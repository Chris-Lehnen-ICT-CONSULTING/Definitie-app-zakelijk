---
id: US-206
title: Extract Business Logic from UI Layer
status: open
priority: HIGH
story_points: 8
owner: development-team
applies_to: definitie-app@current
canonical: false
last_verified: 2025-10-02
epic_id: EPIC-020-PHOENIX
assignee: team
created_date: 2025-01-18
updated_date: 2025-01-18
labels: [phoenix, refactoring, architecture, separation-of-concerns, business-logic]
acceptance_criteria:
  - All business logic moved to service layer
  - UI layer only handles presentation
  - Clear separation between UI and business logic
  - All business rules testable without UI
  - No direct database access from UI
definition_of_done:
  - Code review completed
  - Unit tests for all business logic
  - UI tests simplified
  - Architecture documentation updated
  - No business logic in UI files
dependencies:
  - US-204 (V1 to V2 migration)
  - US-205 (god class splitting)
---

# US-206: Extract Business Logic from UI Layer

## User Story
**Als** architect
**Wil ik** alle business logica uit de UI laag halen
**Zodat** business rules onafhankelijk van de UI getest en hergebruikt kunnen worden

## Current State Analysis

### Problems in Current UI Layer
```python
# Current anti-pattern in UI files:
def render_validation_tab():
    # UI rendering
    st.header("Validatie")

    # PROBLEM: Business logic in UI
    if len(definition.term) > 100:  # Business rule
        st.error("Term too long")

    # PROBLEM: Direct service calls
    results = validator.validate(definition)

    # PROBLEM: Complex calculations in UI
    score = sum(r.score for r in results) / len(results)  # Business logic

    # PROBLEM: Data transformation in UI
    formatted_results = [
        {"rule": r.rule_id, "status": "✓" if r.passed else "✗"}
        for r in results
    ]
```

## Acceptance Criteria

### Separation Requirements
- [ ] UI files bevatten GEEN business rules
- [ ] UI files bevatten GEEN directe database calls
- [ ] UI files bevatten GEEN complexe calculations
- [ ] UI files bevatten GEEN data transformations
- [ ] UI files bevatten ALLEEN rendering en event binding

### Business Logic Organization
- [ ] Alle business rules in service layer
- [ ] Alle validaties in dedicated validators
- [ ] Alle calculations in domain models
- [ ] Alle data transformations in mappers/converters

### Testing Requirements
- [ ] Business logic 100% testbaar zonder Streamlit
- [ ] UI tests focussen alleen op rendering
- [ ] Geen mocking van business logic in UI tests
- [ ] Business logic tests zonder UI dependencies

### Architecture Compliance
- [ ] Clean Architecture principles gevolgd
- [ ] Dependency flow: UI → Application → Domain
- [ ] No circular dependencies
- [ ] Clear interface boundaries

## Technical Implementation Notes

### Target Architecture

```
src/
├── domain/                 # Business Logic & Rules
│   ├── models/
│   │   ├── definition.py   # Domain model with business rules
│   │   ├── validation.py   # Validation domain logic
│   │   └── scoring.py      # Scoring algorithms
│   ├── rules/
│   │   ├── term_rules.py   # Term validation rules
│   │   ├── definition_rules.py  # Definition validation rules
│   │   └── quality_rules.py     # Quality assessment rules
│   └── services/
│       ├── definition_service.py  # Definition business logic
│       ├── validation_service.py  # Validation orchestration
│       └── scoring_service.py     # Score calculations
├── application/            # Application Services
│   ├── use_cases/
│   │   ├── generate_definition.py
│   │   ├── validate_definition.py
│   │   └── export_definition.py
│   └── interfaces/
│       ├── repository_interface.py
│       └── ai_service_interface.py
└── ui/                    # Presentation Only
    ├── presenters/        # UI-specific formatting
    │   ├── definition_presenter.py
    │   ├── validation_presenter.py
    │   └── score_presenter.py
    └── tabs/
        └── *.py           # Pure rendering
```

### Phase 1: Identify Business Logic in UI (Day 1)

```python
# Scan for patterns indicating business logic in UI
patterns_to_find = [
    "if .* > .*:",          # Conditional business rules
    "if .* < .*:",          # Threshold checks
    "calculate_",           # Calculations
    "validate_",            # Validations
    "transform_",           # Data transformations
    ".save()",              # Direct persistence
    ".query()",             # Direct queries
    "SELECT",               # SQL in UI
    "for .* in .*:",        # Complex iterations
    "sum(",                 # Aggregations
    "max(",                 # Business calculations
    "min(",
]
```

### Phase 2: Extract Business Rules (Day 2-3)

```python
# Before: Business logic in UI
def render_definition():
    definition = st.session_state.get("definition")

    # Business rule in UI
    if len(definition.term) > 100:
        st.error("Term mag niet langer zijn dan 100 karakters")

    # Complex validation in UI
    if not definition.term[0].isupper():
        st.warning("Term moet met hoofdletter beginnen")

    # Score calculation in UI
    score = calculate_quality_score(definition)
    if score < 0.7:
        st.error("Kwaliteit onvoldoende")

# After: Clean separation
# domain/rules/term_rules.py
class TermRules:
    MAX_LENGTH = 100

    @staticmethod
    def validate_length(term: str) -> ValidationResult:
        if len(term) > TermRules.MAX_LENGTH:
            return ValidationResult.failure(
                f"Term mag niet langer zijn dan {TermRules.MAX_LENGTH} karakters"
            )
        return ValidationResult.success()

    @staticmethod
    def validate_capitalization(term: str) -> ValidationResult:
        if not term[0].isupper():
            return ValidationResult.warning(
                "Term moet met hoofdletter beginnen"
            )
        return ValidationResult.success()

# domain/services/scoring_service.py
class ScoringService:
    def calculate_quality_score(self, definition: Definition) -> QualityScore:
        # Complex business logic here
        return QualityScore(value=score, threshold=0.7)

# ui/tabs/definition_tab.py (cleaned)
def render_definition():
    definition = st.session_state.get("definition")
    presenter = DefinitionPresenter(
        term_validator=container.get(TermRules),
        scoring_service=container.get(ScoringService)
    )

    # Pure presentation
    validation_results = presenter.validate(definition)
    for result in validation_results:
        if result.is_error:
            st.error(result.message)
        elif result.is_warning:
            st.warning(result.message)
```

### Phase 3: Extract Data Transformations (Day 4)

```python
# Before: Data transformation in UI
def display_validation_results():
    results = st.session_state.get("validation_results")

    # Data transformation in UI
    grouped = {}
    for result in results:
        category = result.rule_id.split("-")[0]
        if category not in grouped:
            grouped[category] = []
        grouped[category].append({
            "rule": result.rule_id,
            "status": "✓" if result.passed else "✗",
            "score": round(result.score * 100, 2)
        })

    for category, items in grouped.items():
        st.subheader(category)
        st.table(items)

# After: Transformation in service
# application/transformers/validation_transformer.py
class ValidationTransformer:
    def group_by_category(self, results: List[ValidationResult]) -> Dict[str, List[ValidationDisplay]]:
        grouped = defaultdict(list)
        for result in results:
            category = self._extract_category(result.rule_id)
            grouped[category].append(self._to_display_model(result))
        return dict(grouped)

    def _to_display_model(self, result: ValidationResult) -> ValidationDisplay:
        return ValidationDisplay(
            rule=result.rule_id,
            status=self._format_status(result.passed),
            score=self._format_score(result.score)
        )

# ui/tabs/validation_tab.py (cleaned)
def display_validation_results():
    results = st.session_state.get("validation_results")
    transformer = container.get(ValidationTransformer)

    # Pure presentation
    grouped_results = transformer.group_by_category(results)
    for category, items in grouped_results.items():
        st.subheader(category)
        st.table([item.to_dict() for item in items])
```

### Phase 4: Extract Calculations (Day 5)

```python
# Before: Calculations in UI
def show_statistics():
    definitions = repository.get_all()

    # Complex calculations in UI
    total_score = sum(d.score for d in definitions)
    avg_score = total_score / len(definitions) if definitions else 0

    passed = [d for d in definitions if d.score >= 0.7]
    pass_rate = len(passed) / len(definitions) * 100

    # Statistical calculations in UI
    scores = [d.score for d in definitions]
    std_dev = statistics.stdev(scores) if len(scores) > 1 else 0

    st.metric("Gemiddelde Score", f"{avg_score:.2f}")
    st.metric("Slagingspercentage", f"{pass_rate:.1f}%")
    st.metric("Standaardafwijking", f"{std_dev:.3f}")

# After: Calculations in domain service
# domain/services/statistics_service.py
class StatisticsService:
    def calculate_statistics(self, definitions: List[Definition]) -> DefinitionStatistics:
        if not definitions:
            return DefinitionStatistics.empty()

        scores = [d.score for d in definitions]
        return DefinitionStatistics(
            average_score=self._calculate_average(scores),
            pass_rate=self._calculate_pass_rate(definitions),
            standard_deviation=self._calculate_std_dev(scores),
            total_count=len(definitions),
            passed_count=self._count_passed(definitions)
        )

    def _calculate_pass_rate(self, definitions: List[Definition]) -> float:
        passed = self._count_passed(definitions)
        return (passed / len(definitions)) * 100 if definitions else 0

# ui/tabs/statistics_tab.py (cleaned)
def show_statistics():
    definitions = repository.get_all()
    stats_service = container.get(StatisticsService)

    # Pure presentation
    stats = stats_service.calculate_statistics(definitions)
    st.metric("Gemiddelde Score", f"{stats.average_score:.2f}")
    st.metric("Slagingspercentage", f"{stats.pass_rate:.1f}%")
    st.metric("Standaardafwijking", f"{stats.standard_deviation:.3f}")
```

### Phase 5: Create Use Cases (Day 6)

```python
# application/use_cases/generate_definition.py
class GenerateDefinitionUseCase:
    def __init__(self, generator, validator, repository):
        self.generator = generator
        self.validator = validator
        self.repository = repository

    def execute(self, request: GenerateDefinitionRequest) -> GenerateDefinitionResponse:
        # Validate request
        validation = self.validator.validate_request(request)
        if not validation.is_valid:
            return GenerateDefinitionResponse.failure(validation.errors)

        # Generate definition
        definition = self.generator.generate(
            term=request.term,
            context=request.context
        )

        # Validate result
        quality = self.validator.validate_definition(definition)

        # Save if quality sufficient
        if quality.score >= 0.7:
            self.repository.save(definition)

        return GenerateDefinitionResponse.success(
            definition=definition,
            quality=quality
        )

# ui/handlers/generation_handler.py (thin UI adapter)
class GenerationHandler:
    def __init__(self, use_case: GenerateDefinitionUseCase):
        self.use_case = use_case

    def handle_generate_click(self, term: str, context: str):
        request = GenerateDefinitionRequest(term=term, context=context)
        response = self.use_case.execute(request)

        if response.is_success:
            st.session_state["definition"] = response.definition
            st.success("Definitie gegenereerd")
        else:
            for error in response.errors:
                st.error(error)
```

## Testing Strategy

### Business Logic Tests (No UI)
```python
# tests/domain/rules/test_term_rules.py
def test_term_length_validation():
    result = TermRules.validate_length("a" * 101)
    assert not result.is_valid
    assert "100 karakters" in result.message

# tests/domain/services/test_scoring_service.py
def test_quality_score_calculation():
    service = ScoringService()
    definition = Definition(term="Test", text="Een test")
    score = service.calculate_quality_score(definition)
    assert 0 <= score.value <= 1

# tests/application/use_cases/test_generate_definition.py
def test_generate_definition_use_case():
    use_case = GenerateDefinitionUseCase(
        generator=MockGenerator(),
        validator=MockValidator(),
        repository=MockRepository()
    )
    response = use_case.execute(request)
    assert response.is_success
```

### UI Tests (Pure Presentation)
```python
# tests/ui/test_definition_tab.py
def test_definition_display():
    # Only test that UI renders correctly
    # No business logic testing here
    with patch('streamlit.write') as mock_write:
        render_definition(mock_definition)
        mock_write.assert_called_with(mock_definition.text)
```

## Migration Checklist

### Per UI File
- [ ] Identify all business logic
- [ ] Extract to appropriate service/domain class
- [ ] Replace with service calls
- [ ] Create presenter if needed
- [ ] Update tests
- [ ] Verify functionality unchanged

### Common Patterns to Extract
- [ ] Validations → Domain Rules
- [ ] Calculations → Domain Services
- [ ] Data transformations → Application Transformers
- [ ] Database queries → Repository Pattern
- [ ] Complex conditions → Business Rules
- [ ] Aggregations → Statistics Services

## Definition of Done

- [ ] **Code Analysis**:
  - Zero business logic in `src/ui/` directory
  - All validations in domain layer
  - All calculations in services
  - All data access through repositories

- [ ] **Testing**:
  - 100% test coverage for business logic
  - Business logic tests run without Streamlit
  - UI tests simplified to presentation only
  - Integration tests still passing

- [ ] **Architecture**:
  - Clean Architecture boundaries enforced
  - Dependency rules followed (UI → App → Domain)
  - No circular dependencies
  - Clear separation of concerns

- [ ] **Documentation**:
  - Architecture diagram updated
  - Domain model documented
  - Business rules catalogued
  - Service interfaces documented

- [ ] **Quality Gates**:
  - Pylint score ≥ 9.0
  - Cyclomatic complexity < 10 per function
  - No code duplication
  - Type hints complete

## Success Metrics

### Before
- Business logic lines in UI: ~800
- UI test complexity: High
- Business rule testability: 40%
- Mock objects in UI tests: >50

### After
- Business logic lines in UI: 0
- UI test complexity: Low
- Business rule testability: 100%
- Mock objects in UI tests: <5

## Risks & Mitigations

### Risk: Over-abstraction
**Mitigation**:
- Follow YAGNI principle
- Maximum 3 layers of abstraction
- Review each abstraction for value

### Risk: Performance Impact
**Mitigation**:
- Profile before/after
- Use lazy loading
- Cache expensive operations

### Risk: Increased Complexity
**Mitigation**:
- Clear naming conventions
- Comprehensive documentation
- Team training on new architecture

## Notes

### Signs of Business Logic in UI
```python
# RED FLAGS in UI code:
- if/else with business conditions
- Mathematical calculations
- Data validations
- String manipulations for business reasons
- Date calculations
- Direct database access
- API calls
- File I/O for business data
- Complex loops with business logic
- Business constants/thresholds
```

### Extraction Priority
1. **High Priority**: Validations and rules
2. **Medium Priority**: Calculations and scoring
3. **Low Priority**: Simple formatting

### Architecture Principles
- UI is a humble object
- Business logic is UI-agnostic
- Domain models are framework-independent
- Use cases orchestrate business operations

## Related Items
- Parent: [[EPIC-020-PHOENIX]]
- Depends on: [[US-204]] (V2 migration), [[US-205]] (god class split)
- Enables: [[US-207]] (component library), [[US-208]] (UI testing)
- Related: [[EPIC-019]] (validation rules extraction)