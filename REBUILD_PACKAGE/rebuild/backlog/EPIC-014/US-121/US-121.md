---
id: US-121
epic: EPIC-014
titel: Implementeer Stagnation Detector
status: open
prioriteit: P2
story_points: 5
aangemaakt: 2025-09-30
bijgewerkt: 2025-09-30
owner: tbd
applies_to: definitie-app@current
canonical: false
last_verified: 2025-09-30
---

# US-121: Implementeer Stagnation Detector

## User Story
**Als** iteratie controller  
**Wil ik** stagnatie in verbetering detecteren  
**Zodat** nutteloze iteraties voorkomen worden  

## Status
**Status**: TODO  
**Priority**: HIGH  
**Story Points**: 3  
**Epic**: [EPIC-014: Business Logic Refactoring](../EPIC-014.md)  

## Business Context
Voorkomt dat het systeem blijft itereren zonder werkelijke verbetering. Detecteert wanneer feedback niet meer helpt en suggereert fundamentele herformulering.

## Acceptance Criteria
- [ ] Detecteer stagnatie: score verschil <0.05 tussen iteraties
- [ ] Detecteer regressie: huidige score < vorige score
- [ ] Detecteer oscillatie: scores gaan op en neer
- [ ] Genereer specifieke feedback bij stagnatie
- [ ] Trigger early stop bij stagnatie na iteratie 2

## Technical Details

### Stagnation Detection Algorithm
```python
class StagnationDetector:
    STAGNATION_THRESHOLD = 0.05
    
    def analyze(self, score_history: List[float], iteration: int) -> StagnationResult:
        if len(score_history) < 2:
            return StagnationResult(detected=False)
        
        current = score_history[-1]
        previous = score_history[-2]
        improvement = current - previous
        
        # Regressie detectie
        if improvement < 0:
            return StagnationResult(
                detected=True,
                type="regression",
                message=f"Score gedaald met {-improvement:.3f}",
                suggestion="Vorige aanpak werkte beter. Probeer andere benadering."
            )
        
        # Stagnatie detectie
        if improvement < self.STAGNATION_THRESHOLD:
            return StagnationResult(
                detected=True,
                type="stagnation",
                message=f"Minimale verbetering: {improvement:.3f}",
                suggestion="Score stagneert. Probeer fundamenteel andere formulering."
            )
        
        # Oscillatie detectie (3+ scores nodig)
        if len(score_history) >= 3:
            if self._detect_oscillation(score_history[-3:]):
                return StagnationResult(
                    detected=True,
                    type="oscillation",
                    message="Scores oscilleren zonder verbetering",
                    suggestion="Patroon gedetecteerd. Breek uit huidige aanpak."
                )
        
        return StagnationResult(detected=False)
    
    def _detect_oscillation(self, recent_scores):
        # Check voor up-down-up of down-up-down patroon
        diffs = [recent_scores[i+1] - recent_scores[i] 
                for i in range(len(recent_scores)-1)]
        
        # Oscillatie als tekens wisselen
        return diffs[0] * diffs[1] < 0  # Verschillende tekens
```

### Integration with Feedback
```python
def generate_stagnation_feedback(stagnation_result, iteration):
    if not stagnation_result.detected:
        return []
    
    feedback = [stagnation_result.suggestion]
    
    if iteration >= 2 and stagnation_result.type == "stagnation":
        feedback.append("Overweeg volledig nieuwe aanpak of accepteer huidige versie.")
    
    if stagnation_result.type == "regression":
        feedback.insert(0, "⚠️ WAARSCHUWING: Kwaliteit verslechterd!")
    
    return feedback
```

## Test Cases
1. Test stagnatie: [0.60, 0.64, 0.67] → detected (0.03 < 0.05)
2. Test regressie: [0.70, 0.65] → detected met warning
3. Test oscillatie: [0.60, 0.70, 0.65] → detected
4. Test normale verbetering: [0.60, 0.70, 0.80] → not detected
5. Test eerste iteratie: [0.60] → not detected (te weinig data)

## Configuration
```yaml
stagnation_detection:
  threshold: 0.05  # 5% minimum improvement required
  enable_early_stop: true
  min_iterations_before_stop: 2
```

## Dependencies
- Score history van iteraties
- Feedback builder voor suggesties

## Notes
- Threshold van 0.05 is empirisch bepaald uit productie data
- Early stop bespaart gemiddeld 1.5 iteraties zonder kwaliteitsverlies