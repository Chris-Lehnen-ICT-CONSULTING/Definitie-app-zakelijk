---
id: US-402
epic: EPIC-021
titel: Version Comparison and Diff Viewer
type: feature
status: proposed
prioriteit: HIGH
story_points: 5
sprint: backlog
aangemaakt: 2025-09-29
bijgewerkt: 2025-09-29
owner: product-owner
applies_to: definitie-app@current
canonical: false
last_verified: 2025-10-02
vereisten:
  - REQ-101
toegewezen_aan: development-team
---

# US-402: Version Comparison and Diff Viewer

**Epic:** EPIC-021 - Definitie Geschiedenis & Audit Trail Management

## Gebruikersverhaal

**Als een** juridisch professional
**wil ik** verschillende versies van definities kunnen vergelijken
**zodat** ik kan zien wat er precies is veranderd tussen versies

## Acceptance Criteria

### Functional Requirements

- [ ] **Version Selection**
  - Select two versions to compare
  - Select multiple versions for timeline comparison
  - Quick compare with previous version
  - Compare across branches
  - Compare with published version

- [ ] **Diff Visualization**
  - Side-by-side comparison view
  - Inline diff view with highlights
  - Unified diff view
  - Word-level diff granularity
  - Character-level diff for small changes

- [ ] **Change Highlighting**
  - Green for additions
  - Red for deletions
  - Yellow for modifications
  - Gray for unchanged context
  - Special marking for moved content

- [ ] **Diff Types**
  - Text content differences
  - Metadata changes
  - Validation result changes
  - Example changes
  - Source/reference changes

- [ ] **Export Options**
  - Export diff as PDF
  - Export as HTML report
  - Export as JSON diff
  - Share diff via link
  - Print-friendly view

### UI Requirements

- [ ] **Comparison Interface**
  ```
  +------------------+------------------+
  | Version 1.0      | Version 2.0      |
  | 2024-01-15       | 2024-02-20       |
  +------------------+------------------+
  | Original text    | Modified text    |
  | with some        | with [+new+]     |
  | [-removed-]      | content added    |
  | content          | and changed      |
  +------------------+------------------+
  ```

- [ ] **Timeline View**
  - Visual timeline of all versions
  - Clickable points for each version
  - Highlight major changes
  - Show change metrics

- [ ] **Filter Options**
  - Show only changes
  - Filter by field type
  - Filter by change type
  - Search within changes

### Technical Requirements

- [ ] **Diff Service**
  ```python
  class DiffService:
      def compare_versions(
          self,
          version_a: Version,
          version_b: Version,
          options: DiffOptions
      ) -> DiffResult

      def generate_diff_html(
          self,
          diff_result: DiffResult,
          template: str = 'side_by_side'
      ) -> str

      def calculate_change_metrics(
          self,
          diff_result: DiffResult
      ) -> ChangeMetrics
  ```

- [ ] **API Endpoints**
  - GET /api/versions/compare?v1={id}&v2={id}
  - GET /api/definitions/{id}/diff/{v1}/{v2}
  - POST /api/diff/export
  - GET /api/diff/metrics

## Implementation Details

### Diff Algorithm Implementation

```python
import difflib
from dataclasses import dataclass
from typing import List, Tuple, Optional
from enum import Enum

class ChangeType(Enum):
    ADDED = "added"
    DELETED = "deleted"
    MODIFIED = "modified"
    MOVED = "moved"
    UNCHANGED = "unchanged"

@dataclass
class DiffSegment:
    type: ChangeType
    content_a: Optional[str]
    content_b: Optional[str]
    line_numbers_a: Tuple[int, int]
    line_numbers_b: Tuple[int, int]
    similarity: float

class AdvancedDiffService:
    def __init__(self):
        self.word_differ = difflib.Differ()
        self.sequence_matcher = difflib.SequenceMatcher()

    def compare_definitions(
        self,
        version_a: dict,
        version_b: dict
    ) -> dict:
        """Compare two definition versions"""

        diff_result = {
            'metadata': self._compare_metadata(version_a, version_b),
            'content': self._compare_content(version_a, version_b),
            'examples': self._compare_examples(
                version_a.get('voorbeelden', []),
                version_b.get('voorbeelden', [])
            ),
            'validation': self._compare_validation(
                version_a.get('validatie_resultaten'),
                version_b.get('validatie_resultaten')
            ),
            'metrics': self._calculate_metrics(version_a, version_b)
        }

        return diff_result

    def _compare_content(
        self,
        content_a: str,
        content_b: str
    ) -> List[DiffSegment]:
        """Perform word-level diff on content"""

        # Split into words while preserving whitespace
        words_a = self._tokenize(content_a)
        words_b = self._tokenize(content_b)

        # Use sequence matcher for intelligent diff
        self.sequence_matcher.set_seqs(words_a, words_b)
        opcodes = self.sequence_matcher.get_opcodes()

        segments = []
        for tag, i1, i2, j1, j2 in opcodes:
            if tag == 'equal':
                segments.append(DiffSegment(
                    type=ChangeType.UNCHANGED,
                    content_a=' '.join(words_a[i1:i2]),
                    content_b=' '.join(words_b[j1:j2]),
                    line_numbers_a=(i1, i2),
                    line_numbers_b=(j1, j2),
                    similarity=1.0
                ))
            elif tag == 'delete':
                segments.append(DiffSegment(
                    type=ChangeType.DELETED,
                    content_a=' '.join(words_a[i1:i2]),
                    content_b=None,
                    line_numbers_a=(i1, i2),
                    line_numbers_b=(j1, j2),
                    similarity=0.0
                ))
            elif tag == 'insert':
                segments.append(DiffSegment(
                    type=ChangeType.ADDED,
                    content_a=None,
                    content_b=' '.join(words_b[j1:j2]),
                    line_numbers_a=(i1, i2),
                    line_numbers_b=(j1, j2),
                    similarity=0.0
                ))
            elif tag == 'replace':
                # Check if content was moved
                similarity = self._calculate_similarity(
                    ' '.join(words_a[i1:i2]),
                    ' '.join(words_b[j1:j2])
                )

                if similarity > 0.8:
                    change_type = ChangeType.MODIFIED
                else:
                    change_type = ChangeType.MODIFIED

                segments.append(DiffSegment(
                    type=change_type,
                    content_a=' '.join(words_a[i1:i2]),
                    content_b=' '.join(words_b[j1:j2]),
                    line_numbers_a=(i1, i2),
                    line_numbers_b=(j1, j2),
                    similarity=similarity
                ))

        return segments

    def _tokenize(self, text: str) -> List[str]:
        """Tokenize text preserving whitespace"""
        import re
        return re.findall(r'\S+|\s+', text)

    def _calculate_similarity(self, text_a: str, text_b: str) -> float:
        """Calculate similarity between two text segments"""
        return difflib.SequenceMatcher(None, text_a, text_b).ratio()
```

### UI Component

```python
import streamlit as st
from typing import Optional

class VersionComparisonUI:
    def __init__(self, diff_service: AdvancedDiffService):
        self.diff_service = diff_service

    def render_comparison_view(
        self,
        definition_id: int,
        version_a_id: Optional[int] = None,
        version_b_id: Optional[int] = None
    ):
        """Render version comparison interface"""

        st.header("ðŸ“Š Versie Vergelijking")

        # Version selector
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Versie A")
            versions = self._get_versions(definition_id)
            version_a = st.selectbox(
                "Selecteer eerste versie",
                versions,
                format_func=lambda v: f"v{v.number} - {v.date}"
            )

        with col2:
            st.subheader("Versie B")
            version_b = st.selectbox(
                "Selecteer tweede versie",
                versions,
                format_func=lambda v: f"v{v.number} - {v.date}"
            )

        # View mode selector
        view_mode = st.radio(
            "Weergave modus",
            ["Side-by-side", "Inline", "Unified"],
            horizontal=True
        )

        # Perform comparison
        if st.button("Vergelijk Versies", type="primary"):
            diff_result = self.diff_service.compare_definitions(
                version_a.content,
                version_b.content
            )

            # Render diff based on view mode
            if view_mode == "Side-by-side":
                self._render_side_by_side(diff_result)
            elif view_mode == "Inline":
                self._render_inline(diff_result)
            else:
                self._render_unified(diff_result)

            # Show metrics
            self._render_metrics(diff_result['metrics'])

    def _render_side_by_side(self, diff_result: dict):
        """Render side-by-side diff view"""
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### Origineel")
            for segment in diff_result['content']:
                if segment.type != ChangeType.ADDED:
                    self._render_segment(segment, 'left')

        with col2:
            st.markdown("### Nieuw")
            for segment in diff_result['content']:
                if segment.type != ChangeType.DELETED:
                    self._render_segment(segment, 'right')

    def _render_segment(self, segment: DiffSegment, side: str):
        """Render a diff segment with appropriate styling"""
        style_map = {
            ChangeType.ADDED: "background-color: #d4f5d4;",
            ChangeType.DELETED: "background-color: #f5d4d4;",
            ChangeType.MODIFIED: "background-color: #f5f5d4;",
            ChangeType.UNCHANGED: ""
        }

        style = style_map.get(segment.type, "")
        content = segment.content_a if side == 'left' else segment.content_b

        if content:
            st.markdown(
                f'<p style="{style}">{content}</p>',
                unsafe_allow_html=True
            )
```

## Test Scenarios

### Unit Tests

```python
def test_basic_diff():
    """Test basic text diffing"""
    service = AdvancedDiffService()
    result = service.compare_content(
        "The quick brown fox",
        "The slow brown fox"
    )
    assert any(s.type == ChangeType.MODIFIED for s in result)

def test_complex_changes():
    """Test complex multi-field changes"""
    version_a = {
        'term': 'Contract',
        'definitie': 'Een overeenkomst',
        'voorbeelden': ['Voorbeeld 1']
    }
    version_b = {
        'term': 'Contract',
        'definitie': 'Een bindende overeenkomst',
        'voorbeelden': ['Voorbeeld 1', 'Voorbeeld 2']
    }
    result = service.compare_definitions(version_a, version_b)
    assert result['metrics']['total_changes'] > 0
```

### Integration Tests

- Test UI rendering with real data
- Test performance with large diffs
- Test export functionality
- Test diff caching
- Test concurrent comparisons

## Definition of Done

- [ ] Diff service implemented
- [ ] UI components created
- [ ] All view modes functional
- [ ] Export functionality working
- [ ] Performance optimized
- [ ] Unit tests passing (>90% coverage)
- [ ] Integration tests passing
- [ ] Documentation complete
- [ ] Code review completed

## Dependencies

- Version Control Service (US-400)
- Diff library (difflib or alternative)
- PDF generation library
- HTML template engine

## Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Large diff performance | HIGH | Implement pagination, lazy loading |
| Complex merge scenarios | MEDIUM | Limit to 2-way comparison initially |
| UI complexity | MEDIUM | Start with simple view, iterate |

## Notes

- Consider implementing 3-way merge view for future
- Evaluate specialized diff libraries for better performance
- Plan for syntax highlighting in code definitions
- Consider implementing blame view showing who changed what