---
id: US-324
epic: EPIC-002
status: open
prioriteit: MEDIUM
story_points: 5
sprint: next
owner: backend
applies_to: definitie-app@current
canonical: false
last_verified: 2025-10-02
created_at: 2025-09-19
dependencies: [US-193, US-213]
---

# US-324 â€” Implementeer Consistente Error Handling Patterns

## Doel
Standaardiseer error handling door de hele applicatie met consistente patterns, duidelijke error messages en proper error propagation voor betere maintainability en user experience.

## Context
Uit de US-193 multi-agent review (P3-16) blijkt dat error handling inconsistent is met verschillende patterns, onduidelijke messages en soms verloren error context. Dit maakt debugging moeilijk en leidt tot poor user experience.

## Scope

### In scope
- Definieer standaard error handling patterns
- CreÃ«er custom exception hierarchy
- Implementeer error context preservation
- Standaardiseer error messages en codes
- Add error recovery strategies
- Implementeer proper async error handling

### Niet in scope
- Error monitoring/alerting (aparte US)
- Retry mechanisme redesign
- Circuit breaker patterns

## Acceptance Criteria

### Functioneel
- [ ] Alle errors hebben duidelijke, actionable messages
- [ ] Error codes voor machine-readable errors
- [ ] Context behouden door error chain
- [ ] User-friendly error messages in UI
- [ ] Graceful degradation waar mogelijk

### Technisch
- [ ] Custom exception classes voor domein errors
- [ ] Consistent try-except patterns
- [ ] Error context via exception chaining
- [ ] Async error handling correct
- [ ] No bare except clauses

## Implementatie

### 1. Custom Exception Hierarchy
```python
# src/exceptions/base.py
from typing import Optional, Dict, Any
from enum import Enum

class ErrorCode(Enum):
    """Standardized error codes for machine processing."""
    # Validation errors (1xxx)
    VALIDATION_FAILED = "ERR_1001"
    INVALID_INPUT = "ERR_1002"
    RULE_EXECUTION_FAILED = "ERR_1003"

    # Generation errors (2xxx)
    GENERATION_FAILED = "ERR_2001"
    AI_SERVICE_ERROR = "ERR_2002"
    PROMPT_BUILD_FAILED = "ERR_2003"
    RATE_LIMIT_EXCEEDED = "ERR_2004"

    # Data errors (3xxx)
    RECORD_NOT_FOUND = "ERR_3001"
    DATABASE_ERROR = "ERR_3002"
    DATA_CORRUPTION = "ERR_3003"

    # Service errors (4xxx)
    SERVICE_UNAVAILABLE = "ERR_4001"
    EXTERNAL_API_ERROR = "ERR_4002"
    TIMEOUT = "ERR_4003"

    # System errors (5xxx)
    CONFIGURATION_ERROR = "ERR_5001"
    INITIALIZATION_ERROR = "ERR_5002"
    UNEXPECTED_ERROR = "ERR_5999"

class DefinitieAppException(Exception):
    """Base exception for all application errors."""

    def __init__(
        self,
        message: str,
        code: ErrorCode = ErrorCode.UNEXPECTED_ERROR,
        details: Optional[Dict[str, Any]] = None,
        user_message: Optional[str] = None,
        cause: Optional[Exception] = None
    ):
        super().__init__(message)
        self.code = code
        self.details = details or {}
        self.user_message = user_message or message
        self.cause = cause

    def to_dict(self) -> Dict[str, Any]:
        """Convert exception to dictionary for API responses."""
        return {
            "error": {
                "code": self.code.value,
                "message": self.user_message,
                "details": self.details,
                "type": self.__class__.__name__
            }
        }

# Domain-specific exceptions
class ValidationException(DefinitieAppException):
    """Exception for validation failures."""
    def __init__(self, message: str, **kwargs):
        super().__init__(
            message,
            code=ErrorCode.VALIDATION_FAILED,
            **kwargs
        )

class GenerationException(DefinitieAppException):
    """Exception for generation failures."""
    def __init__(self, message: str, **kwargs):
        super().__init__(
            message,
            code=ErrorCode.GENERATION_FAILED,
            **kwargs
        )

class DataException(DefinitieAppException):
    """Exception for data-related errors."""
    def __init__(self, message: str, **kwargs):
        super().__init__(
            message,
            code=ErrorCode.DATABASE_ERROR,
            **kwargs
        )

class ServiceException(DefinitieAppException):
    """Exception for service-related errors."""
    def __init__(self, message: str, **kwargs):
        super().__init__(
            message,
            code=ErrorCode.SERVICE_UNAVAILABLE,
            **kwargs
        )
```

### 2. Error Handling Patterns
```python
# src/exceptions/handlers.py
import logging
import functools
from typing import TypeVar, Callable, Optional, Type, Tuple
from contextlib import contextmanager

T = TypeVar('T')

def handle_errors(
    *exception_handlers: Tuple[Type[Exception], ErrorCode, str],
    default_message: str = "An unexpected error occurred",
    logger: Optional[logging.Logger] = None,
    raise_original: bool = False
) -> Callable[[Callable[..., T]], Callable[..., T]]:
    """
    Decorator for consistent error handling.

    Usage:
        @handle_errors(
            (ValueError, ErrorCode.INVALID_INPUT, "Invalid input provided"),
            (KeyError, ErrorCode.RECORD_NOT_FOUND, "Record not found"),
            logger=logger
        )
        def my_function():
            ...
    """
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> T:
            try:
                return func(*args, **kwargs)
            except Exception as e:
                # Check registered handlers
                for exc_type, code, message in exception_handlers:
                    if isinstance(e, exc_type):
                        if logger:
                            logger.error(
                                f"{func.__name__} failed: {message}",
                                exc_info=True,
                                extra={'error_code': code.value}
                            )

                        if raise_original:
                            raise

                        raise DefinitieAppException(
                            message=str(e),
                            code=code,
                            user_message=message,
                            cause=e
                        ) from e

                # Default handler
                if logger:
                    logger.error(
                        f"{func.__name__} failed with unexpected error",
                        exc_info=True
                    )

                if raise_original:
                    raise

                raise DefinitieAppException(
                    message=str(e),
                    code=ErrorCode.UNEXPECTED_ERROR,
                    user_message=default_message,
                    cause=e
                ) from e

        return wrapper
    return decorator

@contextmanager
def error_context(
    operation: str,
    logger: Optional[logging.Logger] = None,
    error_class: Type[DefinitieAppException] = DefinitieAppException,
    **context_details
):
    """
    Context manager for error handling with context preservation.

    Usage:
        with error_context("user_validation", logger=logger, user_id=123):
            # operations that might fail
    """
    try:
        if logger:
            logger.debug(f"Starting {operation}", extra=context_details)
        yield
    except DefinitieAppException:
        # Re-raise application exceptions with added context
        raise
    except Exception as e:
        if logger:
            logger.error(
                f"Failed {operation}",
                exc_info=True,
                extra=context_details
            )
        raise error_class(
            message=f"Failed to {operation}: {str(e)}",
            details=context_details,
            cause=e
        ) from e
```

### 3. Async Error Handling
```python
# src/exceptions/async_handlers.py
import asyncio
from typing import TypeVar, Callable, Awaitable

T = TypeVar('T')

def async_handle_errors(*args, **kwargs):
    """Async version of handle_errors decorator."""
    def decorator(func: Callable[..., Awaitable[T]]) -> Callable[..., Awaitable[T]]:
        @functools.wraps(func)
        async def wrapper(*func_args, **func_kwargs) -> T:
            try:
                return await func(*func_args, **func_kwargs)
            except asyncio.CancelledError:
                # Don't wrap cancellation
                raise
            except Exception as e:
                # Same error handling logic as sync version
                # ... (similar to handle_errors)
                raise

        return wrapper
    return decorator

async def with_timeout(
    coro: Awaitable[T],
    timeout: float,
    operation: str = "operation"
) -> T:
    """Execute coroutine with timeout and proper error handling."""
    try:
        return await asyncio.wait_for(coro, timeout=timeout)
    except asyncio.TimeoutError:
        raise ServiceException(
            f"{operation} timed out after {timeout} seconds",
            code=ErrorCode.TIMEOUT,
            details={"timeout": timeout, "operation": operation}
        )
```

### 4. Service Integration
```python
# Example: src/services/validation/modular_validation_service.py
from exceptions.base import ValidationException, ErrorCode
from exceptions.handlers import handle_errors, error_context

class ModularValidationService:
    logger = get_logger(__name__)

    @handle_errors(
        (KeyError, ErrorCode.RULE_EXECUTION_FAILED, "Validation rule failed"),
        (ValueError, ErrorCode.INVALID_INPUT, "Invalid validation input"),
        logger=logger
    )
    async def validate_definition(
        self,
        begrip: str,
        text: str,
        **kwargs
    ) -> ValidationDetailsDict:
        """Validate with consistent error handling."""

        with error_context(
            "definition_validation",
            logger=self.logger,
            error_class=ValidationException,
            begrip=begrip,
            text_length=len(text)
        ):
            # Validation logic here
            if not text:
                raise ValidationException(
                    "Definition text cannot be empty",
                    code=ErrorCode.INVALID_INPUT,
                    user_message="Definitie tekst mag niet leeg zijn"
                )

            # ... rest of validation logic
```

### 5. UI Error Display
```python
# src/ui/helpers/error_display.py
import streamlit as st
from exceptions.base import DefinitieAppException, ErrorCode

def display_error(error: Exception) -> None:
    """Display error in UI with appropriate formatting."""
    if isinstance(error, DefinitieAppException):
        # Application error - show user message
        st.error(f"âš ï¸ {error.user_message}")

        # Show details in expander for technical users
        if st.checkbox("Toon technische details"):
            st.json(error.to_dict())

        # Suggest actions based on error code
        if error.code == ErrorCode.RATE_LIMIT_EXCEEDED:
            st.info("ðŸ’¡ Probeer het over enkele minuten opnieuw")
        elif error.code == ErrorCode.SERVICE_UNAVAILABLE:
            st.info("ðŸ’¡ De service is tijdelijk niet beschikbaar")

    else:
        # Unexpected error - generic message
        st.error("âŒ Er is een onverwachte fout opgetreden")
        if st.checkbox("Toon error details"):
            st.exception(error)

def safe_operation(operation: Callable, error_container=None) -> Any:
    """Execute operation with UI error handling."""
    try:
        return operation()
    except Exception as e:
        if error_container:
            with error_container:
                display_error(e)
        else:
            display_error(e)
        return None
```

## Migration Strategy

### Phase 1: Define Exception Hierarchy (Day 1)
- Create exception classes
- Define error codes
- Document patterns

### Phase 2: Critical Services (Day 2-3)
- Update validation services
- Update generation services
- Update data access layer

### Phase 3: UI Layer (Day 4)
- Implement error display helper
- Update all UI components
- Add user-friendly messages

### Phase 4: Cleanup (Day 5)
- Remove bare except clauses
- Add missing error context
- Update tests

## Test Plan

```python
# tests/unit/test_error_handling.py
def test_exception_hierarchy():
    """Test exception inheritance and properties."""
    exc = ValidationException(
        "Test error",
        details={"field": "test"},
        user_message="User friendly message"
    )
    assert exc.code == ErrorCode.VALIDATION_FAILED
    assert exc.user_message == "User friendly message"
    assert exc.details["field"] == "test"

def test_error_handler_decorator():
    """Test error handling decorator."""
    @handle_errors(
        (ValueError, ErrorCode.INVALID_INPUT, "Invalid input")
    )
    def failing_function():
        raise ValueError("Test error")

    with pytest.raises(DefinitieAppException) as exc_info:
        failing_function()

    assert exc_info.value.code == ErrorCode.INVALID_INPUT

def test_error_context_manager():
    """Test error context preservation."""
    with pytest.raises(DefinitieAppException) as exc_info:
        with error_context("test_operation", user_id=123):
            raise ValueError("Test error")

    assert exc_info.value.details["user_id"] == 123
```

## Metrics

### Before
- Bare except clauses: 50+
- Inconsistent error messages: Yes
- Lost error context: Common
- User-unfriendly errors: 80%

### After
- Bare except clauses: 0
- Consistent error patterns: Yes
- Full error context: Always
- User-friendly errors: 100%

## Dependencies
- Python 3.11+ (for exception groups)
- logging module
- Optional: sentry-sdk for error monitoring

## Notities
- P3-16 uit US-193 multi-agent review
- Coordinate met ops voor error monitoring
- Consider structured logging integration
- Update CLAUDE.md met error patterns

## Links
- [Python Exception Best Practices](https://docs.python.org/3/tutorial/errors.html)
- [Error Handling Patterns](https://www.python.org/dev/peps/pep-3134/)
- Parent: US-193