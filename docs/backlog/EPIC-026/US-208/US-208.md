---
id: US-208
titel: "US-208: title: Consolidate validation rules to single source"
epic: EPIC-026
title: Consolidate validation rules to single source
status: open
priority: HIGH
created: 2025-01-18
updated: 2025-01-18
owner: development-team
applies_to: definitie-app@current
canonical: false
last_verified: 2025-10-02
tags:
  - phoenix
  - validation
  - consolidation
  - refactoring
  - toetsregels
estimated_hours: 20
actual_hours: 0
---

# US-208: Consolidate validation rules to single source

## User Story
Als een **systeembeheerder** wil ik **alle validatieregels in één gecentraliseerd systeem** zodat ik **regels consistent kan beheren zonder synchronisatie tussen JSON en Python bestanden**.

## Context
Het huidige systeem heeft een duaal JSON+Python formaat voor validatieregels:
- JSON bestanden in `config/toetsregels/regels/` definiëren metadata
- Python modules in `src/toetsregels/regels/` implementeren logica
- Synchronisatie tussen beide is foutgevoelig
- Duplicatie van regel informatie
- Moeilijk te onderhouden en uit te breiden

Dit leidt tot:
- Inconsistenties tussen JSON metadata en Python implementatie
- Onduidelijkheid over welke bron de "truth" is
- Complexe deployment en testing procedures
- Verhoogd risico op bugs door out-of-sync regels

## Acceptance Criteria

1. **Single Source of Truth**
   - [ ] Alle regel metadata en logica in één locatie
   - [ ] Geen duplicatie tussen configuratie en code
   - [ ] Duidelijke scheiding tussen data en gedrag

2. **Rule Definition Format**
   - [ ] Nieuw unified rule format ontworpen
   - [ ] Backwards compatible met bestaande regel IDs
   - [ ] Support voor alle bestaande regel types (ARAI, CON, ESS, INT, SAM, STR, VER)
   - [ ] Metadata en implementatie in dezelfde module

3. **Migration Completed**
   - [ ] Alle 45+ bestaande regels gemigreerd
   - [ ] Legacy JSON bestanden verwijderd/gearchiveerd
   - [ ] Legacy Python modules gerefactored

4. **Rule Registry System**
   - [ ] Centraal register voor alle validatieregels
   - [ ] Dynamische regel discovery
   - [ ] Rule versioning support
   - [ ] Hot-reload capability voor development

5. **Validation Engine Update**
   - [ ] ModularValidationService aangepast voor nieuw format
   - [ ] ValidationOrchestratorV2 compatible
   - [ ] Performance gelijk of beter dan huidige systeem

## Technical Design

### New Unified Rule Structure
```python
# src/validation/rules/str_01.py
from dataclasses import dataclass
from typing import List, Optional, Dict, Any
from src.validation.base import BaseRule, ValidationResult, Priority

@dataclass
class STR01_GeenHoofdletterBegin(BaseRule):
    """Controleert of definitie niet met hoofdletter begint."""

    # Metadata (voorheen in JSON)
    id = "STR-01"
    name = "Hoofdletter aan begin"
    description = "Definities moeten met een kleine letter beginnen"
    category = "STR"
    priority = Priority.HIGH
    weight = 10.0
    active = True

    # Prompt hints voor AI (zie US-209)
    prompt_hints = {
        "instruction": "Begin de definitie ALTIJD met een kleine letter",
        "example": "betekenis: de zin of het belang van iets",
        "common_mistakes": ["Betekenis", "De betekenis"]
    }

    def validate(self, definition: str, context: Optional[Dict[str, Any]] = None) -> ValidationResult:
        """Implementatie van de validatie logica."""
        if not definition:
            return ValidationResult(
                rule_id=self.id,
                passed=False,
                score=0,
                feedback="Definitie is leeg",
                details={}
            )

        first_char = definition.strip()[0]
        if first_char.isupper():
            return ValidationResult(
                rule_id=self.id,
                passed=False,
                score=0,
                feedback=f"Definitie begint met hoofdletter '{first_char}'",
                suggestions=[
                    f"Wijzig '{first_char}' naar '{first_char.lower()}'",
                    "Begin met een kleine letter tenzij het een eigennaam betreft"
                ],
                details={"first_character": first_char}
            )

        return ValidationResult(
            rule_id=self.id,
            passed=True,
            score=10,
            feedback="Definitie begint correct met kleine letter",
            details={"first_character": first_char}
        )

    def get_examples(self) -> Dict[str, List[str]]:
        """Return positive and negative examples."""
        return {
            "positive": [
                "betekenis: de zin of het belang van iets",
                "proces: een reeks van handelingen"
            ],
            "negative": [
                "Betekenis: de zin of het belang van iets",
                "De betekenis van iets"
            ]
        }
```

### Rule Registry Implementation
```python
# src/validation/registry.py
from typing import Dict, List, Type, Optional
from importlib import import_module
from pathlib import Path
import inspect

class RuleRegistry:
    """Central registry for all validation rules."""

    def __init__(self):
        self._rules: Dict[str, Type[BaseRule]] = {}
        self._categories: Dict[str, List[str]] = {}
        self._loaded = False

    def discover_rules(self, path: Path = Path("src/validation/rules")) -> None:
        """Dynamically discover and load all rules."""
        for rule_file in path.glob("*.py"):
            if rule_file.name.startswith("_"):
                continue

            module_name = f"src.validation.rules.{rule_file.stem}"
            module = import_module(module_name)

            for name, obj in inspect.getmembers(module):
                if (inspect.isclass(obj) and
                    issubclass(obj, BaseRule) and
                    obj != BaseRule):
                    self.register_rule(obj)

        self._loaded = True

    def register_rule(self, rule_class: Type[BaseRule]) -> None:
        """Register a validation rule."""
        rule_id = rule_class.id
        category = rule_class.category

        self._rules[rule_id] = rule_class

        if category not in self._categories:
            self._categories[category] = []
        self._categories[category].append(rule_id)

    def get_rule(self, rule_id: str) -> Optional[Type[BaseRule]]:
        """Get a rule by ID."""
        if not self._loaded:
            self.discover_rules()
        return self._rules.get(rule_id)

    def get_rules_by_category(self, category: str) -> List[Type[BaseRule]]:
        """Get all rules in a category."""
        if not self._loaded:
            self.discover_rules()
        rule_ids = self._categories.get(category, [])
        return [self._rules[rid] for rid in rule_ids]

    def get_all_rules(self) -> Dict[str, Type[BaseRule]]:
        """Get all registered rules."""
        if not self._loaded:
            self.discover_rules()
        return self._rules.copy()
```

### Migration Script
```python
# scripts/migrate_validation_rules.py
def migrate_rule(json_path: Path, python_path: Path, output_path: Path):
    """Migrate a rule from JSON+Python to unified format."""
    # Load JSON metadata
    with open(json_path) as f:
        metadata = json.load(f)

    # Load Python implementation
    spec = importlib.util.spec_from_file_location("rule", python_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)

    # Generate unified rule class
    # ... implementation ...
```

## Implementation Notes

1. **Backwards Compatibility**
   - Maintain existing rule IDs and categories
   - Create adapter layer tijdens migratie periode
   - Gradual migration per category mogelijk

2. **Performance Optimization**
   - Lazy loading van rules
   - Caching van rule instances
   - Parallel validation waar mogelijk

3. **Testing Requirements**
   - Unit tests voor elke gemigreerde regel
   - Integration tests voor rule registry
   - Performance benchmarks voor/na migratie
   - Regression tests voor validation outcomes

4. **Documentation Updates**
   - Update developer guide voor nieuwe rule format
   - Migration guide voor custom rules
   - API documentatie voor rule registry

## Dependencies
- Python 3.11+ (voor dataclasses en type hints)
- No external dependencies required
- Moet compatible zijn met existing validation orchestrator

## Risks & Mitigations
- **Risk**: Breaking existing validation flows
  - **Mitigation**: Extensive testing, feature flags, gradual rollout

- **Risk**: Performance degradation
  - **Mitigation**: Benchmarking, profiling, optimization

- **Risk**: Loss of rule configuration flexibility
  - **Mitigation**: Ensure new format supports all current use cases

## Definition of Done
- [ ] Unified rule format gedefinieerd en gedocumenteerd
- [ ] Rule registry geïmplementeerd en getest
- [ ] Alle 45+ regels gemigreerd naar nieuw format
- [ ] Legacy JSON/Python bestanden gearchiveerd
- [ ] ModularValidationService aangepast voor nieuw format
- [ ] Unit tests voor alle gemigreerde regels (>90% coverage)
- [ ] Integration tests voor complete validation flow
- [ ] Performance benchmarks show geen degradatie
- [ ] Migration guide en documentatie compleet
- [ ] Code review door senior developer
- [ ] Smoke tests in staging environment

## Notes
- Coördineer met US-209 voor scheiding van prompt hints
- Dit is een kritieke refactoring - plan rollback scenario
- Overweeg feature flag voor geleidelijke activatie
- Legacy code pas verwijderen na succesvolle productie run