---
id: US-447
epic: EPIC-026
titel: "US-447: titel: Extract Generation Orchestrator (Phase 2)"
owner: code-architect
prioriteit: P1
status: pending
estimate: 2 weeks
sprint: Phase 2 Week 9-10
created: 2025-10-03
blocked_by: US-454
---

# US-447: Extract Generation Orchestrator (Phase 2)

**Epic:** EPIC-026 - God Object Refactoring
**Owner:** Code Architect
**Priority:** P1 (HIGH - critical path)
**Estimate:** 2 weeks (10 days)
**Sprint:** Phase 2 Week 9-10

---

## User Story

**As a** code architect
**I want to** extract the 380 LOC god method to a dedicated orchestrator service
**So that** the UI layer is thin and the core workflow is testable in isolation

---

## Context

**The God Method:**
```
Location: src/ui/tabbed_interface.py::_handle_definition_generation()
Lines: 821-1201 (380 LOC)
Complexity: 116 (CRITICAL)
Current tests: 0
```

**What it does:**
1. Validates context (min 1 of org/jur/wet)
2. Determines ontological category (async, 6-step protocol)
3. Checks for duplicates (3 outcomes)
4. Integrates document context (PDF processing)
5. Handles regeneration override
6. Orchestrates definition generation (async)
7. Stores results in 15+ session state keys
8. Prepares edit tab state
9. Cleans up regeneration context
10. Shows success message

**Why extract:**
- 380 LOC in 1 method violates SRP
- Impossible to test (mocking st.session_state is nightmare)
- Business logic mixed with UI code
- Cannot reuse workflow outside Streamlit UI

---

## Acceptance Criteria

### AC1: Service Created

**File:** `src/services/orchestrators/generation_orchestrator.py`

```python
class GenerationOrchestrator:
    """Orchestrates definition generation workflow (10 steps)"""

    def __init__(
        self,
        definition_service: DefinitionService,
        category_service: CategoryService,
        document_service: DocumentService,
        duplicate_checker: DuplicateChecker,
        regeneration_service: RegenerationService
    ):
        # Dependency injection (not hardcoded!)
        self.definition_service = definition_service
        self.category_service = category_service
        self.document_service = document_service
        self.duplicate_checker = duplicate_checker
        self.regeneration_service = regeneration_service

    async def generate(
        self,
        request: GenerationRequest
    ) -> GenerationResult:
        """Execute 10-step generation workflow"""
        # Step 1: Validate context
        self._validate_context(request)

        # Step 2: Determine category
        category = await self.category_service.determine(request.begrip)

        # Step 3: Check duplicates
        duplicates = self.duplicate_checker.find(request.begrip, request.context)
        if duplicates:
            return GenerationResult.duplicate_found(duplicates)

        # Step 4-10: Continue workflow...
        # (Implementation details)

        return GenerationResult.success(definition)
```

---

### AC2: UI Layer Thinned

**Before (380 LOC in UI):**
```python
def _handle_definition_generation():
    # 380 lines of business logic in UI!
    if not (org_context or jur_context or wet_context):
        st.error("Minimaal 1 context vereist")
        return

    category = await determine_category(...)
    duplicates = check_duplicates(...)
    # ... 370 more lines
```

**After (<50 LOC in UI):**
```python
def _handle_definition_generation():
    """UI handler - delegates to orchestrator"""
    orchestrator = get_generation_orchestrator()  # From ServiceContainer

    request = GenerationRequest(
        begrip=st.session_state.begrip,
        context=get_current_context(),
        documents=st.session_state.get("uploaded_documents", [])
    )

    try:
        result = await orchestrator.generate(request)

        if result.is_duplicate:
            _show_duplicate_dialog(result.duplicates)
        elif result.is_success:
            _store_result(result)
            st.success("Definitie gegenereerd!")
        else:
            st.error(result.error_message)

    except Exception as e:
        st.error(f"Fout: {e}")
```

**LOC Reduction:** 380 → 50 (87% reduction)

---

### AC3: Clean Async Patterns

**Problem:** Current code has nested `asyncio.run()` (57 files!)

```python
# BAD (current code):
def ui_handler():
    result = asyncio.run(async_function())  # Creates event loop
    # Later...
    result2 = asyncio.run(another_async())  # ERROR if loop running!
```

**Solution:** Proper async boundaries

```python
# GOOD (new pattern):
class GenerationOrchestrator:
    async def generate(self, request):
        # Pure async - no event loop creation
        category = await self.category_service.determine(...)
        definition = await self.definition_service.generate(...)
        return result

# UI layer:
def ui_handler():
    orchestrator = get_generation_orchestrator()
    # Single event loop entry point
    result = run_async(orchestrator.generate(request))
```

**`run_async()` helper:**
```python
def run_async(coro):
    """Safe async bridge for Streamlit (single event loop)"""
    loop = asyncio.get_event_loop()
    if loop.is_running():
        # Use thread pool executor (safe for Streamlit)
        return loop.run_in_executor(None, asyncio.run, coro)
    else:
        return asyncio.run(coro)
```

---

### AC4: Test Coverage

- [ ] 150+ tests for GenerationOrchestrator (from US-454)
- [ ] 95%+ branch coverage
- [ ] All 10 steps tested independently
- [ ] Integration tests: 30 scenarios passing
- [ ] Golden baseline: 100% match for 42 definitions

---

### AC5: State Management

**Problem:** 15+ direct `st.session_state` mutations

**Before:**
```python
st.session_state.category = category
st.session_state.generated_definition = definition
st.session_state.editing_definition_id = definition_id
# ... 12 more
```

**After:** Centralized via SessionStateManager

```python
class GenerationOrchestrator:
    def __init__(self, state_manager: SessionStateManager):
        self.state_manager = state_manager

    async def generate(self, request):
        result = # ... generation logic

        # Atomic state update
        self.state_manager.update({
            "category": result.category,
            "generated_definition": result.definition,
            "editing_definition_id": result.definition_id
        })
```

---

## Technical Requirements

### Service Boundaries

```
GenerationOrchestrator
├── Depends on (injected):
│   ├── CategoryService (determine category)
│   ├── DefinitionService (generate definition)
│   ├── DocumentService (process PDFs)
│   ├── DuplicateChecker (find duplicates)
│   └── RegenerationService (handle overrides)
├── Returns: GenerationResult
└── No UI dependencies (pure business logic)
```

---

### Request/Response DTOs

```python
@dataclass
class GenerationRequest:
    begrip: str
    context: DefinitionContext  # org/jur/wet
    documents: List[UploadedFile]
    regeneration_context: Optional[RegenerationContext] = None

@dataclass
class GenerationResult:
    success: bool
    definition: Optional[str] = None
    category: Optional[str] = None
    definition_id: Optional[int] = None
    duplicates: Optional[List[Duplicate]] = None
    error_message: Optional[str] = None

    @staticmethod
    def duplicate_found(duplicates):
        return GenerationResult(success=False, duplicates=duplicates)

    @staticmethod
    def success(definition, category, definition_id):
        return GenerationResult(
            success=True,
            definition=definition,
            category=category,
            definition_id=definition_id
        )
```

---

## Implementation Plan

### Week 9 (Days 41-45)

**Day 41-42: Create Service Shell**
- Create `generation_orchestrator.py`
- Define interfaces (GenerationRequest, GenerationResult)
- Inject dependencies (5 services)
- Basic smoke test (orchestrator instantiates)

**Day 43: Extract Steps 1-5**
- Step 1: Context validation
- Step 2: Category determination
- Step 3: Duplicate check
- Step 4: Document context
- Step 5: Regeneration override
- Tests: 75 tests passing

**Day 44: Extract Steps 6-10**
- Step 6: Definition generation (async)
- Step 7: Result storage
- Step 8: Edit tab preparation
- Step 9: Cleanup
- Step 10: Success/error handling
- Tests: 150 tests passing

**Day 45: Integration Testing**
- Run 30 integration scenarios
- Golden baseline validation (42 definitions)
- Fix any regressions

---

### Week 10 (Days 46-50)

**Day 46-47: Thin UI Layer**
- Replace 380 LOC god method with orchestrator call
- Reduce to <50 LOC in UI
- Remove all business logic from tabbed_interface.py

**Day 48: Async Cleanup**
- Remove nested asyncio.run() calls
- Implement clean async boundaries
- Fix 57 files using asyncio.run (focus on UI layer)

**Day 49: State Management Migration**
- Replace direct st.session_state with SessionStateManager
- Atomic state updates in orchestrator
- Test state isolation

**Day 50: Final Validation**
- All 150+ tests GREEN
- Integration tests passing
- Golden baseline 100% match
- Code review

---

## Dependencies

**Depends On:**
- US-454 (Generation Orchestrator Tests) - 150 tests MUST exist before extraction

**Blocks:**
- US-451 (Thin UI Layer) - depends on orchestrator being extracted

---

## Risks

### Risk 1: Async Refactoring Complexity
**Likelihood:** HIGH
**Impact:** MEDIUM (timeline slip by 2-3 days)
**Mitigation:**
- Use proven async_bridge pattern (already exists in codebase)
- Test async boundaries thoroughly
- Have async expert review code

### Risk 2: State Management Breaks UI
**Likelihood:** MEDIUM
**Impact:** HIGH (workflows freeze, data loss)
**Mitigation:**
- State schema validation (from US-457 state audit)
- Atomic state updates (all or nothing)
- Integration tests catch state issues

### Risk 3: Golden Baseline Mismatch
**Likelihood:** MEDIUM
**Impact:** CRITICAL (cannot deploy if <95% match)
**Mitigation:**
- Run golden baseline after EACH step extraction
- If mismatch: investigate immediately (don't continue)
- Tolerance: 0% for business logic, <5% for LLM variance

---

## Success Metrics

- [ ] 380 LOC god method extracted to service
- [ ] UI layer reduced to <50 LOC (87% reduction)
- [ ] 150+ tests passing (95% coverage)
- [ ] 30 integration scenarios GREEN
- [ ] Golden baseline 100% match (42 definitions)
- [ ] 0 circular dependencies
- [ ] Async patterns clean (no nested event loops)
- [ ] Code review approved

---

## Rollback

**Trigger:** If golden baseline <95% match after Day 49
**Action:** Rollback to Week 8 (before Phase 2)
**Impact:** Phase 2 abandoned, UI remains god object

---

**Status:** Pending (blocked by US-454)
**Next Action:** Wait for Phase 0 Gate 1 + Phase 1 completion, then start Week 9
