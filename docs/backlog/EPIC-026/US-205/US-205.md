---
id: US-205
titel: "US-205: title: Split God Class tabbed_interface.py"
title: Split God Class tabbed_interface.py
status: open
priority: HIGH
story_points: 13
owner: development-team
applies_to: definitie-app@current
canonical: false
last_verified: 2025-10-02
epic_id: EPIC-026
assignee: team
created_date: 2025-01-18
updated_date: 2025-01-18
labels: [phoenix, refactoring, ui, code-quality, god-class]
acceptance_criteria:
  - tabbed_interface.py split into multiple focused modules
  - No single file exceeds 300 lines
  - Clear separation of concerns achieved
  - All functionality preserved
  - Tests coverage maintained or improved
definition_of_done:
  - Code review completed
  - All UI functionality working
  - Unit tests for new modules
  - Integration tests passing
  - Documentation updated
dependencies:
  - US-204 (V1 to V2 migration complete)
---

# US-205: Split God Class tabbed_interface.py

## User Story
**Als** ontwikkelaar
**Wil ik** het god class `tabbed_interface.py` opsplitsen in kleinere, gefocuste modules
**Zodat** de code beter onderhoudbaar, testbaar en begrijpelijk wordt

## Current State Analysis
```
src/ui/tabs/tabbed_interface.py: ~1500+ lines
- Tab rendering logic
- State management
- Event handling
- Business logic
- UI components
- Data transformation
- Validation logic
- Export functionality
```

## Acceptance Criteria

### File Size Constraints
- [ ] Geen enkel UI bestand > 300 regels code
- [ ] Gemiddelde bestandsgrootte < 150 regels
- [ ] Maximaal 5 imports per module (exclusief standard library)

### Module Organization
- [ ] Aparte modules voor elke tab component
- [ ] Gemeenschappelijke UI utilities geëxtraheerd
- [ ] State management gecentraliseerd
- [ ] Event handlers geïsoleerd van rendering

### Code Quality
- [ ] Single Responsibility Principle per module
- [ ] DRY principe toegepast (geen code duplicatie)
- [ ] Clear naming conventions
- [ ] Type hints voor alle publieke functies

### Functionality Preservation
- [ ] Alle huidige features werken identiek
- [ ] Geen UI regressies
- [ ] Performance gelijk of beter
- [ ] Gebruikerservaring onveranderd

## Technical Implementation Notes

### Target Architecture
```
src/ui/
├── components/           # Herbruikbare UI componenten
│   ├── __init__.py
│   ├── definition_card.py      # < 150 lines
│   ├── validation_display.py   # < 150 lines
│   ├── example_builder.py      # < 150 lines
│   └── export_controls.py      # < 100 lines
├── tabs/
│   ├── __init__.py
│   ├── base_tab.py            # < 100 lines - Abstract base
│   ├── generate_tab.py         # < 250 lines
│   ├── validate_tab.py         # < 250 lines
│   ├── manage_tab.py           # < 250 lines
│   ├── settings_tab.py         # < 200 lines
│   └── tab_coordinator.py      # < 150 lines - Orchestration
├── state/
│   ├── __init__.py
│   ├── session_manager.py      # < 200 lines
│   └── state_validators.py     # < 150 lines
├── handlers/
│   ├── __init__.py
│   ├── generation_handler.py   # < 200 lines
│   ├── validation_handler.py   # < 200 lines
│   ├── export_handler.py        # < 150 lines
│   └── settings_handler.py      # < 150 lines
└── utils/
    ├── __init__.py
    ├── ui_helpers.py           # < 100 lines
    ├── formatters.py           # < 100 lines
    └── validators.py           # < 100 lines
```

### Phase 1: Component Extraction (Day 1-2)
```python
# Extract reusable components
class DefinitionCard:
    """Displays a definition with metadata"""
    def render(self, definition: Definition) -> None:
        pass

class ValidationDisplay:
    """Shows validation results"""
    def render(self, results: ValidationResults) -> None:
        pass

class ExampleBuilder:
    """Interactive example sentence builder"""
    def render(self) -> List[str]:
        pass
```

### Phase 2: Tab Separation (Day 3-4)
```python
# Base class for all tabs
class BaseTab(ABC):
    def __init__(self, session_manager: SessionManager):
        self.session = session_manager

    @abstractmethod
    def render(self) -> None:
        pass

    @abstractmethod
    def get_title(self) -> str:
        pass

# Specific tab implementations
class GenerateTab(BaseTab):
    def __init__(self, session_manager, generation_handler):
        super().__init__(session_manager)
        self.handler = generation_handler

    def render(self):
        # Only rendering logic, no business logic
        pass
```

### Phase 3: Handler Extraction (Day 5-6)
```python
# Business logic separated from UI
class GenerationHandler:
    def __init__(self, container: ServiceContainer):
        self.generator = container.get_generator()
        self.validator = container.get_validator()

    def generate_definition(self, term: str, context: str) -> Definition:
        # Business logic here
        pass
```

### Phase 4: State Management (Day 7)
```python
# Centralized state management
class SessionManager:
    def __init__(self):
        self._state = st.session_state

    def get(self, key: str, default=None):
        return self._state.get(key, default)

    def set(self, key: str, value: Any):
        self._state[key] = value

    def clear_namespace(self, namespace: str):
        # Clear all keys starting with namespace
        pass
```

### Phase 5: Integration (Day 8-9)
```python
# Main app integration
def main():
    session = SessionManager()
    container = get_service_container()

    tabs = [
        GenerateTab(session, GenerationHandler(container)),
        ValidateTab(session, ValidationHandler(container)),
        ManageTab(session, container.get_repository()),
        SettingsTab(session, SettingsHandler())
    ]

    TabCoordinator(tabs).render()
```

## Migration Strategy

### Step 1: Create New Structure
```bash
mkdir -p src/ui/{components,state,handlers,utils}
touch src/ui/components/__init__.py
touch src/ui/state/__init__.py
touch src/ui/handlers/__init__.py
touch src/ui/utils/__init__.py
```

### Step 2: Extract Without Breaking
1. Copy functions to new modules
2. Import from new locations in tabbed_interface.py
3. Gradually remove from tabbed_interface.py
4. Test after each extraction

### Step 3: Refactor Incrementally
```python
# Old way (in tabbed_interface.py)
def render_definition_tab():
    # 500 lines of mixed logic
    pass

# New way
# In tabs/generate_tab.py
class GenerateTab(BaseTab):
    def render(self):
        # 50 lines of pure rendering
        pass

# In handlers/generation_handler.py
class GenerationHandler:
    def process(self):
        # 100 lines of business logic
        pass
```

## Testing Strategy

### Unit Tests per Module
```python
# tests/ui/components/test_definition_card.py
def test_definition_card_render():
    card = DefinitionCard()
    # Test isolated component
    pass

# tests/ui/handlers/test_generation_handler.py
def test_generation_handler():
    handler = GenerationHandler(mock_container)
    # Test business logic without UI
    pass
```

### Integration Tests
```python
# tests/ui/test_tab_integration.py
def test_full_tab_flow():
    # Test complete user flow
    pass
```

## Definition of Done

- [ ] **Code Structure**:
  - `tabbed_interface.py` < 100 lines (alleen orchestratie)
  - Alle tab logica in aparte modules
  - Geen enkel bestand > 300 lines
  - Duidelijke module boundaries

- [ ] **Code Quality**:
  - Pylint score ≥ 9.0 voor alle nieuwe modules
  - Type hints 100% coverage
  - Docstrings voor alle publieke functies
  - No cyclic dependencies

- [ ] **Testing**:
  - Unit tests voor elke nieuwe module
  - Integration tests blijven groen
  - UI smoke tests slagen
  - Coverage ≥ 80% per module

- [ ] **Documentation**:
  - Module diagram bijgewerkt
  - README voor ui/ directory
  - Inline comments waar nodig
  - CLAUDE.md bijgewerkt met nieuwe structuur

- [ ] **Review**:
  - Code review door 2 developers
  - UI/UX review (geen regressies)
  - Performance review (geen degradatie)

## Metrics for Success

### Before Refactoring
- tabbed_interface.py: ~1500 lines
- Cyclomatic complexity: >50
- Test coverage: ~45%
- Functions per file: >30

### After Refactoring
- Largest file: <300 lines
- Avg cyclomatic complexity: <10
- Test coverage: >80%
- Functions per file: <10

## Risks & Mitigations

### Risk: Breaking Existing Functionality
**Mitigation**:
- Keep old file during transition
- Feature flags for gradual rollout
- Comprehensive integration tests

### Risk: State Management Issues
**Mitigation**:
- Centralize all state access
- Clear state ownership model
- State validation layer

### Risk: Performance Degradation
**Mitigation**:
- Profile before and after
- Lazy loading where appropriate
- Caching for expensive operations

## Notes

### Anti-patterns to Avoid
- God objects (SessionManager becoming new god class)
- Anemic domain models (handlers with no logic)
- Over-engineering (too many abstractions)
- Premature optimization

### Best Practices to Follow
- Composition over inheritance
- Dependency injection
- Interface segregation
- Clear separation of concerns

## Related Items
- Parent: [[EPIC-020-PHOENIX]]
- Depends on: [[US-204]] (V2 migration)
- Related: [[US-206]] (business logic extraction)
- Blocks: [[US-207]], [[US-208]]