---
id: US-202
epic: EPIC-020
title: "Implement Validation Rules Caching to Prevent 45x Reloading"
status: OPEN
priority: CRITICAL
story_points: 3
tags: [performance, caching, validation, rules]
created: 2025-01-18
updated: 2025-01-18
---

# US-202: Implement Validation Rules Caching to Prevent 45x Reloading

## User Story
**Als** gebruiker
**Wil ik** dat validatieregels slechts eenmaal worden geladen
**Zodat** de applicatie sneller reageert en minder resources gebruikt

## Probleem
Huidige situatie: 45 validatieregels worden opnieuw geladen bij elke validatie run:
- **45x I/O operations** per validatie
- **~2 seconden overhead** per definitie validatie
- **Onnodige disk access** en JSON parsing
- **Memory churn** door constant herladen

## Acceptance Criteria

### Must Have
- [ ] Validatieregels worden **1x geladen** bij app start
- [ ] Rules blijven in-memory cached tijdens sessie
- [ ] Validatie tijd gereduceerd met >70%
- [ ] Geen functionele regressie in validatie resultaten

### Should Have
- [ ] Hot-reload capability voor development mode
- [ ] Cache invalidation bij config wijzigingen
- [ ] Memory-efficient storage van regel metadata

### Performance Targets
- **Current**: ~2 seconden regel loading per validatie
- **Target**: <50ms regel access per validatie
- **Memory footprint**: <10MB voor alle regels

## Technical Implementation

### Caching Strategy
```python
# src/services/validation/rule_cache.py
from functools import lru_cache
import json
from pathlib import Path

class RuleCache:
    _instance = None
    _rules_cache = {}

    @classmethod
    @st.cache_data(ttl=3600)  # 1 hour TTL for development
    def load_all_rules(cls) -> Dict[str, Rule]:
        """Load all validation rules once."""
        if not cls._rules_cache:
            rules_dir = Path("config/toetsregels/regels")
            for category in ["ARAI", "CON", "ESS", "INT", "SAM", "STR", "VER"]:
                category_path = rules_dir / category
                if category_path.exists():
                    for rule_file in category_path.glob("*.json"):
                        rule_id = rule_file.stem
                        cls._rules_cache[rule_id] = cls._load_rule(rule_file)
        return cls._rules_cache

    @staticmethod
    @lru_cache(maxsize=128)
    def _load_rule(rule_path: Path) -> Rule:
        """Load and parse individual rule with caching."""
        with open(rule_path, 'r', encoding='utf-8') as f:
            return Rule.from_json(json.load(f))
```

### Integration Points
```python
# src/services/validation/modular_validation_service.py
class ModularValidationService:
    def __init__(self):
        # Load rules once at initialization
        self.rules = RuleCache.load_all_rules()
        self.validators = self._initialize_validators()

    def validate(self, definition: Definition) -> ValidationResult:
        # Use cached rules directly
        results = []
        for rule_id, rule in self.rules.items():
            validator = self.validators.get(rule.category)
            if validator:
                result = validator.validate(definition, rule)
                results.append(result)
        return ValidationResult(results)
```

### Memory Optimization
```python
# Store only essential rule data
class OptimizedRule:
    __slots__ = ['id', 'category', 'priority', 'pattern', 'validator_fn']

    def __init__(self, rule_data):
        self.id = rule_data['id']
        self.category = rule_data['category']
        self.priority = rule_data['priority']
        self.pattern = self._compile_pattern(rule_data.get('pattern'))
        self.validator_fn = self._get_validator_function()
```

## Test Scenarios

### Performance Tests
```python
def test_rule_loading_performance():
    """Rules should load in <100ms after first load."""
    # First load (cold cache)
    start = time.time()
    rules1 = RuleCache.load_all_rules()
    first_load = time.time() - start

    # Second load (warm cache)
    start = time.time()
    rules2 = RuleCache.load_all_rules()
    cached_load = time.time() - start

    assert cached_load < 0.1  # <100ms
    assert rules1 is rules2  # Same instance
    assert len(rules1) == 45  # All rules loaded

def test_memory_footprint():
    """Total memory for rules should be <10MB."""
    import sys
    rules = RuleCache.load_all_rules()
    total_size = sum(sys.getsizeof(rule) for rule in rules.values())
    assert total_size < 10 * 1024 * 1024  # 10MB
```

### Integration Tests
- Validate 100 definitions and measure total time
- Verify identical results with/without caching
- Test cache behavior across Streamlit reruns

## Key Files to Modify
1. `src/services/validation/modular_validation_service.py` - Add caching layer
2. `src/toetsregels/regel_loader.py` - Implement cached loader
3. `src/services/container.py` - Wire up cached rule service
4. `config/toetsregels.json` - Ensure proper structure for caching

## Definition of Done

- [ ] Rule caching implemented with @st.cache_data
- [ ] Performance tests show >70% improvement
- [ ] Memory usage stays under 10MB
- [ ] All existing validation tests pass
- [ ] No regression in validation accuracy
- [ ] Cache invalidation mechanism documented
- [ ] Performance metrics logged for monitoring

## Dependencies
- US-201 (ServiceContainer caching) - Should be completed first

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|---------|------------|
| Stale cache after rule updates | HIGH | Implement file watcher for dev mode |
| Memory pressure on low-end systems | MEDIUM | Implement LRU eviction if needed |
| Cache corruption | LOW | Add cache validation checksums |

## Notes
- Critical for responsive user experience
- Reduces I/O bottleneck significantly
- Consider implementing rule versioning for cache invalidation
- Future: Could pre-compile regex patterns for additional speed

## Implementation Checklist
- [ ] Create RuleCache class with singleton pattern
- [ ] Implement @st.cache_data decorators
- [ ] Add memory-efficient rule storage
- [ ] Update ModularValidationService to use cache
- [ ] Write comprehensive performance tests
- [ ] Add cache metrics to logging
- [ ] Document cache behavior and tuning options

## Progress Tracking
- [ ] Design reviewed
- [ ] Implementation started
- [ ] Unit tests written
- [ ] Performance benchmarks completed
- [ ] Code review done
- [ ] Merged to main