---
id: US-111
epic: EPIC-014
titel: Implementeer Iterative Improvement Controller
status: open
prioriteit: P2
story_points: 5
aangemaakt: 2025-09-30
bijgewerkt: 2025-09-30
owner: tbd
applies_to: definitie-app@current
canonical: false
last_verified: 2025-09-30
---

# US-111: Implementeer Iterative Improvement Controller

## User Story
**Als** orchestrator  
**Wil ik** een intelligente iteratie controller met stop criteria  
**Zodat** definities iteratief verbeterd worden zonder infinite loops  

## Status
**Status**: TODO  
**Priority**: CRITICAL  
**Story Points**: 8  
**Epic**: [EPIC-014: Business Logic Refactoring](../EPIC-014.md)  

## Business Context
Dit is het hart van de DefinitieAgent - de iteratieve verbeterloop die definities verfijnt tot acceptabel niveau. Bevat intelligente stop criteria om nutteloze iteraties te voorkomen.

## Acceptance Criteria
- [ ] Maximum 3 iteraties (configureerbaar)
- [ ] Minimum improvement threshold: 0.05 per iteratie
- [ ] Best iteration tracking (hoogste score wint)
- [ ] Voorbeelden caching (alleen genereren in iteratie 1)
- [ ] Feedback history management (max 10 items, FIFO)
- [ ] Stagnatie detectie met automatische stop
- [ ] Early success exit bij acceptatie criteria
- [ ] Performance metrics tracking per iteratie

## Technical Details

### Core Loop Implementation
```python
class IterativeImprovementController:
    def __init__(self):
        self.max_iterations = 3
        self.improvement_threshold = 0.05
        self.max_feedback_history = 10
        
    def run_improvement_loop(self, initial_context):
        iterations = []
        best_iteration = None
        feedback_history = []
        first_iteration_voorbeelden = None
        
        for i in range(1, self.max_iterations + 1):
            # Generate definition
            if i == 1:
                result = generate_with_examples(context)
                first_iteration_voorbeelden = result.voorbeelden
            else:
                result = generate_without_examples(context)
                result.voorbeelden = first_iteration_voorbeelden  # Reuse!
            
            # Validate
            validation = validate(result.definitie)
            
            # Track best
            if not best_iteration or validation.score > best_iteration.score:
                best_iteration = IterationResult(result, validation)
            
            # Check success
            if validation.is_acceptable:
                return SuccessResult(best_iteration, f"Accepted at iteration {i}")
            
            # Check improvement (skip voor eerste iteratie)
            if i > 1:
                improvement = validation.score - iterations[-1].validation.score
                if improvement < self.improvement_threshold:
                    # Stagnatie gedetecteerd
                    if improvement < 0:
                        log.warning(f"Score degraded by {-improvement}")
                    else:
                        log.warning(f"Insufficient improvement: {improvement}")
            
            # Prepare next iteration
            if i < self.max_iterations:
                feedback = generate_feedback(validation, i)
                feedback_history.extend(feedback)
                # FIFO management
                if len(feedback_history) > self.max_feedback_history:
                    feedback_history = feedback_history[-self.max_feedback_history:]
                context.feedback_history = feedback_history
            
            iterations.append(IterationResult(result, validation))
        
        # Max iterations reached
        return PartialSuccessResult(best_iteration, 
                                   f"Max iterations ({self.max_iterations}) reached")
```

### Stagnation Detection
```python
def detect_stagnation(score_history):
    if len(score_history) < 2:
        return False
    
    # Check laatste 2 scores
    recent_scores = score_history[-2:]
    score_diff = abs(recent_scores[1] - recent_scores[0])
    
    if score_diff < 0.05:  # Stagnatie threshold
        return True
    
    # Check voor oscillatie (score gaat op en neer)
    if len(score_history) >= 3:
        if score_history[-1] < score_history[-2] < score_history[-3]:
            return True  # Dalende trend
    
    return False
```

### Performance Optimizations
1. **Voorbeelden Caching**: 
   - Genereer alleen in iteratie 1
   - Besparing: ~2-3 seconden per iteratie 2 & 3
   
2. **Early Exit**:
   - Stop zodra acceptatie criteria gehaald
   - Stop bij stagnatie/degradatie

3. **Feedback Limiting**:
   - Max 10 items in history
   - Voorkomt prompt bloat

## Test Cases
1. Test happy path: acceptatie in iteratie 1
2. Test improvement: iteratie 2 beter dan 1
3. Test stagnatie: stop bij <0.05 improvement
4. Test degradatie: beste iteratie behouden
5. Test max iterations: stop na 3
6. Test voorbeelden caching: zelfde voorbeelden in alle iteraties
7. Test feedback FIFO: max 10 items

## Performance Requirements
- Iteratie 1: <5 seconden (incl. voorbeelden)
- Iteratie 2-3: <2 seconden (zonder voorbeelden)
- Totale loop: <10 seconden worst case

## Configuration
```python
# Bewezen optimale waarden uit productie
ITERATION_CONFIG = {
    "max_iterations": 3,           # Balans kwaliteit/performance
    "improvement_threshold": 0.05,  # 5% minimum verbetering
    "max_feedback_history": 10,     # Voorkom prompt overflow
    "enable_caching": True          # Voorbeelden caching
}
```

## Dependencies
- Definition generator (met/zonder voorbeelden)
- Validation engine
- Feedback builder
- Performance timer

## Notes
- Core functionaliteit - uitgebreid testen vereist
- Voorbeelden caching is kritiek voor performance
- Best iteration tracking voorkomt kwaliteit regressie