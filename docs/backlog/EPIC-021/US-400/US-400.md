---
id: US-400
titel: Implement Version Control System for Definitions
epic: EPIC-021
status: Open
prioriteit: HIGH
story_points: 8
sprint: backlog
toegewezen_aan: development-team
aangemaakt: 2025-09-29
bijgewerkt: 2025-09-29
owner: tech-lead
type: feature
vereisten:
  - REQ-100
  - REQ-101
applies_to: definitie-app@current
canonical: true
---

# US-400: Implement Version Control System for Definitions

**Epic:** EPIC-021 - Definitie Geschiedenis & Audit Trail Management

## Gebruikersverhaal

**Als een** juridisch professional
**wil ik** een volledig version control systeem voor definities
**zodat** ik de evolutie van definities kan volgen en eerdere versies kan herstellen

## Acceptance Criteria

### Functional Requirements

- [ ] **Automatic Versioning**
  - Create new version on every save
  - Increment version numbers sequentially
  - Track major/minor version distinctions
  - Maintain version metadata

- [ ] **Version Storage**
  - Store complete definition snapshot per version
  - Efficient delta storage for large definitions
  - Maintain version hierarchy/tree
  - Support branching for experiments

- [ ] **Version Retrieval**
  - List all versions for a definition
  - Filter versions by date range
  - Filter versions by author
  - Search within version content

- [ ] **Version Metadata**
  - Author identification
  - Timestamp (created/modified)
  - Change description/reason
  - Version tags/labels
  - Parent version reference

### Technical Requirements

- [ ] **Database Schema**
  - Create definitie_versies table
  - Add version_id to definities table
  - Create version_branches table
  - Implement proper indexes

- [ ] **Service Layer**
  ```python
  class VersionControlService:
      def create_version(self, definition_id: int, content: dict, metadata: dict) -> Version
      def get_version(self, version_id: int) -> Version
      def list_versions(self, definition_id: int, filters: VersionFilters) -> List[Version]
      def get_latest_version(self, definition_id: int, branch: str = "main") -> Version
      def tag_version(self, version_id: int, tag: str) -> bool
      def branch_from_version(self, version_id: int, branch_name: str) -> Version
  ```

- [ ] **API Endpoints**
  - GET /api/definitions/{id}/versions
  - GET /api/versions/{version_id}
  - POST /api/definitions/{id}/versions
  - PUT /api/versions/{version_id}/tag
  - POST /api/versions/{version_id}/branch

### Performance Requirements

- [ ] Version creation < 500ms
- [ ] Version retrieval < 200ms
- [ ] Version listing < 1s for 1000+ versions
- [ ] Storage overhead < 30% of original size

## Implementation Details

### Database Migration

```sql
-- Create version control tables
CREATE TABLE definitie_versies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    definitie_id INTEGER NOT NULL,
    versie_nummer INTEGER NOT NULL,
    versie_label VARCHAR(50),
    branch_naam VARCHAR(100) DEFAULT 'main',
    parent_versie_id INTEGER,

    -- Content
    term VARCHAR(255) NOT NULL,
    definitie_tekst TEXT NOT NULL,
    context TEXT,
    bron TEXT,
    voorbeelden JSON,
    opmerkingen TEXT,
    validatie_resultaten JSON,

    -- Metadata
    auteur VARCHAR(255) NOT NULL,
    wijziging_reden TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_current BOOLEAN DEFAULT FALSE,
    is_published BOOLEAN DEFAULT FALSE,

    -- Checksums for integrity
    content_hash VARCHAR(64),

    FOREIGN KEY (definitie_id) REFERENCES definities(id),
    FOREIGN KEY (parent_versie_id) REFERENCES definitie_versies(id),
    UNIQUE(definitie_id, versie_nummer, branch_naam)
);

-- Add version tracking to main table
ALTER TABLE definities ADD COLUMN current_version_id INTEGER;
ALTER TABLE definities ADD FOREIGN KEY (current_version_id) REFERENCES definitie_versies(id);

-- Create indexes
CREATE INDEX idx_versies_definitie ON definitie_versies(definitie_id);
CREATE INDEX idx_versies_branch ON definitie_versies(branch_naam);
CREATE INDEX idx_versies_auteur ON definitie_versies(auteur);
CREATE INDEX idx_versies_created ON definitie_versies(created_at);
```

### Version Control Service

```python
from dataclasses import dataclass
from typing import List, Optional, Dict
import hashlib
import json

@dataclass
class Version:
    id: int
    definitie_id: int
    versie_nummer: int
    branch_naam: str
    content: dict
    metadata: dict
    created_at: datetime
    content_hash: str

class VersionControlService:
    def __init__(self, db_connection):
        self.db = db_connection

    def create_version(
        self,
        definition_id: int,
        content: dict,
        metadata: dict
    ) -> Version:
        """Create new version with automatic numbering"""
        # Get next version number
        version_number = self._get_next_version_number(
            definition_id,
            metadata.get('branch', 'main')
        )

        # Calculate content hash
        content_hash = self._calculate_hash(content)

        # Check if content actually changed
        if self._is_duplicate(definition_id, content_hash):
            return self.get_latest_version(definition_id)

        # Insert new version
        version = self._insert_version(
            definition_id,
            version_number,
            content,
            metadata,
            content_hash
        )

        # Update current version pointer
        self._update_current_version(definition_id, version.id)

        return version

    def _calculate_hash(self, content: dict) -> str:
        """Calculate SHA-256 hash of content"""
        content_str = json.dumps(content, sort_keys=True)
        return hashlib.sha256(content_str.encode()).hexdigest()
```

## Test Scenarios

### Unit Tests

```python
def test_version_creation():
    """Test creating new version"""
    service = VersionControlService(mock_db)
    version = service.create_version(
        definition_id=1,
        content={'term': 'test', 'definitie': 'test def'},
        metadata={'author': 'user1', 'reason': 'Initial version'}
    )
    assert version.versie_nummer == 1
    assert version.branch_naam == 'main'

def test_version_numbering():
    """Test sequential version numbering"""
    # Create multiple versions
    # Verify numbers increment correctly

def test_duplicate_detection():
    """Test that identical content doesn't create new version"""
    # Create version
    # Try to create identical version
    # Verify no new version created

def test_branch_creation():
    """Test creating experimental branch"""
    # Create main version
    # Branch from it
    # Verify branch structure
```

### Integration Tests

- Test version creation with database
- Test concurrent version creation
- Test large definition versioning
- Test version retrieval performance
- Test storage efficiency

## Definition of Done

- [ ] Version control service implemented
- [ ] Database migrations executed
- [ ] API endpoints functional
- [ ] Unit tests passing (>90% coverage)
- [ ] Integration tests passing
- [ ] Performance benchmarks met
- [ ] Documentation updated
- [ ] Code review completed
- [ ] Security review passed

## Dependencies

- Database migration framework
- JSON storage optimization
- Hash calculation libraries
- Current definition repository refactoring

## Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Storage growth | HIGH | Implement delta storage, compression |
| Performance impact | MEDIUM | Add caching, optimize queries |
| Migration complexity | MEDIUM | Staged migration, rollback plan |
| Hash collisions | LOW | Use SHA-256, verify uniqueness |

## Notes

- Consider implementing git-like branching model
- Evaluate compression algorithms for storage
- Plan for version pruning/archiving strategy
- Consider read-only access for historical versions