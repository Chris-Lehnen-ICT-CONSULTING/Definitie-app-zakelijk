---
id: US-401
titel: Enhanced Audit Trail with Cryptographic Integrity
epic: EPIC-021
status: Open
prioriteit: HIGH
story_points: 5
sprint: backlog
toegewezen_aan: development-team
aangemaakt: 2025-09-29
bijgewerkt: 2025-09-29
owner: security-lead
type: feature
vereisten:
  - REQ-100
  - REQ-103
applies_to: definitie-app@current
canonical: true
---

# US-401: Enhanced Audit Trail with Cryptographic Integrity

**Epic:** EPIC-021 - Definitie Geschiedenis & Audit Trail Management

## Gebruikersverhaal

**Als een** compliance officer
**wil ik** een tamper-proof audit trail met volledige attributie
**zodat** ik kan aantonen dat alle wijzigingen traceerbaar en integer zijn

## Acceptance Criteria

### Functional Requirements

- [ ] **Complete Activity Logging**
  - Log all CRUD operations on definitions
  - Log validation rule changes
  - Log approval/rejection actions
  - Log export/import actions
  - Log user authentication events
  - Log configuration changes

- [ ] **Detailed Attribution**
  - Capture user identity (authenticated)
  - Capture session ID
  - Capture IP address
  - Capture user agent
  - Capture timestamp (microsecond precision)
  - Capture action context

- [ ] **Change Details**
  - Store old value (before change)
  - Store new value (after change)
  - Store change delta/diff
  - Store reason for change
  - Store related entity IDs

- [ ] **Cryptographic Integrity**
  - Sign each audit entry
  - Chain entries cryptographically
  - Verify integrity on read
  - Detect tampering attempts

### Technical Requirements

- [ ] **Audit Service Implementation**
  ```python
  class EnhancedAuditService:
      def log_action(
          self,
          entity_type: str,
          entity_id: int,
          action: str,
          old_value: Optional[dict],
          new_value: Optional[dict],
          context: AuditContext
      ) -> AuditEntry

      def verify_integrity(
          self,
          start_date: datetime,
          end_date: datetime
      ) -> IntegrityReport

      def query_audit_log(
          self,
          filters: AuditFilters,
          pagination: PaginationParams
      ) -> AuditQueryResult
  ```

- [ ] **Database Schema**
  ```sql
  CREATE TABLE audit_log_v2 (
      id INTEGER PRIMARY KEY AUTOINCREMENT,

      -- Entity information
      entity_type VARCHAR(50) NOT NULL,
      entity_id INTEGER NOT NULL,
      entity_name VARCHAR(255),

      -- Action details
      action VARCHAR(50) NOT NULL,
      action_category VARCHAR(50),
      old_value JSON,
      new_value JSON,
      change_delta JSON,

      -- Attribution
      user_id VARCHAR(255) NOT NULL,
      user_name VARCHAR(255),
      user_role VARCHAR(100),
      session_id VARCHAR(255) NOT NULL,
      ip_address VARCHAR(45),
      user_agent TEXT,

      -- Context
      reason TEXT,
      correlation_id VARCHAR(255),
      parent_audit_id INTEGER,

      -- Integrity
      timestamp TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6),
      previous_hash VARCHAR(64),
      entry_hash VARCHAR(64) NOT NULL,
      signature VARCHAR(512),

      -- Indexes
      INDEX idx_entity_lookup (entity_type, entity_id, timestamp),
      INDEX idx_user_activity (user_id, timestamp),
      INDEX idx_action_type (action, timestamp),
      INDEX idx_correlation (correlation_id),
      INDEX idx_timestamp (timestamp),

      FOREIGN KEY (parent_audit_id) REFERENCES audit_log_v2(id)
  );
  ```

- [ ] **API Endpoints**
  - GET /api/audit/query
  - GET /api/audit/verify
  - GET /api/audit/export
  - GET /api/audit/stats
  - POST /api/audit/annotate

### Security Requirements

- [ ] Audit entries are immutable (no UPDATE/DELETE)
- [ ] Cryptographic chain prevents entry removal
- [ ] Failed integrity checks trigger alerts
- [ ] Role-based access to audit logs
- [ ] Audit the audit queries themselves

## Implementation Details

### Cryptographic Chain Implementation

```python
import hashlib
import hmac
import json
from datetime import datetime
from typing import Optional, Dict, Any

class CryptographicAuditChain:
    def __init__(self, secret_key: bytes):
        self.secret_key = secret_key

    def create_entry_hash(
        self,
        entry_data: dict,
        previous_hash: Optional[str] = None
    ) -> tuple[str, str]:
        """Create hash and signature for audit entry"""

        # Prepare data for hashing
        hash_data = {
            'timestamp': entry_data['timestamp'],
            'entity_type': entry_data['entity_type'],
            'entity_id': entry_data['entity_id'],
            'action': entry_data['action'],
            'user_id': entry_data['user_id'],
            'old_value': entry_data.get('old_value'),
            'new_value': entry_data.get('new_value'),
            'previous_hash': previous_hash
        }

        # Create deterministic JSON
        json_data = json.dumps(hash_data, sort_keys=True, default=str)

        # Calculate hash
        entry_hash = hashlib.sha256(json_data.encode()).hexdigest()

        # Create HMAC signature
        signature = hmac.new(
            self.secret_key,
            entry_hash.encode(),
            hashlib.sha256
        ).hexdigest()

        return entry_hash, signature

    def verify_chain(
        self,
        entries: list[dict]
    ) -> tuple[bool, list[str]]:
        """Verify integrity of audit chain"""

        errors = []
        previous_hash = None

        for i, entry in enumerate(entries):
            # Recalculate hash
            expected_hash, expected_sig = self.create_entry_hash(
                entry,
                previous_hash
            )

            # Verify hash matches
            if entry['entry_hash'] != expected_hash:
                errors.append(f"Entry {i}: Hash mismatch")

            # Verify signature
            if entry['signature'] != expected_sig:
                errors.append(f"Entry {i}: Signature invalid")

            # Verify chain continuity
            if entry['previous_hash'] != previous_hash:
                errors.append(f"Entry {i}: Chain broken")

            previous_hash = entry['entry_hash']

        return len(errors) == 0, errors
```

### Audit Context Capture

```python
from dataclasses import dataclass
from typing import Optional
import socket

@dataclass
class AuditContext:
    user_id: str
    user_name: str
    user_role: str
    session_id: str
    ip_address: str
    user_agent: str
    reason: Optional[str] = None
    correlation_id: Optional[str] = None

class AuditContextCapture:
    @staticmethod
    def from_request(request) -> AuditContext:
        """Capture audit context from HTTP request"""
        return AuditContext(
            user_id=request.user.id,
            user_name=request.user.name,
            user_role=request.user.role,
            session_id=request.session.id,
            ip_address=request.remote_addr,
            user_agent=request.headers.get('User-Agent', ''),
            correlation_id=request.headers.get('X-Correlation-ID')
        )
```

## Test Scenarios

### Unit Tests

```python
def test_audit_entry_creation():
    """Test creating audit entries with all fields"""
    service = EnhancedAuditService()
    entry = service.log_action(
        entity_type='definition',
        entity_id=1,
        action='UPDATE',
        old_value={'term': 'old'},
        new_value={'term': 'new'},
        context=mock_context
    )
    assert entry.entry_hash is not None
    assert entry.signature is not None

def test_cryptographic_chain():
    """Test chain integrity verification"""
    chain = CryptographicAuditChain(secret_key)
    entries = create_test_entries()
    is_valid, errors = chain.verify_chain(entries)
    assert is_valid

def test_tampering_detection():
    """Test that tampering is detected"""
    entries = create_test_entries()
    # Tamper with entry
    entries[1]['new_value'] = {'tampered': True}
    is_valid, errors = chain.verify_chain(entries)
    assert not is_valid
    assert 'Hash mismatch' in errors[0]
```

### Integration Tests

- Test high-volume audit logging performance
- Test query performance with millions of entries
- Test integrity verification speed
- Test concurrent audit writes
- Test audit export functionality

## Definition of Done

- [ ] Enhanced audit service implemented
- [ ] Cryptographic chaining functional
- [ ] Database migration completed
- [ ] API endpoints implemented
- [ ] Unit tests passing (>95% coverage)
- [ ] Integration tests passing
- [ ] Security review completed
- [ ] Performance benchmarks met
- [ ] Documentation updated

## Dependencies

- Cryptographic libraries (hashlib, hmac)
- Database migration tools
- Session management system
- User authentication system

## Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Performance overhead | HIGH | Async logging, batching |
| Storage growth | HIGH | Archiving, compression |
| Key management | CRITICAL | Secure key storage, rotation |
| Chain corruption | HIGH | Regular verification, backups |

## Notes

- Consider implementing audit log streaming for real-time monitoring
- Evaluate using blockchain for immutable audit trail
- Plan for key rotation without breaking chain
- Consider implementing audit log replication for redundancy