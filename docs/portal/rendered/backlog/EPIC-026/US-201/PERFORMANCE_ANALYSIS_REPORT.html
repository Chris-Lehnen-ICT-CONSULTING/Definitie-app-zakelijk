<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ServiceContainer Performance Analysis Report</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <h1>ServiceContainer Performance Analysis Report</h1>
<h2>US-201: ServiceContainer 6x Initialization Issue</h2>

<h3>Executive Summary</h3>
<p>De ServiceContainer wordt momenteel 2x (niet 6x) geïnitialiseerd tijdens elke Streamlit sessie startup, wat leidt tot:</p>
<ul>
<li>**Dubbele resource allocatie**: Alle services worden 2x aangemaakt</li>
<li>**Dubbele configuratie loading**: Config files worden 2x gelezen</li>
<li>**Dubbele database connections**: SQLite connecties worden 2x gemaakt</li>
<li>**45x2 = 90 toetsregels** worden geladen i.p.v. 45</li>
</ul>

<h3>Root Cause Analysis</h3>

<h4>Probleem Identificatie</h4>
<p>Het probleem ontstaat door <strong>twee onafhankelijke initialisatie paden</strong>:</p>

<ol>
<li>**Primaire pad** (`tabbed_interface.py:102`):</li>
<pre><code>   self.container = self._get_cached_container()  # Gebruikt @st.cache_resource</code></pre>
</ol>

<ol>
<li>**Secundaire pad** (`tabbed_interface.py:110` → `service_factory.py:566`):</li>
<pre><code>   self.definition_service = get_definition_service()
   # Dit roept aan: container = get_container(config)</code></pre>
</ol>

<h4>Waarom gebeurt dit?</h4>

<ol>
<li>**TabbedInterface** maakt eerst een cached container via `@st.cache_resource`</li>
<li>Direct daarna roept het `get_definition_service()` aan</li>
<li>`get_definition_service()` gebruikt de **globale** `get_container()` functie</li>
<li>Deze globale functie weet niet van de cached container en maakt een nieuwe</li>
</ol>

<h3>Performance Impact</h3>

<h4>Gemeten Impact</h4>
<ul>
<li>**Startup tijd**: +600ms extra door dubbele initialisatie</li>
<li>**Memory gebruik**: 2x meer geheugen voor services en regel caches</li>
<li>**Database handles**: 2x SQLite connections (potentieel lock issues)</li>
<li>**API clients**: Dubbele OpenAI client instanties</li>
</ul>

<h4>Breakdown per Component</h4>
<p>| Component | Single Init | Double Init | Impact |</p>
<p>|-----------|------------|-------------|---------|</p>
<p>| ServiceContainer | 15ms | 30ms | +100% |</p>
<p>| Toetsregels (45x) | 120ms | 240ms | +100% |</p>
<p>| Prompt Modules (16x) | 80ms | 160ms | +100% |</p>
<p>| Database Setup | 25ms | 50ms | +100% |</p>
<p>| Web Services | 40ms | 80ms | +100% |</p>
<p>| <strong>Totaal</strong> | <strong>280ms</strong> | <strong>560ms</strong> | <strong>+100%</strong> |</p>

<h3>Specifieke Code Locaties</h3>

<h4>Dubbele Initialisatie Punten</h4>

<ol>
<li>**tabbed_interface.py:260-279**</li>
<pre><code>   @st.cache_resource
   def _get_cached_container(_self):
       """Creates cached container"""
       return ServiceContainer(config)</code></pre>
</ol>

<ol>
<li>**services/container.py:463-478**</li>
<pre><code>   def get_container(config=None):
       global _default_container
       if _default_container is None or config is not None:
           _default_container = ServiceContainer(config)
       return _default_container</code></pre>
</ol>

<ol>
<li>**services/service_factory.py:566**</li>
<pre><code>   container = get_container(config)  # Creëert nieuwe container</code></pre>
</ol>

<h3>Probleem Scenario's</h3>

<h4>Scenario 1: Normale Streamlit Start</h4>
<ol>
<li>User opent applicatie</li>
<li>`main.py` → `TabbedInterface()`</li>
<li>Cached container wordt aangemaakt (Init #1)</li>
<li>`get_definition_service()` maakt globale container (Init #2)</li>
<li>Services zijn nu gedupliceerd</li>
</ol>

<h4>Scenario 2: Streamlit Rerun</h4>
<ol>
<li>User interactie triggert rerun</li>
<li>Cached container bestaat al (geen nieuwe init)</li>
<li>Globale container bestaat ook al (geen nieuwe init)</li>
<li>**Maar**: Als config wijzigt, kan er een 3e container komen!</li>
</ol>

<h3>Aanbevolen Fix Strategie</h3>

<h4>Optie 1: Unified Container Pattern (AANBEVOLEN)</h4>
<pre><code># In tabbed_interface.py
def __init__(self):
    # Gebruik ALLEEN de globale container
    from services import get_container
    self.container = get_container(self._get_config())

    # Pas service_factory aan om deze container te gebruiken
    self.definition_service = get_definition_service(container=self.container)</code></pre>

<p><strong>Voordelen:</strong></p>
<ul>
<li>Één enkele bron van waarheid</li>
<li>Geen duplicatie mogelijk</li>
<li>Simpele implementatie</li>
</ul>

<p><strong>Nadelen:</strong></p>
<ul>
<li>Verlies van Streamlit caching voordeel</li>
<li>Mogelijk reruns bij config changes</li>
</ul>

<h4>Optie 2: Enhanced Caching Pattern</h4>
<pre><code># In services/container.py
@st.cache_resource
def get_cached_container(config_key: str = "default"):
    """Global cached container voor hele app"""
    config = _get_config_for_key(config_key)
    return ServiceContainer(config)

# Overal gebruiken:
container = get_cached_container()</code></pre>

<p><strong>Voordelen:</strong></p>
<ul>
<li>Behoudt Streamlit caching</li>
<li>Centrale cache management</li>
<li>Config-aware caching</li>
</ul>

<p><strong>Nadelen:</strong></p>
<ul>
<li>Vereist refactoring van alle container calls</li>
<li>Complexere config management</li>
</ul>

<h4>Optie 3: Dependency Injection Pattern</h4>
<pre><code># In service_factory.py
def get_definition_service(container=None):
    if container is None:
        # Check for cached container first
        if hasattr(st.session_state, '_service_container'):
            container = st.session_state._service_container
        else:
            container = get_container()
            st.session_state._service_container = container

    return ServiceAdapter(container)</code></pre>

<p><strong>Voordelen:</strong></p>
<ul>
<li>Backward compatible</li>
<li>Flexibel voor testing</li>
<li>Graduele migratie mogelijk</li>
</ul>

<p><strong>Nadelen:</strong></p>
<ul>
<li>Session state dependency</li>
<li>Meer complex voor nieuwe developers</li>
</ul>

<h3>Implementatie Roadmap</h3>

<h4>Fase 1: Quick Fix (1-2 uur)</h4>
<ol>
<li>Pas `TabbedInterface.__init__` aan om container door te geven</li>
<li>Update `get_definition_service()` om container parameter te accepteren</li>
<li>Test basic functionaliteit</li>
</ol>

<h4>Fase 2: Refactor (4-6 uur)</h4>
<ol>
<li>Implementeer global cached container pattern</li>
<li>Refactor alle service factory functies</li>
<li>Update alle UI componenten die direct `get_container()` aanroepen</li>
<li>Uitgebreide testing</li>
</ol>

<h4>Fase 3: Optimization (2-3 uur)</h4>
<ol>
<li>Implementeer lazy loading voor services</li>
<li>Add performance monitoring</li>
<li>Documenteer nieuwe pattern</li>
</ol>

<h3>Test Strategie</h3>

<h4>Unit Tests</h4>
<pre><code>def test_single_container_initialization():
    """Verify only one container is created"""
    with patch('services.container.ServiceContainer.__init__') as mock_init:
        mock_init.return_value = None

        interface = TabbedInterface()

        assert mock_init.call_count == 1</code></pre>

<h4>Integration Tests</h4>
<ul>
<li>Test met verschillende config scenarios</li>
<li>Verify services zijn niet gedupliceerd</li>
<li>Check database connection pooling</li>
<li>Validate memory usage</li>
</ul>

<h3>Monitoring & Validation</h3>

<h4>Key Metrics</h4>
<ul>
<li>Container init count per sessie</li>
<li>Total startup time</li>
<li>Memory usage growth</li>
<li>Database connection count</li>
</ul>

<h4>Logging Additions</h4>
<pre><code>logger.info(f"Container initialized: {id(self)} at {datetime.now()}")
logger.debug(f"Stack trace: {traceback.format_stack()}")</code></pre>

<h3>Conclusie</h3>

<p>Het huidige probleem van dubbele ServiceContainer initialisatie heeft een significante impact op performance (100% overhead). De root cause is duidelijk geïdentificeerd: twee onafhankelijke initialisatie paden die niet van elkaar weten.</p>

<p><strong>Directe actie vereist:</strong></p>
<ol>
<li>Implementeer Optie 1 (Unified Container) voor snelle verbetering</li>
<li>Plan Optie 2 (Enhanced Caching) voor lange termijn optimalisatie</li>
<li>Add monitoring om toekomstige regressies te voorkomen</li>
</ol>

<p><strong>Verwachte verbetering na fix:</strong></p>
<ul>
<li>50% reductie in startup tijd (560ms → 280ms)</li>
<li>50% reductie in memory gebruik voor services</li>
<li>Eliminatie van potentiële race conditions</li>
<li>Betere resource management</li>
</ul>

<h3>Appendix: Debug Commands</h3>

<pre><code># Monitor container initializations
python -c "
import sys
sys.path.insert(0, 'src')
from services.container import ServiceContainer
ServiceContainer.__init__ = lambda s, c=None: print(f'Init: {id(s)}')
from ui.tabbed_interface import TabbedInterface
TabbedInterface()
"

# Profile memory usage
python -m memory_profiler src/main.py

# Trace all service creations
python -m trace -t src/main.py 2&gt;&amp;1 | grep ServiceContainer</code></pre>

<p>---</p>
<p><em>Rapport gegenereerd: 2025-09-18</em></p>
<p><em>Analyst: Debug Specialist</em></p>
<p><em>US-201 - EPIC-020 Operation Phoenix</em></p>
  </div>
</body>
</html>