<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>US-447: titel: Extract Generation Orchestrator (Phase 2)</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <p>---</p>
<p>id: US-447</p>
<p>epic: EPIC-026</p>
<p>titel: "US-447: titel: Extract Generation Orchestrator (Phase 2)"</p>
<p>owner: code-architect</p>
<p>prioriteit: P1</p>
<p>status: pending</p>
<p>estimate: 2 weeks</p>
<p>sprint: Phase 2 Week 9-10</p>
<p>created: 2025-10-03</p>
<p>blocked_by: US-454</p>
<p>---</p>

<h1>US-447: Extract Generation Orchestrator (Phase 2)</h1>

<p><strong>Epic:</strong> EPIC-026 - God Object Refactoring</p>
<p><strong>Owner:</strong> Code Architect</p>
<p><strong>Priority:</strong> P1 (HIGH - critical path)</p>
<p><strong>Estimate:</strong> 2 weeks (10 days)</p>
<p><strong>Sprint:</strong> Phase 2 Week 9-10</p>

<p>---</p>

<h2>User Story</h2>

<p><strong>As a</strong> code architect</p>
<p><strong>I want to</strong> extract the 380 LOC god method to a dedicated orchestrator service</p>
<p><strong>So that</strong> the UI layer is thin and the core workflow is testable in isolation</p>

<p>---</p>

<h2>Context</h2>

<p><strong>The God Method:</strong></p>
<pre><code>Location: src/ui/tabbed_interface.py::_handle_definition_generation()
Lines: 821-1201 (380 LOC)
Complexity: 116 (CRITICAL)
Current tests: 0</code></pre>

<p><strong>What it does:</strong></p>
<ol>
<li>Validates context (min 1 of org/jur/wet)</li>
<li>Determines ontological category (async, 6-step protocol)</li>
<li>Checks for duplicates (3 outcomes)</li>
<li>Integrates document context (PDF processing)</li>
<li>Handles regeneration override</li>
<li>Orchestrates definition generation (async)</li>
<li>Stores results in 15+ session state keys</li>
<li>Prepares edit tab state</li>
<li>Cleans up regeneration context</li>
<li>Shows success message</li>
</ol>

<p><strong>Why extract:</strong></p>
<ul>
<li>380 LOC in 1 method violates SRP</li>
<li>Impossible to test (mocking st.session_state is nightmare)</li>
<li>Business logic mixed with UI code</li>
<li>Cannot reuse workflow outside Streamlit UI</li>
</ul>

<p>---</p>

<h2>Acceptance Criteria</h2>

<h3>AC1: Service Created</h3>

<p><strong>File:</strong> <code>src/services/orchestrators/generation_orchestrator.py</code></p>

<pre><code>class GenerationOrchestrator:
    """Orchestrates definition generation workflow (10 steps)"""

    def __init__(
        self,
        definition_service: DefinitionService,
        category_service: CategoryService,
        document_service: DocumentService,
        duplicate_checker: DuplicateChecker,
        regeneration_service: RegenerationService
    ):
        # Dependency injection (not hardcoded!)
        self.definition_service = definition_service
        self.category_service = category_service
        self.document_service = document_service
        self.duplicate_checker = duplicate_checker
        self.regeneration_service = regeneration_service

    async def generate(
        self,
        request: GenerationRequest
    ) -&gt; GenerationResult:
        """Execute 10-step generation workflow"""
        # Step 1: Validate context
        self._validate_context(request)

        # Step 2: Determine category
        category = await self.category_service.determine(request.begrip)

        # Step 3: Check duplicates
        duplicates = self.duplicate_checker.find(request.begrip, request.context)
        if duplicates:
            return GenerationResult.duplicate_found(duplicates)

        # Step 4-10: Continue workflow...
        # (Implementation details)

        return GenerationResult.success(definition)</code></pre>

<p>---</p>

<h3>AC2: UI Layer Thinned</h3>

<p><strong>Before (380 LOC in UI):</strong></p>
<pre><code>def _handle_definition_generation():
    # 380 lines of business logic in UI!
    if not (org_context or jur_context or wet_context):
        st.error("Minimaal 1 context vereist")
        return

    category = await determine_category(...)
    duplicates = check_duplicates(...)
    # ... 370 more lines</code></pre>

<p><strong>After (<50 LOC in UI):</strong></p>
<pre><code>def _handle_definition_generation():
    """UI handler - delegates to orchestrator"""
    orchestrator = get_generation_orchestrator()  # From ServiceContainer

    request = GenerationRequest(
        begrip=st.session_state.begrip,
        context=get_current_context(),
        documents=st.session_state.get("uploaded_documents", [])
    )

    try:
        result = await orchestrator.generate(request)

        if result.is_duplicate:
            _show_duplicate_dialog(result.duplicates)
        elif result.is_success:
            _store_result(result)
            st.success("Definitie gegenereerd!")
        else:
            st.error(result.error_message)

    except Exception as e:
        st.error(f"Fout: {e}")</code></pre>

<p><strong>LOC Reduction:</strong> 380 → 50 (87% reduction)</p>

<p>---</p>

<h3>AC3: Clean Async Patterns</h3>

<p><strong>Problem:</strong> Current code has nested <code>asyncio.run()</code> (57 files!)</p>

<pre><code># BAD (current code):
def ui_handler():
    result = asyncio.run(async_function())  # Creates event loop
    # Later...
    result2 = asyncio.run(another_async())  # ERROR if loop running!</code></pre>

<p><strong>Solution:</strong> Proper async boundaries</p>

<pre><code># GOOD (new pattern):
class GenerationOrchestrator:
    async def generate(self, request):
        # Pure async - no event loop creation
        category = await self.category_service.determine(...)
        definition = await self.definition_service.generate(...)
        return result

# UI layer:
def ui_handler():
    orchestrator = get_generation_orchestrator()
    # Single event loop entry point
    result = run_async(orchestrator.generate(request))</code></pre>

<p><strong><code>run_async()</code> helper:</strong></p>
<pre><code>def run_async(coro):
    """Safe async bridge for Streamlit (single event loop)"""
    loop = asyncio.get_event_loop()
    if loop.is_running():
        # Use thread pool executor (safe for Streamlit)
        return loop.run_in_executor(None, asyncio.run, coro)
    else:
        return asyncio.run(coro)</code></pre>

<p>---</p>

<h3>AC4: Test Coverage</h3>

<ul>
<li>[ ] 150+ tests for GenerationOrchestrator (from US-454)</li>
<li>[ ] 95%+ branch coverage</li>
<li>[ ] All 10 steps tested independently</li>
<li>[ ] Integration tests: 30 scenarios passing</li>
<li>[ ] Golden baseline: 100% match for 42 definitions</li>
</ul>

<p>---</p>

<h3>AC5: State Management</h3>

<p><strong>Problem:</strong> 15+ direct <code>st.session_state</code> mutations</p>

<p><strong>Before:</strong></p>
<pre><code>st.session_state.category = category
st.session_state.generated_definition = definition
st.session_state.editing_definition_id = definition_id
# ... 12 more</code></pre>

<p><strong>After:</strong> Centralized via SessionStateManager</p>

<pre><code>class GenerationOrchestrator:
    def __init__(self, state_manager: SessionStateManager):
        self.state_manager = state_manager

    async def generate(self, request):
        result = # ... generation logic

        # Atomic state update
        self.state_manager.update({
            "category": result.category,
            "generated_definition": result.definition,
            "editing_definition_id": result.definition_id
        })</code></pre>

<p>---</p>

<h2>Technical Requirements</h2>

<h3>Service Boundaries</h3>

<pre><code>GenerationOrchestrator
├── Depends on (injected):
│   ├── CategoryService (determine category)
│   ├── DefinitionService (generate definition)
│   ├── DocumentService (process PDFs)
│   ├── DuplicateChecker (find duplicates)
│   └── RegenerationService (handle overrides)
├── Returns: GenerationResult
└── No UI dependencies (pure business logic)</code></pre>

<p>---</p>

<h3>Request/Response DTOs</h3>

<pre><code>@dataclass
class GenerationRequest:
    begrip: str
    context: DefinitionContext  # org/jur/wet
    documents: List[UploadedFile]
    regeneration_context: Optional[RegenerationContext] = None

@dataclass
class GenerationResult:
    success: bool
    definition: Optional[str] = None
    category: Optional[str] = None
    definition_id: Optional[int] = None
    duplicates: Optional[List[Duplicate]] = None
    error_message: Optional[str] = None

    @staticmethod
    def duplicate_found(duplicates):
        return GenerationResult(success=False, duplicates=duplicates)

    @staticmethod
    def success(definition, category, definition_id):
        return GenerationResult(
            success=True,
            definition=definition,
            category=category,
            definition_id=definition_id
        )</code></pre>

<p>---</p>

<h2>Implementation Plan</h2>

<h3>Week 9 (Days 41-45)</h3>

<p><strong>Day 41-42: Create Service Shell</strong></p>
<ul>
<li>Create `generation_orchestrator.py`</li>
<li>Define interfaces (GenerationRequest, GenerationResult)</li>
<li>Inject dependencies (5 services)</li>
<li>Basic smoke test (orchestrator instantiates)</li>
</ul>

<p><strong>Day 43: Extract Steps 1-5</strong></p>
<ul>
<li>Step 1: Context validation</li>
<li>Step 2: Category determination</li>
<li>Step 3: Duplicate check</li>
<li>Step 4: Document context</li>
<li>Step 5: Regeneration override</li>
<li>Tests: 75 tests passing</li>
</ul>

<p><strong>Day 44: Extract Steps 6-10</strong></p>
<ul>
<li>Step 6: Definition generation (async)</li>
<li>Step 7: Result storage</li>
<li>Step 8: Edit tab preparation</li>
<li>Step 9: Cleanup</li>
<li>Step 10: Success/error handling</li>
<li>Tests: 150 tests passing</li>
</ul>

<p><strong>Day 45: Integration Testing</strong></p>
<ul>
<li>Run 30 integration scenarios</li>
<li>Golden baseline validation (42 definitions)</li>
<li>Fix any regressions</li>
</ul>

<p>---</p>

<h3>Week 10 (Days 46-50)</h3>

<p><strong>Day 46-47: Thin UI Layer</strong></p>
<ul>
<li>Replace 380 LOC god method with orchestrator call</li>
<li>Reduce to <50 LOC in UI</li>
<li>Remove all business logic from tabbed_interface.py</li>
</ul>

<p><strong>Day 48: Async Cleanup</strong></p>
<ul>
<li>Remove nested asyncio.run() calls</li>
<li>Implement clean async boundaries</li>
<li>Fix 57 files using asyncio.run (focus on UI layer)</li>
</ul>

<p><strong>Day 49: State Management Migration</strong></p>
<ul>
<li>Replace direct st.session_state with SessionStateManager</li>
<li>Atomic state updates in orchestrator</li>
<li>Test state isolation</li>
</ul>

<p><strong>Day 50: Final Validation</strong></p>
<ul>
<li>All 150+ tests GREEN</li>
<li>Integration tests passing</li>
<li>Golden baseline 100% match</li>
<li>Code review</li>
</ul>

<p>---</p>

<h2>Dependencies</h2>

<p><strong>Depends On:</strong></p>
<ul>
<li>US-454 (Generation Orchestrator Tests) - 150 tests MUST exist before extraction</li>
</ul>

<p><strong>Blocks:</strong></p>
<ul>
<li>US-451 (Thin UI Layer) - depends on orchestrator being extracted</li>
</ul>

<p>---</p>

<h2>Risks</h2>

<h3>Risk 1: Async Refactoring Complexity</h3>
<p><strong>Likelihood:</strong> HIGH</p>
<p><strong>Impact:</strong> MEDIUM (timeline slip by 2-3 days)</p>
<p><strong>Mitigation:</strong></p>
<ul>
<li>Use proven async_bridge pattern (already exists in codebase)</li>
<li>Test async boundaries thoroughly</li>
<li>Have async expert review code</li>
</ul>

<h3>Risk 2: State Management Breaks UI</h3>
<p><strong>Likelihood:</strong> MEDIUM</p>
<p><strong>Impact:</strong> HIGH (workflows freeze, data loss)</p>
<p><strong>Mitigation:</strong></p>
<ul>
<li>State schema validation (from US-457 state audit)</li>
<li>Atomic state updates (all or nothing)</li>
<li>Integration tests catch state issues</li>
</ul>

<h3>Risk 3: Golden Baseline Mismatch</h3>
<p><strong>Likelihood:</strong> MEDIUM</p>
<p><strong>Impact:</strong> CRITICAL (cannot deploy if <95% match)</p>
<p><strong>Mitigation:</strong></p>
<ul>
<li>Run golden baseline after EACH step extraction</li>
<li>If mismatch: investigate immediately (don't continue)</li>
<li>Tolerance: 0% for business logic, <5% for LLM variance</li>
</ul>

<p>---</p>

<h2>Success Metrics</h2>

<ul>
<li>[ ] 380 LOC god method extracted to service</li>
<li>[ ] UI layer reduced to <50 LOC (87% reduction)</li>
<li>[ ] 150+ tests passing (95% coverage)</li>
<li>[ ] 30 integration scenarios GREEN</li>
<li>[ ] Golden baseline 100% match (42 definitions)</li>
<li>[ ] 0 circular dependencies</li>
<li>[ ] Async patterns clean (no nested event loops)</li>
<li>[ ] Code review approved</li>
</ul>

<p>---</p>

<h2>Rollback</h2>

<p><strong>Trigger:</strong> If golden baseline <95% match after Day 49</p>
<p><strong>Action:</strong> Rollback to Week 8 (before Phase 2)</p>
<p><strong>Impact:</strong> Phase 2 abandoned, UI remains god object</p>

<p>---</p>

<p><strong>Status:</strong> Pending (blocked by US-454)</p>
<p><strong>Next Action:</strong> Wait for Phase 0 Gate 1 + Phase 1 completion, then start Week 9</p>

  </div>
</body>
</html>