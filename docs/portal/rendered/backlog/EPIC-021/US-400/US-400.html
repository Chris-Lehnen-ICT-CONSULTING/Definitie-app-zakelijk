<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Implement Version Control System for Definitions</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <p>---</p>
<p>id: US-400</p>
<p>epic: EPIC-021</p>
<p>titel: Implement Version Control System for Definitions</p>
<p>type: feature</p>
<p>status: proposed</p>
<p>prioriteit: HIGH</p>
<p>story_points: 8</p>
<p>sprint: backlog</p>
<p>aangemaakt: 2025-09-29</p>
<p>bijgewerkt: 2025-09-29</p>
<p>owner: tech-lead</p>
<p>applies_to: definitie-app@current</p>
<p>canonical: false</p>
<p>last_verified: 2025-10-02</p>
<p>vereisten:</p>
<ul>
<li> - REQ-100</li>
<li> - REQ-101</li>
<p>toegewezen_aan: development-team</p>
<p>---</p>
</ul>

<h1>US-400: Implement Version Control System for Definitions</h1>

<p><strong>Epic:</strong> EPIC-021 - Definitie Geschiedenis & Audit Trail Management</p>

<h2>Gebruikersverhaal</h2>

<p><strong>Als een</strong> juridisch professional</p>
<p><strong>wil ik</strong> een volledig version control systeem voor definities</p>
<p><strong>zodat</strong> ik de evolutie van definities kan volgen en eerdere versies kan herstellen</p>

<h2>Acceptance Criteria</h2>

<h3>Functional Requirements</h3>

<ul>
<li>[ ] **Automatic Versioning**</li>
<li> - Create new version on every save</li>
<li> - Increment version numbers sequentially</li>
<li> - Track major/minor version distinctions</li>
<li> - Maintain version metadata</li>
</ul>

<ul>
<li>[ ] **Version Storage**</li>
<li> - Store complete definition snapshot per version</li>
<li> - Efficient delta storage for large definitions</li>
<li> - Maintain version hierarchy/tree</li>
<li> - Support branching for experiments</li>
</ul>

<ul>
<li>[ ] **Version Retrieval**</li>
<li> - List all versions for a definition</li>
<li> - Filter versions by date range</li>
<li> - Filter versions by author</li>
<li> - Search within version content</li>
</ul>

<ul>
<li>[ ] **Version Metadata**</li>
<li> - Author identification</li>
<li> - Timestamp (created/modified)</li>
<li> - Change description/reason</li>
<li> - Version tags/labels</li>
<li> - Parent version reference</li>
</ul>

<h3>Technical Requirements</h3>

<ul>
<li>[ ] **Database Schema**</li>
<li> - Create definitie_versies table</li>
<li> - Add version_id to definities table</li>
<li> - Create version_branches table</li>
<li> - Implement proper indexes</li>
</ul>

<ul>
<li>[ ] **Service Layer**</li>
<pre><code>  class VersionControlService:
      def create_version(self, definition_id: int, content: dict, metadata: dict) -&gt; Version
      def get_version(self, version_id: int) -&gt; Version
      def list_versions(self, definition_id: int, filters: VersionFilters) -&gt; List[Version]
      def get_latest_version(self, definition_id: int, branch: str = "main") -&gt; Version
      def tag_version(self, version_id: int, tag: str) -&gt; bool
      def branch_from_version(self, version_id: int, branch_name: str) -&gt; Version</code></pre>
</ul>

<ul>
<li>[ ] **API Endpoints**</li>
<li> - GET /api/definitions/{id}/versions</li>
<li> - GET /api/versions/{version_id}</li>
<li> - POST /api/definitions/{id}/versions</li>
<li> - PUT /api/versions/{version_id}/tag</li>
<li> - POST /api/versions/{version_id}/branch</li>
</ul>

<h3>Performance Requirements</h3>

<ul>
<li>[ ] Version creation < 500ms</li>
<li>[ ] Version retrieval < 200ms</li>
<li>[ ] Version listing < 1s for 1000+ versions</li>
<li>[ ] Storage overhead < 30% of original size</li>
</ul>

<h2>Implementation Details</h2>

<h3>Database Migration</h3>

<pre><code>-- Create version control tables
CREATE TABLE definitie_versies (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    definitie_id INTEGER NOT NULL,
    versie_nummer INTEGER NOT NULL,
    versie_label VARCHAR(50),
    branch_naam VARCHAR(100) DEFAULT 'main',
    parent_versie_id INTEGER,

    -- Content
    term VARCHAR(255) NOT NULL,
    definitie_tekst TEXT NOT NULL,
    context TEXT,
    bron TEXT,
    voorbeelden JSON,
    opmerkingen TEXT,
    validatie_resultaten JSON,

    -- Metadata
    auteur VARCHAR(255) NOT NULL,
    wijziging_reden TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_current BOOLEAN DEFAULT FALSE,
    is_published BOOLEAN DEFAULT FALSE,

    -- Checksums for integrity
    content_hash VARCHAR(64),

    FOREIGN KEY (definitie_id) REFERENCES definities(id),
    FOREIGN KEY (parent_versie_id) REFERENCES definitie_versies(id),
    UNIQUE(definitie_id, versie_nummer, branch_naam)
);

-- Add version tracking to main table
ALTER TABLE definities ADD COLUMN current_version_id INTEGER;
ALTER TABLE definities ADD FOREIGN KEY (current_version_id) REFERENCES definitie_versies(id);

-- Create indexes
CREATE INDEX idx_versies_definitie ON definitie_versies(definitie_id);
CREATE INDEX idx_versies_branch ON definitie_versies(branch_naam);
CREATE INDEX idx_versies_auteur ON definitie_versies(auteur);
CREATE INDEX idx_versies_created ON definitie_versies(created_at);</code></pre>

<h3>Version Control Service</h3>

<pre><code>from dataclasses import dataclass
from typing import List, Optional, Dict
import hashlib
import json

@dataclass
class Version:
    id: int
    definitie_id: int
    versie_nummer: int
    branch_naam: str
    content: dict
    metadata: dict
    created_at: datetime
    content_hash: str

class VersionControlService:
    def __init__(self, db_connection):
        self.db = db_connection

    def create_version(
        self,
        definition_id: int,
        content: dict,
        metadata: dict
    ) -&gt; Version:
        """Create new version with automatic numbering"""
        # Get next version number
        version_number = self._get_next_version_number(
            definition_id,
            metadata.get('branch', 'main')
        )

        # Calculate content hash
        content_hash = self._calculate_hash(content)

        # Check if content actually changed
        if self._is_duplicate(definition_id, content_hash):
            return self.get_latest_version(definition_id)

        # Insert new version
        version = self._insert_version(
            definition_id,
            version_number,
            content,
            metadata,
            content_hash
        )

        # Update current version pointer
        self._update_current_version(definition_id, version.id)

        return version

    def _calculate_hash(self, content: dict) -&gt; str:
        """Calculate SHA-256 hash of content"""
        content_str = json.dumps(content, sort_keys=True)
        return hashlib.sha256(content_str.encode()).hexdigest()</code></pre>

<h2>Test Scenarios</h2>

<h3>Unit Tests</h3>

<pre><code>def test_version_creation():
    """Test creating new version"""
    service = VersionControlService(mock_db)
    version = service.create_version(
        definition_id=1,
        content={'term': 'test', 'definitie': 'test def'},
        metadata={'author': 'user1', 'reason': 'Initial version'}
    )
    assert version.versie_nummer == 1
    assert version.branch_naam == 'main'

def test_version_numbering():
    """Test sequential version numbering"""
    # Create multiple versions
    # Verify numbers increment correctly

def test_duplicate_detection():
    """Test that identical content doesn't create new version"""
    # Create version
    # Try to create identical version
    # Verify no new version created

def test_branch_creation():
    """Test creating experimental branch"""
    # Create main version
    # Branch from it
    # Verify branch structure</code></pre>

<h3>Integration Tests</h3>

<ul>
<li>Test version creation with database</li>
<li>Test concurrent version creation</li>
<li>Test large definition versioning</li>
<li>Test version retrieval performance</li>
<li>Test storage efficiency</li>
</ul>

<h2>Definition of Done</h2>

<ul>
<li>[ ] Version control service implemented</li>
<li>[ ] Database migrations executed</li>
<li>[ ] API endpoints functional</li>
<li>[ ] Unit tests passing (>90% coverage)</li>
<li>[ ] Integration tests passing</li>
<li>[ ] Performance benchmarks met</li>
<li>[ ] Documentation updated</li>
<li>[ ] Code review completed</li>
<li>[ ] Security review passed</li>
</ul>

<h2>Dependencies</h2>

<ul>
<li>Database migration framework</li>
<li>JSON storage optimization</li>
<li>Hash calculation libraries</li>
<li>Current definition repository refactoring</li>
</ul>

<h2>Risks</h2>

<p>| Risk | Impact | Mitigation |</p>
<p>|------|--------|------------|</p>
<p>| Storage growth | HIGH | Implement delta storage, compression |</p>
<p>| Performance impact | MEDIUM | Add caching, optimize queries |</p>
<p>| Migration complexity | MEDIUM | Staged migration, rollback plan |</p>
<p>| Hash collisions | LOW | Use SHA-256, verify uniqueness |</p>

<h2>Notes</h2>

<ul>
<li>Consider implementing git-like branching model</li>
<li>Evaluate compression algorithms for storage</li>
<li>Plan for version pruning/archiving strategy</li>
<li>Consider read-only access for historical versions</li>
</ul>
  </div>
</body>
</html>