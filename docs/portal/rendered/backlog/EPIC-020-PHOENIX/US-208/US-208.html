<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Consolidate validation rules to single source</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <p>---</p>
<p>id: US-208</p>
<p>epic: EPIC-020</p>
<p>title: Consolidate validation rules to single source</p>
<p>status: open</p>
<p>priority: HIGH</p>
<p>created: 2025-01-18</p>
<p>updated: 2025-01-18</p>
<p>owner: development-team</p>
<p>applies_to: definitie-app@current</p>
<p>canonical: false</p>
<p>last_verified: 2025-10-02</p>
<p>tags:</p>
<ul>
<li> - phoenix</li>
<li> - validation</li>
<li> - consolidation</li>
<li> - refactoring</li>
<li> - toetsregels</li>
<p>estimated_hours: 20</p>
<p>actual_hours: 0</p>
<p>---</p>
</ul>

<h1>US-208: Consolidate validation rules to single source</h1>

<h2>User Story</h2>
<p>Als een <strong>systeembeheerder</strong> wil ik <strong>alle validatieregels in één gecentraliseerd systeem</strong> zodat ik <strong>regels consistent kan beheren zonder synchronisatie tussen JSON en Python bestanden</strong>.</p>

<h2>Context</h2>
<p>Het huidige systeem heeft een duaal JSON+Python formaat voor validatieregels:</p>
<ul>
<li>JSON bestanden in `config/toetsregels/regels/` definiëren metadata</li>
<li>Python modules in `src/toetsregels/regels/` implementeren logica</li>
<li>Synchronisatie tussen beide is foutgevoelig</li>
<li>Duplicatie van regel informatie</li>
<li>Moeilijk te onderhouden en uit te breiden</li>
</ul>

<p>Dit leidt tot:</p>
<ul>
<li>Inconsistenties tussen JSON metadata en Python implementatie</li>
<li>Onduidelijkheid over welke bron de "truth" is</li>
<li>Complexe deployment en testing procedures</li>
<li>Verhoogd risico op bugs door out-of-sync regels</li>
</ul>

<h2>Acceptance Criteria</h2>

<ol>
<li>**Single Source of Truth**</li>
</ol>
<ul>
<li>  - [ ] Alle regel metadata en logica in één locatie</li>
<li>  - [ ] Geen duplicatie tussen configuratie en code</li>
<li>  - [ ] Duidelijke scheiding tussen data en gedrag</li>
</ul>

<ol>
<li>**Rule Definition Format**</li>
</ol>
<ul>
<li>  - [ ] Nieuw unified rule format ontworpen</li>
<li>  - [ ] Backwards compatible met bestaande regel IDs</li>
<li>  - [ ] Support voor alle bestaande regel types (ARAI, CON, ESS, INT, SAM, STR, VER)</li>
<li>  - [ ] Metadata en implementatie in dezelfde module</li>
</ul>

<ol>
<li>**Migration Completed**</li>
</ol>
<ul>
<li>  - [ ] Alle 45+ bestaande regels gemigreerd</li>
<li>  - [ ] Legacy JSON bestanden verwijderd/gearchiveerd</li>
<li>  - [ ] Legacy Python modules gerefactored</li>
</ul>

<ol>
<li>**Rule Registry System**</li>
</ol>
<ul>
<li>  - [ ] Centraal register voor alle validatieregels</li>
<li>  - [ ] Dynamische regel discovery</li>
<li>  - [ ] Rule versioning support</li>
<li>  - [ ] Hot-reload capability voor development</li>
</ul>

<ol>
<li>**Validation Engine Update**</li>
</ol>
<ul>
<li>  - [ ] ModularValidationService aangepast voor nieuw format</li>
<li>  - [ ] ValidationOrchestratorV2 compatible</li>
<li>  - [ ] Performance gelijk of beter dan huidige systeem</li>
</ul>

<h2>Technical Design</h2>

<h3>New Unified Rule Structure</h3>
<pre><code># src/validation/rules/str_01.py
from dataclasses import dataclass
from typing import List, Optional, Dict, Any
from src.validation.base import BaseRule, ValidationResult, Priority

@dataclass
class STR01_GeenHoofdletterBegin(BaseRule):
    """Controleert of definitie niet met hoofdletter begint."""

    # Metadata (voorheen in JSON)
    id = "STR-01"
    name = "Hoofdletter aan begin"
    description = "Definities moeten met een kleine letter beginnen"
    category = "STR"
    priority = Priority.HIGH
    weight = 10.0
    active = True

    # Prompt hints voor AI (zie US-209)
    prompt_hints = {
        "instruction": "Begin de definitie ALTIJD met een kleine letter",
        "example": "betekenis: de zin of het belang van iets",
        "common_mistakes": ["Betekenis", "De betekenis"]
    }

    def validate(self, definition: str, context: Optional[Dict[str, Any]] = None) -&gt; ValidationResult:
        """Implementatie van de validatie logica."""
        if not definition:
            return ValidationResult(
                rule_id=self.id,
                passed=False,
                score=0,
                feedback="Definitie is leeg",
                details={}
            )

        first_char = definition.strip()[0]
        if first_char.isupper():
            return ValidationResult(
                rule_id=self.id,
                passed=False,
                score=0,
                feedback=f"Definitie begint met hoofdletter '{first_char}'",
                suggestions=[
                    f"Wijzig '{first_char}' naar '{first_char.lower()}'",
                    "Begin met een kleine letter tenzij het een eigennaam betreft"
                ],
                details={"first_character": first_char}
            )

        return ValidationResult(
            rule_id=self.id,
            passed=True,
            score=10,
            feedback="Definitie begint correct met kleine letter",
            details={"first_character": first_char}
        )

    def get_examples(self) -&gt; Dict[str, List[str]]:
        """Return positive and negative examples."""
        return {
            "positive": [
                "betekenis: de zin of het belang van iets",
                "proces: een reeks van handelingen"
            ],
            "negative": [
                "Betekenis: de zin of het belang van iets",
                "De betekenis van iets"
            ]
        }</code></pre>

<h3>Rule Registry Implementation</h3>
<pre><code># src/validation/registry.py
from typing import Dict, List, Type, Optional
from importlib import import_module
from pathlib import Path
import inspect

class RuleRegistry:
    """Central registry for all validation rules."""

    def __init__(self):
        self._rules: Dict[str, Type[BaseRule]] = {}
        self._categories: Dict[str, List[str]] = {}
        self._loaded = False

    def discover_rules(self, path: Path = Path("src/validation/rules")) -&gt; None:
        """Dynamically discover and load all rules."""
        for rule_file in path.glob("*.py"):
            if rule_file.name.startswith("_"):
                continue

            module_name = f"src.validation.rules.{rule_file.stem}"
            module = import_module(module_name)

            for name, obj in inspect.getmembers(module):
                if (inspect.isclass(obj) and
                    issubclass(obj, BaseRule) and
                    obj != BaseRule):
                    self.register_rule(obj)

        self._loaded = True

    def register_rule(self, rule_class: Type[BaseRule]) -&gt; None:
        """Register a validation rule."""
        rule_id = rule_class.id
        category = rule_class.category

        self._rules[rule_id] = rule_class

        if category not in self._categories:
            self._categories[category] = []
        self._categories[category].append(rule_id)

    def get_rule(self, rule_id: str) -&gt; Optional[Type[BaseRule]]:
        """Get a rule by ID."""
        if not self._loaded:
            self.discover_rules()
        return self._rules.get(rule_id)

    def get_rules_by_category(self, category: str) -&gt; List[Type[BaseRule]]:
        """Get all rules in a category."""
        if not self._loaded:
            self.discover_rules()
        rule_ids = self._categories.get(category, [])
        return [self._rules[rid] for rid in rule_ids]

    def get_all_rules(self) -&gt; Dict[str, Type[BaseRule]]:
        """Get all registered rules."""
        if not self._loaded:
            self.discover_rules()
        return self._rules.copy()</code></pre>

<h3>Migration Script</h3>
<pre><code># scripts/migrate_validation_rules.py
def migrate_rule(json_path: Path, python_path: Path, output_path: Path):
    """Migrate a rule from JSON+Python to unified format."""
    # Load JSON metadata
    with open(json_path) as f:
        metadata = json.load(f)

    # Load Python implementation
    spec = importlib.util.spec_from_file_location("rule", python_path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)

    # Generate unified rule class
    # ... implementation ...</code></pre>

<h2>Implementation Notes</h2>

<ol>
<li>**Backwards Compatibility**</li>
</ol>
<ul>
<li>  - Maintain existing rule IDs and categories</li>
<li>  - Create adapter layer tijdens migratie periode</li>
<li>  - Gradual migration per category mogelijk</li>
</ul>

<ol>
<li>**Performance Optimization**</li>
</ol>
<ul>
<li>  - Lazy loading van rules</li>
<li>  - Caching van rule instances</li>
<li>  - Parallel validation waar mogelijk</li>
</ul>

<ol>
<li>**Testing Requirements**</li>
</ol>
<ul>
<li>  - Unit tests voor elke gemigreerde regel</li>
<li>  - Integration tests voor rule registry</li>
<li>  - Performance benchmarks voor/na migratie</li>
<li>  - Regression tests voor validation outcomes</li>
</ul>

<ol>
<li>**Documentation Updates**</li>
</ol>
<ul>
<li>  - Update developer guide voor nieuwe rule format</li>
<li>  - Migration guide voor custom rules</li>
<li>  - API documentatie voor rule registry</li>
</ul>

<h2>Dependencies</h2>
<ul>
<li>Python 3.11+ (voor dataclasses en type hints)</li>
<li>No external dependencies required</li>
<li>Moet compatible zijn met existing validation orchestrator</li>
</ul>

<h2>Risks & Mitigations</h2>
<ul>
<li>**Risk**: Breaking existing validation flows</li>
<li> - **Mitigation**: Extensive testing, feature flags, gradual rollout</li>
</ul>

<ul>
<li>**Risk**: Performance degradation</li>
<li> - **Mitigation**: Benchmarking, profiling, optimization</li>
</ul>

<ul>
<li>**Risk**: Loss of rule configuration flexibility</li>
<li> - **Mitigation**: Ensure new format supports all current use cases</li>
</ul>

<h2>Definition of Done</h2>
<ul>
<li>[ ] Unified rule format gedefinieerd en gedocumenteerd</li>
<li>[ ] Rule registry geïmplementeerd en getest</li>
<li>[ ] Alle 45+ regels gemigreerd naar nieuw format</li>
<li>[ ] Legacy JSON/Python bestanden gearchiveerd</li>
<li>[ ] ModularValidationService aangepast voor nieuw format</li>
<li>[ ] Unit tests voor alle gemigreerde regels (>90% coverage)</li>
<li>[ ] Integration tests voor complete validation flow</li>
<li>[ ] Performance benchmarks show geen degradatie</li>
<li>[ ] Migration guide en documentatie compleet</li>
<li>[ ] Code review door senior developer</li>
<li>[ ] Smoke tests in staging environment</li>
</ul>

<h2>Notes</h2>
<ul>
<li>Coördineer met US-209 voor scheiding van prompt hints</li>
<li>Dit is een kritieke refactoring - plan rollback scenario</li>
<li>Overweeg feature flag voor geleidelijke activatie</li>
<li>Legacy code pas verwijderen na succesvolle productie run</li>
</ul>
  </div>
</body>
</html>