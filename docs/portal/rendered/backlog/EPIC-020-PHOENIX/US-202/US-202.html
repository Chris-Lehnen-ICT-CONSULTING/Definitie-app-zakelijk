<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Implement Validation Rules Caching to Prevent 45x Reloading</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <p>---</p>
<p>id: US-202</p>
<p>epic: EPIC-020</p>
<p>title: Implement Validation Rules Caching to Prevent 45x Reloading</p>
<p>status: open</p>
<p>priority: CRITICAL</p>
<p>story_points: 3</p>
<p>created: 2025-01-18</p>
<p>updated: 2025-01-18</p>
<p>owner: development-team</p>
<p>applies_to: definitie-app@current</p>
<p>canonical: false</p>
<p>last_verified: 2025-10-02</p>
<p>tags: [performance, caching, validation, rules]</p>
<p>---</p>

<h1>US-202: Implement Validation Rules Caching to Prevent 45x Reloading</h1>

<h2>User Story</h2>
<p><strong>Als</strong> gebruiker</p>
<p><strong>Wil ik</strong> dat validatieregels slechts eenmaal worden geladen</p>
<p><strong>Zodat</strong> de applicatie sneller reageert en minder resources gebruikt</p>

<h2>Probleem</h2>
<p>Huidige situatie: 45 validatieregels worden opnieuw geladen bij elke validatie run:</p>
<ul>
<li>**45x I/O operations** per validatie</li>
<li>**~2 seconden overhead** per definitie validatie</li>
<li>**Onnodige disk access** en JSON parsing</li>
<li>**Memory churn** door constant herladen</li>
</ul>

<h2>Acceptance Criteria</h2>

<h3>Must Have</h3>
<ul>
<li>[ ] Validatieregels worden **1x geladen** bij app start</li>
<li>[ ] Rules blijven in-memory cached tijdens sessie</li>
<li>[ ] Validatie tijd gereduceerd met >70%</li>
<li>[ ] Geen functionele regressie in validatie resultaten</li>
</ul>

<h3>Should Have</h3>
<ul>
<li>[ ] Hot-reload capability voor development mode</li>
<li>[ ] Cache invalidation bij config wijzigingen</li>
<li>[ ] Memory-efficient storage van regel metadata</li>
</ul>

<h3>Performance Targets</h3>
<ul>
<li>**Current**: ~2 seconden regel loading per validatie</li>
<li>**Target**: <50ms regel access per validatie</li>
<li>**Memory footprint**: <10MB voor alle regels</li>
</ul>

<h2>Technical Implementation</h2>

<h3>Caching Strategy</h3>
<pre><code># src/services/validation/rule_cache.py
from functools import lru_cache
import json
from pathlib import Path

class RuleCache:
    _instance = None
    _rules_cache = {}

    @classmethod
    @st.cache_data(ttl=3600)  # 1 hour TTL for development
    def load_all_rules(cls) -&gt; Dict[str, Rule]:
        """Load all validation rules once."""
        if not cls._rules_cache:
            rules_dir = Path("config/toetsregels/regels")
            for category in ["ARAI", "CON", "ESS", "INT", "SAM", "STR", "VER"]:
                category_path = rules_dir / category
                if category_path.exists():
                    for rule_file in category_path.glob("*.json"):
                        rule_id = rule_file.stem
                        cls._rules_cache[rule_id] = cls._load_rule(rule_file)
        return cls._rules_cache

    @staticmethod
    @lru_cache(maxsize=128)
    def _load_rule(rule_path: Path) -&gt; Rule:
        """Load and parse individual rule with caching."""
        with open(rule_path, 'r', encoding='utf-8') as f:
            return Rule.from_json(json.load(f))</code></pre>

<h3>Integration Points</h3>
<pre><code># src/services/validation/modular_validation_service.py
class ModularValidationService:
    def __init__(self):
        # Load rules once at initialization
        self.rules = RuleCache.load_all_rules()
        self.validators = self._initialize_validators()

    def validate(self, definition: Definition) -&gt; ValidationResult:
        # Use cached rules directly
        results = []
        for rule_id, rule in self.rules.items():
            validator = self.validators.get(rule.category)
            if validator:
                result = validator.validate(definition, rule)
                results.append(result)
        return ValidationResult(results)</code></pre>

<h3>Memory Optimization</h3>
<pre><code># Store only essential rule data
class OptimizedRule:
    __slots__ = ['id', 'category', 'priority', 'pattern', 'validator_fn']

    def __init__(self, rule_data):
        self.id = rule_data['id']
        self.category = rule_data['category']
        self.priority = rule_data['priority']
        self.pattern = self._compile_pattern(rule_data.get('pattern'))
        self.validator_fn = self._get_validator_function()</code></pre>

<h2>Test Scenarios</h2>

<h3>Performance Tests</h3>
<pre><code>def test_rule_loading_performance():
    """Rules should load in &lt;100ms after first load."""
    # First load (cold cache)
    start = time.time()
    rules1 = RuleCache.load_all_rules()
    first_load = time.time() - start

    # Second load (warm cache)
    start = time.time()
    rules2 = RuleCache.load_all_rules()
    cached_load = time.time() - start

    assert cached_load &lt; 0.1  # &lt;100ms
    assert rules1 is rules2  # Same instance
    assert len(rules1) == 45  # All rules loaded

def test_memory_footprint():
    """Total memory for rules should be &lt;10MB."""
    import sys
    rules = RuleCache.load_all_rules()
    total_size = sum(sys.getsizeof(rule) for rule in rules.values())
    assert total_size &lt; 10 * 1024 * 1024  # 10MB</code></pre>

<h3>Integration Tests</h3>
<ul>
<li>Validate 100 definitions and measure total time</li>
<li>Verify identical results with/without caching</li>
<li>Test cache behavior across Streamlit reruns</li>
</ul>

<h2>Key Files to Modify</h2>
<ol>
<li>`src/services/validation/modular_validation_service.py` - Add caching layer</li>
<li>`src/toetsregels/regel_loader.py` - Implement cached loader</li>
<li>`src/services/container.py` - Wire up cached rule service</li>
<li>`config/toetsregels.json` - Ensure proper structure for caching</li>
</ol>

<h2>Definition of Done</h2>

<ul>
<li>[ ] Rule caching implemented with @st.cache_data</li>
<li>[ ] Performance tests show >70% improvement</li>
<li>[ ] Memory usage stays under 10MB</li>
<li>[ ] All existing validation tests pass</li>
<li>[ ] No regression in validation accuracy</li>
<li>[ ] Cache invalidation mechanism documented</li>
<li>[ ] Performance metrics logged for monitoring</li>
</ul>

<h2>Dependencies</h2>
<ul>
<li>US-201 (ServiceContainer caching) - Should be completed first</li>
</ul>

<h2>Risks & Mitigations</h2>
<p>| Risk | Impact | Mitigation |</p>
<p>|------|---------|------------|</p>
<p>| Stale cache after rule updates | HIGH | Implement file watcher for dev mode |</p>
<p>| Memory pressure on low-end systems | MEDIUM | Implement LRU eviction if needed |</p>
<p>| Cache corruption | LOW | Add cache validation checksums |</p>

<h2>Notes</h2>
<ul>
<li>Critical for responsive user experience</li>
<li>Reduces I/O bottleneck significantly</li>
<li>Consider implementing rule versioning for cache invalidation</li>
<li>Future: Could pre-compile regex patterns for additional speed</li>
</ul>

<h2>Implementation Checklist</h2>
<ul>
<li>[ ] Create RuleCache class with singleton pattern</li>
<li>[ ] Implement @st.cache_data decorators</li>
<li>[ ] Add memory-efficient rule storage</li>
<li>[ ] Update ModularValidationService to use cache</li>
<li>[ ] Write comprehensive performance tests</li>
<li>[ ] Add cache metrics to logging</li>
<li>[ ] Document cache behavior and tuning options</li>
</ul>

<h2>Progress Tracking</h2>
<ul>
<li>[ ] Design reviewed</li>
<li>[ ] Implementation started</li>
<li>[ ] Unit tests written</li>
<li>[ ] Performance benchmarks completed</li>
<li>[ ] Code review done</li>
<li>[ ] Merged to main</li>
</ul>
  </div>
</body>
</html>