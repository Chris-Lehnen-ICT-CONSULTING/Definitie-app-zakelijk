<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>V2 Validator Migratieplan per Toetsregel</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <p>---</p>
<p>owner: validation</p>
<p>status: draft</p>
<p>last_verified: 2025-09-16</p>
<p>applies_to: definitie-app@current</p>
<p>canonical: true</p>
<p>---</p>

<h1>V2 Validator Migratieplan per Toetsregel</h1>

<p>Doel: elke bestaande toetsregel (JSON + legacy Python) migreren naar de V2‑validator (<code>ModularValidationService</code>) zonder backwards‑compatibility shims, conform CLAUDE.md, README (EPIC‑010 gates), V2‑contracten en schema.sql.</p>

<p>Bronnen</p>
<ul>
<li>JSON regels: `src/toetsregels/regels/*.json`</li>
<li>Legacy Python: `src/toetsregels/regels/*.py` en (soms) `src/toetsregels/validators/*.py`</li>
<li>V2 validator: `src/services/validation/modular_validation_service.py`</li>
<li>Orchestrator: `src/services/orchestrators/validation_orchestrator_v2.py`</li>
<li>Loader/manager: `src/toetsregels/loader.py`, `src/toetsregels/manager.py`</li>
<li>Legacy interpreter referentie: `src/validation/definitie_validator.py`</li>
</ul>

<p>Architectuurkeuzes (V2)</p>
<ul>
<li>Geen aanroep van legacy validators; logica wordt in V2 generiek geïnterpreteerd op basis van JSON + beperkte regel‑specifieke uitbreidingen.</li>
<li>Schema‑conforme output (TypedDict) met deterministische scores en gesorteerde violations.</li>
<li>Regelseverity/gewicht: afgeleid uit JSON (`aanbeveling`, `prioriteit`), identiek aan `definitie_validator.ValidationRegelInterpreter` waar zinvol.</li>
</ul>

<p>Algemene migratiestappen per regel</p>
<p>1) JSON inlezen via ToetsregelManager (al aanwezig). Zorg dat <code>loader.load_toetsregels()</code> de <code>id</code> overschrijft naar bestandsnaam (hyphenated, gebeurt al).</p>
<p>2) Bepaal evaluatietype:</p>
<ul>
<li>  - forbidden_patterns (regex) → FORBIDDEN_PATTERN violation</li>
<li>  - required_elements (afgeleid; bijv. ESS‑02) → MISSING_ELEMENT</li>
<li>  - structure_checks (afgeleid) → STRUCTURE_ISSUE</li>
<p>3) Severity en weight bepalen op basis van JSON (<code>aanbeveling</code>, <code>prioriteit</code>).</p>
<p>4) Scoreberekening: startscore 1.0; aftrek per overtreding met multiplier o.b.v. severity (zoals in legacy interpreter), bodemen op 0.0.</p>
<p>5) Violations deterministisch sorteren op <code>code</code>.</p>
<p>6) Tests: unit (rule‑specifiek) + integratie (end‑to‑end via orchestrator V2).</p>
</ul>

<p>Bekende extra patronen (uit legacy interpreter) — samenvoegen</p>
<ul>
<li>CON-01, ESS-01, INT-01, INT-03, STR-01, STR-02 hebben aanvullende regexen in `validation/definitie_validator.py` (mappen naar `additional_patterns`). Deze meenemen in de V2‑evaluatie.</li>
</ul>

<p>Specifieke notitie ESS‑02</p>
<ul>
<li>Ondersteun metadata‑override (marker) en eenduidigheid (exact één categorie). Zie `src/toetsregels/validators/ESS_02.py` voor referentiegedrag.</li>
</ul>

<p>---</p>

<h2>ARAI‑regels</h2>

<p>ARAI‑01 … ARAI‑06 (formele/algemene regels)</p>
<ul>
<li>Bestanden: `src/toetsregels/regels/ARAI-0X.json` (+ `.py`)</li>
<li>Stappen per regel:</li>
<p>  1) Lees JSON en extraheer <code>herkenbaar_patronen</code> → <code>FORBIDDEN_PATTERN</code> checks in V2.</p>
<p>  2) Bepaal severity/weight uit JSON.</p>
<p>  3) Voeg tests toe: 2× foute/2× goede voorbeelden uit JSON (unit), integratie via orchestrator.</p>
<p>  4) Als Python‑module extra detectie bevat t.o.v. JSON, port minimalistisch als extra regex.</p>
</ul>

<p>Regels: ARAI-01, ARAI-02, ARAI-02SUB1, ARAI-02SUB2, ARAI-03, ARAI-04, ARAI-04SUB1, ARAI-05, ARAI-06.</p>

<p>---</p>

<h2>CON‑regels</h2>

<p>CON‑01 — Eigen definitie voor elke context (zonder expliciet te benoemen)</p>
<ul>
<li>JSON: `src/toetsregels/regels/CON-01.json`</li>
<li>Extra: aanvullende patronen in legacy interpreter (UI/juridische namen, “volgens het Wetboek…”).</li>
<li>Stappen:</li>
<p>  1) Merge JSON‑patronen + aanvullende regexen → één lijst in V2.</p>
<p>  2) FORBIDDEN_PATTERN violations met <code>category="samenhang"</code>.</p>
<p>  3) Tests: JSON goede/foute voorbeelden + extra negatieve case (OM/DJI/“in de context van”).</p>
</ul>

<p>CON‑02 — Authentieke bron (indien van toepassing)</p>
<ul>
<li>JSON: `src/toetsregels/regels/CON-02.json`</li>
<li>Stappen:</li>
<p>  1) Definieer <code>required_elements=["authentieke_bron_basis"]</code> → <code>_has_authentic_source_basis</code> equivalent in V2.</p>
<p>  2) MISSING_ELEMENT bij ontbreken; severity volgens JSON.</p>
<p>  3) Tests: met/zonder bronindicatoren (“volgens”, “conform”, “wet/regeling”).</p>
</ul>

<p>---</p>

<h2>ESS‑regels</h2>

<p>ESS‑01 — Essentie, niet doel</p>
<ul>
<li>JSON: `src/toetsregels/regels/ESS-01.json`</li>
<li>Extra: aanvullende patronen ("om te", "met als doel", …) al in JSON; legacy voegt o.a. "gericht op" toe (al aanwezig).</li>
<li>Stappen:</li>
<p>  1) FORBIDDEN_PATTERN op alle doelgerichte frasen.</p>
<p>  2) Tests: JSON goede/foute voorbeelden, plus randgeval “ten behoeve van”.</p>
</ul>

<p>ESS‑02 — Ontologische categorie expliciteren</p>
<ul>
<li>JSON: `src/toetsregels/regels/ESS-02.json`; Python: `src/toetsregels/validators/ESS_02.py` (referentie‑gedrag) en `src/toetsregels/regels/ESS-02.py`.</li>
<li>Stappen:</li>
<p>  1) Implementatie in V2: </p>
<li>    - metadata override: `context.marker ∈ {type, exemplaar/particulier, proces/activiteit, resultaat/uitkomst}` → direct pass (1.0).</li>
<li>    - Regexhits per categorie uit JSON; precies één categorie → pass; meerdere → ambigu‑violation; geen → missing‑element/structure‑issue.</li>
<p>  2) Violations:</p>
<li>    - `CONTENT_ISSUE` bij ambiguïteit; `MISSING_ELEMENT` bij geen marker; severity=critical indien JSON `verplicht`+`hoog`.</li>
<p>  3) Tests: één‑hit, multi‑hit (fail), none‑hit (fail), metadata override (pass).</p>
</ul>

<p>ESS‑03 — Unieke identificatie/onderscheidbaarheid</p>
<ul>
<li>JSON: `src/toetsregels/regels/ESS-03.json`</li>
<li>Stappen: required element `_has_unique_identification` equivalent; MISSING_ELEMENT bij ontbreken; tests met “code/id/registratie/nummer”.</li>
</ul>

<p>ESS‑04 — Objectief toetsbare elementen</p>
<ul>
<li>JSON: `src/toetsregels/regels/ESS-04.json`</li>
<li>Stappen: required element `_has_testable_element` equivalent; tests met cijfers/term‑triggers.</li>
</ul>

<p>ESS‑05 — Onderscheidende kenmerken</p>
<ul>
<li>JSON: `src/toetsregels/regels/ESS-05.json`</li>
<li>Stappen: required element `_has_distinguishing_feature` equivalent; tests met “onderscheidt/kenmerk”.</li>
</ul>

<p>---</p>

<h2>INT‑regels</h2>

<p>INT‑01 — Eén zin (maximaal) / duidelijke structuur</p>
<ul>
<li>JSON: `src/toetsregels/regels/INT-01.json`</li>
<li>Extra: aanvullende patronen in legacy (meerdere zinnen detectie, “;” heuristiek).</li>
<li>Stappen: structure checks `max_one_sentence`, `clear_structure` (≥5 woorden); voeg aanvullende regex uit legacy toe; tests met dubbele zinnen en minimale lengte.</li>
</ul>

<p>INT‑02 — (Titel en inhoud, afhankelijk van JSON)</p>
<ul>
<li>JSON: `src/toetsregels/regels/INT-02.json`</li>
<li>Stappen: toepassen zoals JSON: forbidden/required/structure; tests met voorbeelden.</li>
</ul>

<p>INT‑03 — Verwijswoorden (“deze/dit/die”) vermijden</p>
<ul>
<li>JSON: `src/toetsregels/regels/INT-03.json`</li>
<li>Extra: aanvullende patroon (uitsluiten wanneer gevolgd door “begrip/definitie/regel”).</li>
<li>Stappen: FORBIDDEN_PATTERN + uitzondering; tests met en zonder uitzonderingsfrase.</li>
</ul>

<p>INT‑04 … INT‑10</p>
<ul>
<li>JSON: `src/toetsregels/regels/INT-0X.json`</li>
<li>Stappen: idem: JSON → V2 mapping; voeg waar nodig extra regex uit legacy toe.</li>
</ul>

<p>---</p>

<h2>SAM‑regels (samenhang)</h2>

<p>SAM‑01 … SAM‑08</p>
<ul>
<li>JSON: `src/toetsregels/regels/SAM-0X.json`</li>
<li>Stappen per regel: JSON patronen/vereisten → V2; categoriseer violations als `samenhang`; tests per JSON voorbeelden.</li>
</ul>

<p>---</p>

<h2>STR‑regels (structuur)</h2>

<p>STR‑01 — Start met zelfstandig naamwoord</p>
<ul>
<li>JSON: `src/toetsregels/regels/STR-01.json`</li>
<li>Extra: aanvullende verboden starts ("is", "de/het/een", "wordt", …) uit legacy.</li>
<li>Stappen: structure check `proper_noun_start` met forbidden starts; tests met “is/wordt” (fail) en correcte start (pass).</li>
</ul>

<p>STR‑02 — Concrete terminologie (tegen vage termen)</p>
<ul>
<li>JSON: `src/toetsregels/regels/STR-02.json`</li>
<li>Extra: aanvullende regex voor vage termen zonder specificatie.</li>
<li>Stappen: structure check `concrete_terminology`; tests met “proces/activiteit/zaak/ding” zonder specificatie (fail), met specificatie (pass).</li>
</ul>

<p>STR‑03 … STR‑09</p>
<ul>
<li>JSON: `src/toetsregels/regels/STR-0X.json`</li>
<li>Stappen: JSON → V2 mapping; structure‑categorie voor violations; tests per voorbeelden.</li>
</ul>

<p>---</p>

<h2>VER‑regels (verschijningsvorm)</h2>

<p>VER‑01 — Term in enkelvoud</p>
<ul>
<li>JSON: `src/toetsregels/regels/VER-01.json`</li>
<li>Stappen: eenvoudige lemma‑check (heuristisch: eindigt op “en” ≠ plurale tantum whitelist); tests met “gegevens/voertuigen” (fail) en “gegeven/voertuig” (pass).</li>
</ul>

<p>VER‑02 … VER‑03</p>
<ul>
<li>JSON: `src/toetsregels/regels/VER-0X.json`</li>
<li>Stappen: JSON → V2 mapping; tests per voorbeelden.</li>
</ul>

<p>---</p>

<h2>Overstijgende werkzaamheden</h2>

<p>1) V2 Evaluatie‑engine uitbreiden</p>
<ul>
<li>  - In `modular_validation_service.py`: </li>
<li>    - Laad regels (`ToetsregelManager.get_all_regels()` – al beschikbaar).</li>
<li>    - Evalueer per regel:</li>
<li>      * Forbidden patterns → matches → violations</li>
<li>      * Derived required elements / structure checks (zoals in legacy helpermethoden) → violations</li>
<li>    - Severity→multiplier, gewicht→aggregatie.</li>
<li>    - Map rule→category (`juridisch/structuur/samenhang/taal`) op basis van prefix (ESS/STR/SAM/CON/…)</li>
<li>  - Voeg `additional_patterns` voor CON‑01/ESS‑01/INT‑01/INT‑03/STR‑01/STR‑02.</li>
</ul>

<p>2) Tests</p>
<ul>
<li>  - Unit per regel (minimaal 2 foute + 2 goede voorbeelden, waar aanwezig in JSON).</li>
<li>  - Integratie: orchestrator V2 pad met realistische definities; schema‑conforme output.</li>
</ul>

<p>3) Documenteer aanpassingen (CHANGELOG) – geen nieuwe docsstructuur, enkel dit plan.</p>

<p>Risico’s & mitigaties</p>
<ul>
<li>Regex vals‑positief/negatief → golden tests per regel; extra voorbeelden toevoegen.</li>
<li>Performance bij veel regexen → compile cache + limiet op matches (early break).</li>
<li>Inconsistentie tussen JSON en Python‑module → JSON leidend; Python alleen als referentie voor uitbreidingen.</li>
</ul>

<p>Acceptatiecriteria (globaal)</p>
<ul>
<li>[ ] Alle regels uit `src/toetsregels/regels/*.json` worden geëvalueerd in V2 (zonder legacy aanroep)</li>
<li>[ ] Severity/weight volgen JSON (met multiplier mapping)</li>
<li>[ ] Schema‑conforme output; deterministische sorting</li>
<li>[ ] Golden tests per regel groen (minimaal basis cases)</li>
<li>[ ] ESS‑02: metadata‑override + eenduidigheid (1 hit) + ambigu (multi‑hit) afgedekt</li>
</ul>

<p>---</p>

<h2>Per‑Regel Validatie Specificatie (velden + methode)</h2>

<p>Onderstaande lijst specificeert per toetsregel waar (welke velden) en hoe (methode) gevalideerd wordt in de V2‑validator. Indien nodig worden afgeleide checks gebruikt zoals in de legacy helpermethoden. Severity en gewicht volgen JSON.</p>

<p>Legenda velden</p>
<ul>
<li>definitie: `Definition.definitie` (string)</li>
<li>begrip: `Definition.begrip` (lemma/term)</li>
<li>organisatorische_context/juridische_context/wettelijke_basis: contextlijsten (TEXT JSON arrays in DB; in memory list[str])</li>
<li>ontologische_categorie: `Definition.ontologische_categorie` (optioneel)</li>
<li>marker: `context["marker"]` in ValidationContext (optioneel)</li>
</ul>

<p>ARAI (ARAI‑01, ARAI‑02, ARAI‑02SUB1, ARAI‑02SUB2, ARAI‑03, ARAI‑04, ARAI‑04SUB1, ARAI‑05, ARAI‑06)</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: JSON `herkenbaar_patronen` → FORBIDDEN_PATTERN violations; extra regex uit legacy (indien aanwezig) toevoegen.</li>
<li>Violatiecategorie: taal/juridisch (afhankelijk van regel; default: juridisch)</li>
</ul>

<p>CON‑01 — Eigen definitie voor elke context (zonder expliciet te benoemen)</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: JSON patronen (o.a. “in de context van”, “juridisch”, “DJI/OM/ZM/KMAR”, “Wetboek van …”) + aanvullende regexen uit legacy interpreter → FORBIDDEN_PATTERN.</li>
<li>Violatiecategorie: samenhang</li>
</ul>

<p>CON‑02 — Authentieke bron (indien van toepassing)</p>
<ul>
<li>Velden: definitie (primair)</li>
<li>Methode: required element `authentieke_bron_basis` → _has_authentic_source_basis (regex: “volgens|conform|gebaseerd|bepaald|bedoeld|wet|regeling”). Bij ontbreek → MISSING_ELEMENT.</li>
<li>Violatiecategorie: samenhang</li>
</ul>

<p>ESS‑01 — Essentie, niet doel</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: FORBIDDEN_PATTERN op doelgerichte frasen uit JSON (bv. “om te”, “met als doel”, “teneinde”, “zodat”, “gericht op”).</li>
<li>Violatiecategorie: juridisch</li>
</ul>

<p>ESS‑02 — Ontologische categorie expliciteren</p>
<ul>
<li>Velden: definitie, marker (context), ontologische_categorie (optioneel)</li>
<li>Methode: </li>
<li> - Marker‑override: als `marker ∈ {type, exemplaar/particulier, proces/activiteit, resultaat/uitkomst}` → PASS.</li>
<li> - Regex per categorie uit JSON: tel categorie‑hits; exact één → PASS; >1 → CONTENT_ISSUE “ambiguïteit”; 0 → MISSING_ELEMENT “ontologische categorie ontbreekt”.</li>
<li> - Structure check: `explicit_ontological_category` (fallback op indicatoren: “soort|type|categorie|klasse|proces|activiteit|handeling|resultaat|uitkomst|product|effect|exemplaar|instantie|specifiek”).</li>
<li>Violatiecategorie: juridisch</li>
</ul>

<p>ESS‑03 — Unieke identificatie</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: required element `unieke_identificatie_criterium` → _has_unique_identification (regex: “uniek|specifiek|identificeer|registratie|nummer|code|id”).</li>
<li>Violatiecategorie: juridisch</li>
</ul>

<p>ESS‑04 — Objectief toetsbare elementen</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: required element `objectief_toetsbaar_element` → _has_testable_element (regex: getallen, “binnen|na|voor|volgens|conform|gebaseerd op”).</li>
<li>Violatiecategorie: juridisch</li>
</ul>

<p>ESS‑05 — Onderscheidende kenmerken</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: required element `onderscheidend_kenmerk` → _has_distinguishing_feature (regex: “onderscheidt|specifiek|bijzonder|kenmerk|eigenschap”).</li>
<li>Violatiecategorie: juridisch</li>
</ul>

<p>INT‑01 — Eén zin / duidelijke structuur</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: structure checks `max_one_sentence` (regex splitsers), `clear_structure` (≥5 woorden). Aanvullende regexen uit legacy (“.;” heuristiek) meenemen.</li>
<li>Violatiecategorie: structuur</li>
</ul>

<p>INT‑02 — (volgt JSON)</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: patronen/vereisten/structuur uit JSON → overeenkomstige FORBIDDEN_PATTERN/MISSING_ELEMENT/STRUCTURE_ISSUE.</li>
<li>Violatiecategorie: structuur (of juridisch, volgens JSON)</li>
</ul>

<p>INT‑03 — Verwijswoorden vermijden</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: FORBIDDEN_PATTERN op “deze|dit|die|daarvan” met uitzondering als gevolgd door “begrip|definitie|regel” (lookahead‑uitzondering zoals legacy).</li>
<li>Violatiecategorie: structuur</li>
</ul>

<p>INT‑04 — Onduidelijke artikel‑verwijzingen</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: structure check `clear_article_references` (regex op “de proces/activiteit” zonder specificatie).</li>
<li>Violatiecategorie: structuur</li>
</ul>

<p>INT‑06, INT‑07, INT‑08, INT‑09, INT‑10 — (volgen JSON)</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: JSON patronen/vereisten → overeenkomstige checks; structure of juridisch categorie per regeltype.</li>
</ul>

<p>SAM‑01 … SAM‑08 — Samenhangregels</p>
<ul>
<li>Velden: definitie (primair; sommige kunnen cross‑checks vereisen, maar JSON is leidend)</li>
<li>Methode: JSON patronen/structuur → samenhang‑categorie violations.</li>
</ul>

<p>STR‑01 — Start met zelfstandig naamwoord</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: structure check `proper_noun_start` + forbidden starts (regex: “^(is|de|het|een|wordt|betreft|zijn|kan|moet|mag)\b”).</li>
<li>Violatiecategorie: structuur</li>
</ul>

<p>STR‑02 — Concrete terminologie</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: structure check `concrete_terminology` (verbied vage termen zonder specificatie: “proces|activiteit|zaak|ding” zonder kwalificatie).</li>
<li>Violatiecategorie: structuur</li>
</ul>

<p>STR‑03 … STR‑09 — (volgen JSON)</p>
<ul>
<li>Velden: definitie</li>
<li>Methode: JSON patronen/vereisten/structuur → overeenkomstige checks.</li>
</ul>

<p>VER‑01 — Term in enkelvoud</p>
<ul>
<li>Velden: begrip (lemma/term)</li>
<li>Methode: eenvoudige lemma‑heuristiek: detecteer meervoud (regex “\b(\w+en)\b”) met whitelist voor plurale tantum (lijst uitbreidbaar vanuit JSON “goede/foute voorbeelden”).</li>
<li>Violatiecategorie: taal/vorm</li>
</ul>

<p>VER‑02 … VER‑03 — (volgen JSON)</p>
<ul>
<li>Velden: begrip of definitie (afhankelijk van JSON “geldigheid”)</li>
<li>Methode: JSON patronen/vereisten → overeenkomstige checks.</li>
</ul>

<p>---</p>

<h3>CON‑01 — Deep: Daadwerkelijke Validatie + DB‑kruischeck</h3>

<p>Doel van de regel (samengevat):</p>
<ul>
<li>De definitie moet contextspecifiek geformuleerd zijn ZONDER de context expliciet te benoemen in de tekst.</li>
<li>Voor hetzelfde begrip met exact dezelfde contextcombinatie moet er géén parallelle “nieuwe” definitie ontstaan; toon dan de bestaande (UI‑verantwoordelijkheid), de validator kan dit signaleren.</li>
</ul>

<p>Invoer/velden</p>
<ul>
<li>begrip (string)</li>
<li>definitie (string)</li>
<li>organisatorische_context: list[str]</li>
<li>juridische_context: list[str]</li>
<li>wettelijke_basis: list[str]</li>
<li>categorie (optioneel, voor uniqueness)</li>
<li>repository (injectie via ServiceContainer)</li>
</ul>

<p>Normalisatie</p>
<ul>
<li>Contextlijsten normaliseren (casefold, trim, unieke volgorde) en serialiseren naar canonieke JSON (zoals schema.sql). Dit moet overeenkomen met de opslagvorm in DB (TEXT met JSON array).</li>
</ul>

<p>Valideer (in volgorde)</p>
<p>1) Context verplicht (primary gate)</p>
<ul>
<li>  - Check: minimaal één van de drie contextlijsten heeft lengte > 0.</li>
<li>  - Fout: MISSING_ELEMENT (critical) code: CON-01-NO-CONTEXT, message: “Geen context opgegeven (organisatorisch/juridisch/wettelijk).”</li>
<li>  - Rationale: Zonder context is de definitie niet contextspecifiek; regeldoel niet haalbaar.</li>
</ul>

<p>2) Duplicate contextcombinatie (signaal; geen hard fail, tenzij policy)</p>
<ul>
<li>  - Query (DB): zoek in `definities` naar record(s) met:</li>
<li>    - `begrip = ?`</li>
<li>    - genormaliseerde `organisatorische_context` exact gelijk</li>
<li>    - genormaliseerde `juridische_context` exact gelijk</li>
<li>    - (optioneel) `categorie = ?` (meenemen indien betekenislaag vastligt)</li>
<li>    - `status != 'archived'`</li>
<li>  - Als gevonden:</li>
<li>    - Violatie: INFO of WARNING (afhankelijk van gewenste gate) code: CON-01-DUP, message: “Bestaande definitie met dezelfde context gevonden”, metadata: {existing_definition_id, status}.</li>
<li>    - UI‑actie (buiten validator): toon bestaande definitie. Geen hard fail tenzij policy bepaalt dat dubbelen geblokkeerd worden bij established.</li>
<li>  - Rationale: schema.sql heeft UNIQUE op (begrip, organisatorische_context, juridische_context, categorie, status). Bij andere status kan er al bestaan; dit willen we signaleren i.p.v. falen.</li>
</ul>

<p>3) Geen expliciete contextbenoeming in definitietekst (taalpatroon)</p>
<ul>
<li>  - Check: FORBIDDEN_PATTERN op JSON‑patronen (o.a. “in de context van”, “juridisch(e)”, “DJI/OM/ZM/KMAR”, “volgens het Wetboek van …”).</li>
<li>  - Fout: FORBIDDEN_PATTERN (high) code: CON-01-TEXT-CONTEXT, message: “Definitie benoemt de context expliciet; formuleer impliciet.”</li>
<li>  - Rationale: regeltekst eist impliciete context; expliciet benoemen is tegenregel.</li>
</ul>

<p>4) (Optioneel) Implicietheidscheck lichtgewicht</p>
<ul>
<li>  - Soft‑heuristiek: als tekst letterlijk een of meer van de opgegeven contexttermen bevat, verhoog waarschuwing (geen extra fail) — voorkomt valse zekerheid.</li>
</ul>

<p>Fail/Pass logica samengevat</p>
<ul>
<li>Fail (hard): stap 1 (geen context) of stap 3 (expliciete context in tekst) — conform regelintentie en JSON.</li>
<li>Niet‑fail maar signaal: stap 2 duplicate → INFO/WARNING + metadata zodat UI kan tonen/redirecten.</li>
</ul>

<p>Alternatieve failcondities</p>
<ul>
<li>Policy‑gedreven: duplicate als ERROR wanneer bestaande definitie status ‘established’ heeft (om wildgroei te voorkomen). Deze keuze is product/UX‑gedreven; default in V2 = waarschuwing.</li>
</ul>

<h3>CON‑02 — Deep: Authentieke bron vereist (indien van toepassing)</h3>

<p>Velden</p>
<ul>
<li>definitie (primair), wettelijke_basis (list[str], secundair signaal)</li>
</ul>

<p>Validatie</p>
<ul>
<li>Primary: required element `authentieke_bron_basis` in definitietekst (regex: “\b(volgens|conform|gebaseerd|bepaald|bedoeld|wet|regeling)\b”).</li>
<li> - Fail: MISSING_ELEMENT (high/critical volgens JSON) code: CON-02-NO-BASIS als geen indicatoren voorkomen.</li>
<li>Secondary: als `wettelijke_basis` lijst niet leeg is, telt dit als extra signaal (kan INFO toevoegen bij afwezigheid in tekst); geen hard pass zonder tekstindicator (tenzij productbesluit).</li>
<li>Geen DB‑query vereist.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Pass: tekst bevat bron‑indicatoren (en optioneel non‑empty `wettelijke_basis`).</li>
<li>Fail: geen indicatoren in tekst (en lege `wettelijke_basis` → versterkt de melding in suggestions/metadata).</li>
</ul>

<p>---</p>

<h3>ESS‑01 — Deep: Essentie, niet doel</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>FORBIDDEN_PATTERN: doel/gebruik‑frases uit JSON (“om te”, “met als doel”, “bedoeld om/voor”, “teneinde”, “zodat”, “gericht op”, “ten behoeve van”).</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Pass: geen doel‑frases.</li>
<li>Fail: één of meer doel‑frases aangetroffen → FORBIDDEN_PATTERN (high/critical conform JSON).</li>
</ul>

<p>---</p>

<h3>ESS‑02 — Deep: Ontologische categorie expliciteren</h3>

<p>Velden</p>
<ul>
<li>definitie, context.marker (override), ontologische_categorie (optioneel signaal voor prompt, niet voor pass)</li>
</ul>

<p>Validatie</p>
<ul>
<li>Marker‑override: als `marker ∈ {type, exemplaar/particulier, proces/activiteit, resultaat/uitkomst}` → PASS (score 1.0).</li>
<li>Regex per categorie (JSON): tel categorie‑hits.</li>
<li> - 1 categorie → PASS (met metadata: {category, patterns}).</li>
<li> - >1 categorie → CONTENT_ISSUE (critical): “ambiguïteit – meerdere categorieën herkend”.</li>
<li> - 0 categorie → MISSING_ELEMENT (critical): “ontologische categorie niet expliciet”.</li>
<li>Structure fallback: `explicit_ontological_category` (indicatoren: “soort|type|categorie|klasse|proces|activiteit|handeling|resultaat|uitkomst|product|effect|exemplaar|instantie|specifiek”).</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Pass: marker of exact één categorie‑hit.</li>
<li>Fail: 0 of >1 categorie‑hits.</li>
</ul>

<p>---</p>

<h3>ESS‑03 — Deep: Unieke identificatie</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>Required element `_has_unique_identification` (regex: “\b(uniek|specifiek|identificeer|registratie|nummer|code|id)\b”).</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Pass: indicator aanwezig.</li>
<li>Fail: afwezig → MISSING_ELEMENT (severity volgens JSON).</li>
</ul>

<p>---</p>

<h3>ESS‑04 — Deep: Objectief toetsbare elementen</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>Required element `_has_testable_element` (regex: “\b(\d+|binnen|na|voor|volgens|conform|gebaseerd op)\b”).</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Pass: objectief toetsbaar element aanwezig.</li>
<li>Fail: afwezig → MISSING_ELEMENT.</li>
</ul>

<p>---</p>

<h3>ESS‑05 — Deep: Onderscheidende kenmerken</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>Required element `_has_distinguishing_feature` (regex: “\b(onderscheidt|specifiek|bijzonder|kenmerk|eigenschap)\b”).</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Pass: onderscheidend element aanwezig.</li>
<li>Fail: afwezig → MISSING_ELEMENT.</li>
</ul>

<p>---</p>

<h3>INT‑01 — Deep: Eén zin / duidelijke structuur</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>Structure `max_one_sentence`: splits op [.!?]+, maximaal 1 zin (lege trailing split toegestaan).</li>
<li>Structure `clear_structure`: minimaal 5 woorden (duidelijkheidseis).</li>
<li>Aanvullende heuristiek (legacy): detecteer “.;” en ‘;’ gevolgd door kleine letter als zinscheiding.</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Fail: >1 zin of te weinig woorden.</li>
<li>Pass: 1 zin en voldoende woorden.</li>
</ul>

<p>---</p>

<h3>INT‑03 — Deep: Verwijswoorden vermijden</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>FORBIDDEN_PATTERN: “\b(deze|dit|die|daarvan)\b”</li>
<li>Uitzondering: toestaan bij expliciete toelichting “\b(deze|dit|die)\b\s+(begrip|definitie|regel)” (geen violation).</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Fail: pronomen zonder uitzondering.</li>
<li>Pass: geen pronomen of met uitzondering.</li>
</ul>

<p>---</p>

<h3>INT‑04 — Deep: Duidelijke artikel‑verwijzingen</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>Structure `clear_article_references`: verbied “\bde\s+(proces|activiteit)\b(?!\s+\w+)” (vage artikel+generiek zonder nadere specificatie).</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Fail: onduidelijke artikel‑verwijzing.</li>
<li>Pass: geen vage artikel‑verwijzing of wel specificeert.</li>
</ul>

<p>---</p>

<h3>STR‑01 — Deep: Start met zelfstandig naamwoord</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>Structure `proper_noun_start`: niet beginnen met hulpwerkwoord/artikel.</li>
<li>FORBIDDEN starts: “^(is|de|het|een|wordt|betreft|zijn|kan|moet|mag)\b”.</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Fail: begint met verboden start.</li>
<li>Pass: begint met zelfstandig naamwoord/naamwoordgroep.</li>
</ul>

<p>---</p>

<h3>STR‑02 — Deep: Concrete terminologie (tegen vaagheid)</h3>

<p>Velden</p>
<ul>
<li>definitie</li>
</ul>

<p>Validatie</p>
<ul>
<li>Structure `concrete_terminology`: verbied vage termen zonder specificatie: “\b(proces|activiteit|zaak|ding)\b(?!\s+\w+)”.</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Fail: vage term zonder nadere kwalificatie.</li>
<li>Pass: voldoende gespecificeerde term of geen vage term.</li>
</ul>

<p>---</p>

<h3>VER‑01 — Deep: Term in enkelvoud</h3>

<p>Velden</p>
<ul>
<li>begrip (lemma)</li>
</ul>

<p>Validatie</p>
<ul>
<li>Heuristiek meervoud: regex “\b(\w+en)\b” (NL meervoudsvorm); whitelist van plurale tantum (uitbreidbaar) zoals ‘kosten’, ‘hersenen’. JSON voorbeelden helpen whitelist opstellen.</li>
<li>Geen DB‑query.</li>
</ul>

<p>Fail/Pass</p>
<ul>
<li>Fail: meervoudig lemma dat geen plurale tantum is.</li>
<li>Pass: enkelvoud of erkende plurale tantum.</li>
</ul>

<p>---</p>

<h2>Per‑Regel Deep Spec Index (compact)</h2>

<p>ARAI‑01..06 (+SUB1/SUB2):</p>
<ul>
<li>Velden: definitie; Methode: JSON forbidden patterns; Geen DB; Fail: pattern‑match; Pass: geen match.</li>
</ul>

<p>CON‑01: zie deep‑sectie.</p>

<p>CON‑02:</p>
<ul>
<li>Velden: definitie (+wettelijke_basis signaal); Methode: bronindicatoren in tekst (required), optioneel signaal vanuit lijst; Geen DB; Fail: geen indicatoren; Pass: wel indicatoren.</li>
</ul>

<p>ESS‑01..05: zie deep‑secties (boven) voor 01..05.</p>

<p>INT‑01/03/04: zie deep‑secties; INT‑02/06/07/08/09/10 volgen JSON (forbidden/required/structure) zonder DB.</p>

<p>SAM‑01..08:</p>
<ul>
<li>Velden: definitie; Methode: JSON patronen/coherentie‑checks; Geen DB; Fail: pattern‑match; Pass: geen match.</li>
</ul>

<p>STR‑01/02: zie deep‑secties; STR‑03..09 volgen JSON (forbidden/required/structure) zonder DB.</p>

<p>VER‑01: zie deep‑sectie; VER‑02/03 volgen JSON (velden: begrip of definitie volgens “geldigheid”).</p>

<p>---</p>

<h2>ARAI — Deep Specificaties</h2>

<h3>ARAI‑01 — Formele correctheid (volgt JSON)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON `herkenbaar_patronen` (formele/taalconstructies die niet thuishoren in definities) → FORBIDDEN_PATTERN (severity volgens JSON).</li>
<li>Fail/Pass: match → fail; geen match → pass.</li>
</ul>

<h3>ARAI‑02 / ARAI‑02SUB1 / ARAI‑02SUB2 — Precisie/consistentie subregels</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen per subregel; geen DB; FORBIDDEN_PATTERN of structure per definitie van de JSON.</li>
<li>Fail/Pass: match → fail; geen match → pass.</li>
</ul>

<h3>ARAI‑03 — Terminologische correctheid</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen; FORBIDDEN_PATTERN.</li>
</ul>

<h3>ARAI‑04 / ARAI‑04SUB1 — Modale hulpwerkwoorden vermijden</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen op “kan, moet, mag, zou, dient” etc. → FORBIDDEN_PATTERN (verlegd van doel/regelspraak naar definitie‑essentie).</li>
</ul>

<h3>ARAI‑05 / ARAI‑06 — Overige formele/taalregels</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen → FORBIDDEN_PATTERN.</li>
</ul>

<p>---</p>

<h2>SAM — Deep Specificaties</h2>

<h3>SAM‑01 — Kwalificatie leidt niet tot afwijking</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen op kwalificaties (“juridisch”, “technisch”, “operationeel”, …). Signaleer misleidende kwalificatie wanneer de definitie daardoor afwijkt van algemeen aanvaarde betekenis.</li>
<li>Fail/Pass: match → fail (semantische misleiding); of waarschuwing afhankelijk van policy.</li>
</ul>

<h3>SAM‑02 … SAM‑08 — Samenhangregels</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen (coherentie/consistentie) → FORBIDDEN_PATTERN of STRUCTURE_ISSUE conform JSON.</li>
<li>DB: niet vereist.</li>
</ul>

<p>---</p>

<h2>STR — Deep Specificaties (aanvullend)</h2>

<h3>STR‑03 — Begripsstructuur correct (volgt JSON)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen/structuur → STRUCTURE_ISSUE.</li>
</ul>

<h3>STR‑04 — Tautologie/cirkelredenering vermijden (volgt JSON)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen (bijv. herhalen van kernterm zonder afbakening) → STRUCTURE_ISSUE.</li>
</ul>

<h3>STR‑05 — Zinsbouw helder (volgt JSON)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON structuurregels (interpunctie, bijzinnen) → STRUCTURE_ISSUE.</li>
</ul>

<h3>STR‑06 — Terminologie consistent (volgt JSON)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen → FORBIDDEN_PATTERN/STRUCTURE_ISSUE.</li>
</ul>

<h3>STR‑07 — Redundantie vermijden (volgt JSON)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen (dubbelingen/overbodig taalgebruik) → STRUCTURE_ISSUE.</li>
</ul>

<h3>STR‑08 — Afbakening compleet (volgt JSON)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON vereisten → MISSING_ELEMENT/STRUCTURE_ISSUE.</li>
</ul>

<h3>STR‑09 — Jargon vermijden (volgt JSON)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: JSON patronen (vakjargon zonder toelichting) → FORBIDDEN_PATTERN.</li>
</ul>

<p>---</p>

<h2>INT — Deep Specificaties (aanvullend)</h2>

<h3>INT‑02 — Geen beslisregel (voorwaarden/normen uit de definitie)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: FORBIDDEN_PATTERN op voorwaardelijke/normatieve frasen: “indien, mits, alleen als, tenzij, voor zover, op voorwaarde dat, in geval dat”.</li>
<li>Fail/Pass: match → fail; geen match → pass.</li>
</ul>

<h3>INT‑06 — Geen toelichting in definitiezin</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: FORBIDDEN_PATTERN op “bijvoorbeeld/zoals/dit houdt in/dat wil zeggen/namelijk”.</li>
<li>Fail/Pass: match → fail; geen match → pass.</li>
</ul>

<h3>INT‑07 — Afkortingen toegelicht</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: detecteer afkortingen (regex \b[A-Z]{2,6}\b en whitelist). Fail wanneer zonder toelichting tussen haakjes of zonder link/uitwerking in hetzelfde stuk tekst.</li>
<li>Fail/Pass: onverklaarde afkorting → fail; verklaard of gelinkt → pass.</li>
</ul>

<h3>INT‑08 — Positieve formulering</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: FORBIDDEN_PATTERN op negatieve formuleringen (“niet/geen/zonder/uitgezonderd/…”) met ruimte voor uitzonderingen als ze specificerend zijn (optie: waarschuwing i.p.v. error).</li>
</ul>

<h3>INT‑09 — Limitatieve opsomming</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: FORBIDDEN_PATTERN op “zoals/bijvoorbeeld/onder andere/etc./enz./o.a./inclusief/waaronder begrepen/al dan niet”.</li>
<li>Fail/Pass: match → fail; geen match → pass.</li>
</ul>

<h3>INT‑10 — Geen ontoegankelijke achtergrondkennis</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: FORBIDDEN_PATTERN op “zie/zoals gedefinieerd in/afgekort als/zoals bekend binnen/volgens interne richtlijn/interne notitie/…”.</li>
<li>Fail/Pass: match → fail; geen match → pass. Toegestaan: expliciete, openbare bron met duidelijke verwijzing.</li>
</ul>

<p>---</p>

<h2>VER — Deep Specificaties (aanvullend)</h2>

<h3>VER‑02 — (volgt JSON)</h3>
<ul>
<li>Velden: begrip of definitie (volgens JSON geldigheid)</li>
<li>Validatie: JSON patronen; geen DB.</li>
</ul>

<h3>VER‑03 — (volgt JSON)</h3>
<ul>
<li>Velden: begrip of definitie</li>
<li>Validatie: JSON patronen; geen DB.</li>
</ul>

<p>---</p>

<h2>V2 Interne Regels (ModularValidationService) — Deep Specificaties</h2>

<h3>VAL‑EMP‑001 — Lege tekst</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: `len(chars) == 0` → fail (error). Geen DB.</li>
<li>Fail/Pass: leeg → fail; anders → pass.</li>
</ul>

<h3>VAL‑LEN‑001 — Te kort</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: woorden < 5 of chars < 15 → fail (error). Geen DB.</li>
</ul>

<h3>VAL‑LEN‑002 — Te lang/overdadig</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: woorden > 80 of chars > 600 → fail (error). Geen DB.</li>
</ul>

<h3>ESS‑CONT‑001 — Essentiële inhoud aanwezig (grove heuristiek)</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: woorden < 6 → fail (error) “Essentiële inhoud ontbreekt of te summier”. Geen DB.</li>
</ul>

<h3>CON‑CIRC‑001 — Circulair (begrip in definitie)</h3>
<ul>
<li>Velden: begrip, definitie</li>
<li>Validatie: regex match van begrip binnen definitietekst (word boundary, case‑insensitive) → fail (error).</li>
</ul>

<h3>STR‑TERM‑001 — Terminologie/structuur kleinigheid</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: specifieke verkeerde term (bijv. “HTTP protocol” i.p.v. “HTTP‑protocol”) → fail (warning). Uitbreidbaar.</li>
</ul>

<h3>STR‑ORG‑001 — Zwakke zinsstructuur of redundantie</h3>
<ul>
<li>Velden: definitie</li>
<li>Validatie: lange, aaneengeregen zin (chars > 300 en ≥6 komma’s) of redundantiepatroon (“simpel … complex”/vice versa) → fail (warning).</li>
</ul>

  </div>
</body>
</html>