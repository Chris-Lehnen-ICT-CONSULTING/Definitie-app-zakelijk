<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>US-217 ‚Äî Implementeer Consistente Error Handling Patterns</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <p>---</p>
<p>id: US-217</p>
<p>epic: EPIC-002</p>
<p>status: open</p>
<p>prioriteit: MEDIUM</p>
<p>story_points: 5</p>
<p>sprint: next</p>
<p>owner: backend</p>
<p>applies_to: definitie-app@current</p>
<p>canonical: false</p>
<p>last_verified: 2025-10-02</p>
<p>created_at: 2025-09-19</p>
<p>dependencies: [US-193, US-213]</p>
<p>---</p>

<h1>US-217 ‚Äî Implementeer Consistente Error Handling Patterns</h1>

<h2>Doel</h2>
<p>Standaardiseer error handling door de hele applicatie met consistente patterns, duidelijke error messages en proper error propagation voor betere maintainability en user experience.</p>

<h2>Context</h2>
<p>Uit de US-193 multi-agent review (P3-16) blijkt dat error handling inconsistent is met verschillende patterns, onduidelijke messages en soms verloren error context. Dit maakt debugging moeilijk en leidt tot poor user experience.</p>

<h2>Scope</h2>

<h3>In scope</h3>
<ul>
<li>Definieer standaard error handling patterns</li>
<li>Cre√´er custom exception hierarchy</li>
<li>Implementeer error context preservation</li>
<li>Standaardiseer error messages en codes</li>
<li>Add error recovery strategies</li>
<li>Implementeer proper async error handling</li>
</ul>

<h3>Niet in scope</h3>
<ul>
<li>Error monitoring/alerting (aparte US)</li>
<li>Retry mechanisme redesign</li>
<li>Circuit breaker patterns</li>
</ul>

<h2>Acceptance Criteria</h2>

<h3>Functioneel</h3>
<ul>
<li>[ ] Alle errors hebben duidelijke, actionable messages</li>
<li>[ ] Error codes voor machine-readable errors</li>
<li>[ ] Context behouden door error chain</li>
<li>[ ] User-friendly error messages in UI</li>
<li>[ ] Graceful degradation waar mogelijk</li>
</ul>

<h3>Technisch</h3>
<ul>
<li>[ ] Custom exception classes voor domein errors</li>
<li>[ ] Consistent try-except patterns</li>
<li>[ ] Error context via exception chaining</li>
<li>[ ] Async error handling correct</li>
<li>[ ] No bare except clauses</li>
</ul>

<h2>Implementatie</h2>

<h3>1. Custom Exception Hierarchy</h3>
<pre><code># src/exceptions/base.py
from typing import Optional, Dict, Any
from enum import Enum

class ErrorCode(Enum):
    """Standardized error codes for machine processing."""
    # Validation errors (1xxx)
    VALIDATION_FAILED = "ERR_1001"
    INVALID_INPUT = "ERR_1002"
    RULE_EXECUTION_FAILED = "ERR_1003"

    # Generation errors (2xxx)
    GENERATION_FAILED = "ERR_2001"
    AI_SERVICE_ERROR = "ERR_2002"
    PROMPT_BUILD_FAILED = "ERR_2003"
    RATE_LIMIT_EXCEEDED = "ERR_2004"

    # Data errors (3xxx)
    RECORD_NOT_FOUND = "ERR_3001"
    DATABASE_ERROR = "ERR_3002"
    DATA_CORRUPTION = "ERR_3003"

    # Service errors (4xxx)
    SERVICE_UNAVAILABLE = "ERR_4001"
    EXTERNAL_API_ERROR = "ERR_4002"
    TIMEOUT = "ERR_4003"

    # System errors (5xxx)
    CONFIGURATION_ERROR = "ERR_5001"
    INITIALIZATION_ERROR = "ERR_5002"
    UNEXPECTED_ERROR = "ERR_5999"

class DefinitieAppException(Exception):
    """Base exception for all application errors."""

    def __init__(
        self,
        message: str,
        code: ErrorCode = ErrorCode.UNEXPECTED_ERROR,
        details: Optional[Dict[str, Any]] = None,
        user_message: Optional[str] = None,
        cause: Optional[Exception] = None
    ):
        super().__init__(message)
        self.code = code
        self.details = details or {}
        self.user_message = user_message or message
        self.cause = cause

    def to_dict(self) -&gt; Dict[str, Any]:
        """Convert exception to dictionary for API responses."""
        return {
            "error": {
                "code": self.code.value,
                "message": self.user_message,
                "details": self.details,
                "type": self.__class__.__name__
            }
        }

# Domain-specific exceptions
class ValidationException(DefinitieAppException):
    """Exception for validation failures."""
    def __init__(self, message: str, **kwargs):
        super().__init__(
            message,
            code=ErrorCode.VALIDATION_FAILED,
            **kwargs
        )

class GenerationException(DefinitieAppException):
    """Exception for generation failures."""
    def __init__(self, message: str, **kwargs):
        super().__init__(
            message,
            code=ErrorCode.GENERATION_FAILED,
            **kwargs
        )

class DataException(DefinitieAppException):
    """Exception for data-related errors."""
    def __init__(self, message: str, **kwargs):
        super().__init__(
            message,
            code=ErrorCode.DATABASE_ERROR,
            **kwargs
        )

class ServiceException(DefinitieAppException):
    """Exception for service-related errors."""
    def __init__(self, message: str, **kwargs):
        super().__init__(
            message,
            code=ErrorCode.SERVICE_UNAVAILABLE,
            **kwargs
        )</code></pre>

<h3>2. Error Handling Patterns</h3>
<pre><code># src/exceptions/handlers.py
import logging
import functools
from typing import TypeVar, Callable, Optional, Type, Tuple
from contextlib import contextmanager

T = TypeVar('T')

def handle_errors(
    *exception_handlers: Tuple[Type[Exception], ErrorCode, str],
    default_message: str = "An unexpected error occurred",
    logger: Optional[logging.Logger] = None,
    raise_original: bool = False
) -&gt; Callable[[Callable[..., T]], Callable[..., T]]:
    """
    Decorator for consistent error handling.

    Usage:
        @handle_errors(
            (ValueError, ErrorCode.INVALID_INPUT, "Invalid input provided"),
            (KeyError, ErrorCode.RECORD_NOT_FOUND, "Record not found"),
            logger=logger
        )
        def my_function():
            ...
    """
    def decorator(func: Callable[..., T]) -&gt; Callable[..., T]:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -&gt; T:
            try:
                return func(*args, **kwargs)
            except Exception as e:
                # Check registered handlers
                for exc_type, code, message in exception_handlers:
                    if isinstance(e, exc_type):
                        if logger:
                            logger.error(
                                f"{func.__name__} failed: {message}",
                                exc_info=True,
                                extra={'error_code': code.value}
                            )

                        if raise_original:
                            raise

                        raise DefinitieAppException(
                            message=str(e),
                            code=code,
                            user_message=message,
                            cause=e
                        ) from e

                # Default handler
                if logger:
                    logger.error(
                        f"{func.__name__} failed with unexpected error",
                        exc_info=True
                    )

                if raise_original:
                    raise

                raise DefinitieAppException(
                    message=str(e),
                    code=ErrorCode.UNEXPECTED_ERROR,
                    user_message=default_message,
                    cause=e
                ) from e

        return wrapper
    return decorator

@contextmanager
def error_context(
    operation: str,
    logger: Optional[logging.Logger] = None,
    error_class: Type[DefinitieAppException] = DefinitieAppException,
    **context_details
):
    """
    Context manager for error handling with context preservation.

    Usage:
        with error_context("user_validation", logger=logger, user_id=123):
            # operations that might fail
    """
    try:
        if logger:
            logger.debug(f"Starting {operation}", extra=context_details)
        yield
    except DefinitieAppException:
        # Re-raise application exceptions with added context
        raise
    except Exception as e:
        if logger:
            logger.error(
                f"Failed {operation}",
                exc_info=True,
                extra=context_details
            )
        raise error_class(
            message=f"Failed to {operation}: {str(e)}",
            details=context_details,
            cause=e
        ) from e</code></pre>

<h3>3. Async Error Handling</h3>
<pre><code># src/exceptions/async_handlers.py
import asyncio
from typing import TypeVar, Callable, Awaitable

T = TypeVar('T')

def async_handle_errors(*args, **kwargs):
    """Async version of handle_errors decorator."""
    def decorator(func: Callable[..., Awaitable[T]]) -&gt; Callable[..., Awaitable[T]]:
        @functools.wraps(func)
        async def wrapper(*func_args, **func_kwargs) -&gt; T:
            try:
                return await func(*func_args, **func_kwargs)
            except asyncio.CancelledError:
                # Don't wrap cancellation
                raise
            except Exception as e:
                # Same error handling logic as sync version
                # ... (similar to handle_errors)
                raise

        return wrapper
    return decorator

async def with_timeout(
    coro: Awaitable[T],
    timeout: float,
    operation: str = "operation"
) -&gt; T:
    """Execute coroutine with timeout and proper error handling."""
    try:
        return await asyncio.wait_for(coro, timeout=timeout)
    except asyncio.TimeoutError:
        raise ServiceException(
            f"{operation} timed out after {timeout} seconds",
            code=ErrorCode.TIMEOUT,
            details={"timeout": timeout, "operation": operation}
        )</code></pre>

<h3>4. Service Integration</h3>
<pre><code># Example: src/services/validation/modular_validation_service.py
from exceptions.base import ValidationException, ErrorCode
from exceptions.handlers import handle_errors, error_context

class ModularValidationService:
    logger = get_logger(__name__)

    @handle_errors(
        (KeyError, ErrorCode.RULE_EXECUTION_FAILED, "Validation rule failed"),
        (ValueError, ErrorCode.INVALID_INPUT, "Invalid validation input"),
        logger=logger
    )
    async def validate_definition(
        self,
        begrip: str,
        text: str,
        **kwargs
    ) -&gt; ValidationDetailsDict:
        """Validate with consistent error handling."""

        with error_context(
            "definition_validation",
            logger=self.logger,
            error_class=ValidationException,
            begrip=begrip,
            text_length=len(text)
        ):
            # Validation logic here
            if not text:
                raise ValidationException(
                    "Definition text cannot be empty",
                    code=ErrorCode.INVALID_INPUT,
                    user_message="Definitie tekst mag niet leeg zijn"
                )

            # ... rest of validation logic</code></pre>

<h3>5. UI Error Display</h3>
<pre><code># src/ui/helpers/error_display.py
import streamlit as st
from exceptions.base import DefinitieAppException, ErrorCode

def display_error(error: Exception) -&gt; None:
    """Display error in UI with appropriate formatting."""
    if isinstance(error, DefinitieAppException):
        # Application error - show user message
        st.error(f"‚ö†Ô∏è {error.user_message}")

        # Show details in expander for technical users
        if st.checkbox("Toon technische details"):
            st.json(error.to_dict())

        # Suggest actions based on error code
        if error.code == ErrorCode.RATE_LIMIT_EXCEEDED:
            st.info("üí° Probeer het over enkele minuten opnieuw")
        elif error.code == ErrorCode.SERVICE_UNAVAILABLE:
            st.info("üí° De service is tijdelijk niet beschikbaar")

    else:
        # Unexpected error - generic message
        st.error("‚ùå Er is een onverwachte fout opgetreden")
        if st.checkbox("Toon error details"):
            st.exception(error)

def safe_operation(operation: Callable, error_container=None) -&gt; Any:
    """Execute operation with UI error handling."""
    try:
        return operation()
    except Exception as e:
        if error_container:
            with error_container:
                display_error(e)
        else:
            display_error(e)
        return None</code></pre>

<h2>Migration Strategy</h2>

<h3>Phase 1: Define Exception Hierarchy (Day 1)</h3>
<ul>
<li>Create exception classes</li>
<li>Define error codes</li>
<li>Document patterns</li>
</ul>

<h3>Phase 2: Critical Services (Day 2-3)</h3>
<ul>
<li>Update validation services</li>
<li>Update generation services</li>
<li>Update data access layer</li>
</ul>

<h3>Phase 3: UI Layer (Day 4)</h3>
<ul>
<li>Implement error display helper</li>
<li>Update all UI components</li>
<li>Add user-friendly messages</li>
</ul>

<h3>Phase 4: Cleanup (Day 5)</h3>
<ul>
<li>Remove bare except clauses</li>
<li>Add missing error context</li>
<li>Update tests</li>
</ul>

<h2>Test Plan</h2>

<pre><code># tests/unit/test_error_handling.py
def test_exception_hierarchy():
    """Test exception inheritance and properties."""
    exc = ValidationException(
        "Test error",
        details={"field": "test"},
        user_message="User friendly message"
    )
    assert exc.code == ErrorCode.VALIDATION_FAILED
    assert exc.user_message == "User friendly message"
    assert exc.details["field"] == "test"

def test_error_handler_decorator():
    """Test error handling decorator."""
    @handle_errors(
        (ValueError, ErrorCode.INVALID_INPUT, "Invalid input")
    )
    def failing_function():
        raise ValueError("Test error")

    with pytest.raises(DefinitieAppException) as exc_info:
        failing_function()

    assert exc_info.value.code == ErrorCode.INVALID_INPUT

def test_error_context_manager():
    """Test error context preservation."""
    with pytest.raises(DefinitieAppException) as exc_info:
        with error_context("test_operation", user_id=123):
            raise ValueError("Test error")

    assert exc_info.value.details["user_id"] == 123</code></pre>

<h2>Metrics</h2>

<h3>Before</h3>
<ul>
<li>Bare except clauses: 50+</li>
<li>Inconsistent error messages: Yes</li>
<li>Lost error context: Common</li>
<li>User-unfriendly errors: 80%</li>
</ul>

<h3>After</h3>
<ul>
<li>Bare except clauses: 0</li>
<li>Consistent error patterns: Yes</li>
<li>Full error context: Always</li>
<li>User-friendly errors: 100%</li>
</ul>

<h2>Dependencies</h2>
<ul>
<li>Python 3.11+ (for exception groups)</li>
<li>logging module</li>
<li>Optional: sentry-sdk for error monitoring</li>
</ul>

<h2>Notities</h2>
<ul>
<li>P3-16 uit US-193 multi-agent review</li>
<li>Coordinate met ops voor error monitoring</li>
<li>Consider structured logging integration</li>
<li>Update CLAUDE.md met error patterns</li>
</ul>

<h2>Links</h2>
<ul>
<li>[Python Exception Best Practices](https://docs.python.org/3/tutorial/errors.html)</li>
<li>[Error Handling Patterns](https://www.python.org/dev/peps/pep-3134/)</li>
<li>Parent: US-193</li>
</ul>
  </div>
</body>
</html>