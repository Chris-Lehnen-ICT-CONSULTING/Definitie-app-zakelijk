<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DEF-138: UNIQUE INDEX Removal Impact Analysis</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <h1>DEF-138: UNIQUE INDEX Removal Impact Analysis</h1>

<p><strong>Date:</strong> 2025-11-10</p>
<p><strong>Issue:</strong> User unable to generate new definition for existing term</p>
<p><strong>Error:</strong> <code>UNIQUE constraint failed: definities.begrip, definities.organisatorische_context, ...</code></p>
<p><strong>Scope:</strong> Database schema modification + application behavior change</p>

<p>---</p>

<h2>Executive Summary</h2>

<h3>Problem Statement</h3>
<p>The application currently blocks users from creating a NEW definition for an existing term (e.g., "werkwoord") in the same context, even when the intent is legitimate versioning or alternative definitions.</p>

<h3>Root Cause</h3>
<p><strong>Migration 008</strong> (<code>src/database/migrations/008_add_unique_constraint.sql</code>) enforces a 5-field UNIQUE INDEX:</p>
<pre><code>CREATE UNIQUE INDEX idx_definities_unique_full
ON definities(begrip, organisatorische_context, juridische_context, wettelijke_basis, categorie)
WHERE status != 'archived';</code></pre>

<p>This prevents multiple active definitions with identical context, which <strong>contradicts</strong> the versioning system designed into the schema.</p>

<h3>Recommended Solution</h3>
<p><strong>REMOVE the UNIQUE INDEX</strong> - it is:</p>
<ol>
<li>**Ontologically incorrect** (same term CAN have different meanings in same context over time)</li>
<li>**Incompatible with versioning system** (`version_number`, `previous_version_id` fields exist but are blocked)</li>
<li>**Redundant** - Python-level duplicate detection in `definitie_checker.py` already handles this intelligently</li>
</ol>

<p><strong>Safety:</strong> The removal is <strong>LOW RISK</strong> because duplicate prevention is already handled at the application level.</p>

<p>---</p>

<h2>Part 1: Root Cause Analysis</h2>

<h3>1.1 When Was the UNIQUE INDEX Added?</h3>

<p><strong>Migration 008</strong> (2025-10-31, DEF-87) added this constraint:</p>

<pre><code>-- Migration 008: Add UNIQUE constraint for duplicate prevention (DEF-87)
-- Date: 2025-10-31
-- Rationale: Prevents duplicate entries after import strategy cleanup
CREATE UNIQUE INDEX IF NOT EXISTS idx_definities_unique_full
ON definities(
    begrip,
    organisatorische_context,
    juridische_context,
    wettelijke_basis,
    categorie
)
WHERE status != 'archived';</code></pre>

<p><strong>Why it was added:</strong></p>
<ul>
<li>To prevent duplicates after the "import strategy" (temporary duplicate allowance)</li>
<li>Assumed business rule: "same 5-field combination = duplicate"</li>
<li>**Did NOT consider** versioning use case</li>
</ul>

<p><strong>Schema comment confirms temporary nature:</strong></p>
<p>Line 81 in <code>schema.sql</code>:</p>
<pre><code>-- (UNIQUE constraint tijdelijk uitgeschakeld i.v.m. importstrategie)</code></pre>
<p>Translation: "UNIQUE constraint temporarily disabled for import strategy"</p>

<h3>1.2 Ontological Contradiction</h3>

<p>The schema has <strong>versioning fields</strong> designed for exactly the scenario that the UNIQUE INDEX prevents:</p>

<pre><code>-- Versioning
version_number INTEGER NOT NULL DEFAULT 1,
previous_version_id INTEGER REFERENCES definities(id),</code></pre>

<p><strong>Intent:</strong> Same term can have multiple versions with identical context.</p>

<p><strong>Example:</strong></p>
<ul>
<li>Version 1: "werkwoord" (begrip) + "test" (context) → Draft definition A</li>
<li>Version 2: "werkwoord" (begrip) + "test" (context) → Improved definition B (previous_version_id → V1)</li>
</ul>

<p><strong>Current state:</strong> UNIQUE INDEX <strong>BLOCKS</strong> this entirely.</p>

<h3>1.3 Current Database State</h3>

<p>Query result shows one existing definition:</p>
<pre><code>id=127 | begrip=werkwoord | categorie=proces | context=["test"] | status=draft | version=1</code></pre>

<p>User wants to generate a <strong>NEW</strong> definition (not update existing) → <strong>BLOCKED by UNIQUE INDEX</strong>.</p>

<p>---</p>

<h2>Part 2: Impact Assessment</h2>

<h3>2.1 Database-Level Dependencies</h3>

<h4>UNIQUE INDEX Structure</h4>
<pre><code>Index: idx_definities_unique_full
Columns: (begrip, organisatorische_context, juridische_context, wettelijke_basis, categorie)
Filter: WHERE status != 'archived'</code></pre>

<p><strong>What it enforces:</strong></p>
<ul>
<li>Only ONE active (non-archived) definition per 5-field combination</li>
<li>Multiple archived definitions ARE allowed (excluded by WHERE clause)</li>
</ul>

<h4>Foreign Key Dependencies</h4>
<p><strong>NONE</strong> - This is just an index, no FK references to it.</p>

<h4>Trigger Dependencies</h4>
<p><strong>NONE</strong> - No triggers depend on uniqueness guarantee.</p>

<h4>View Dependencies</h4>
<p>Views (<code>actieve_definities</code>, <code>vastgestelde_definities</code>) do NOT rely on uniqueness - they simply filter and order.</p>

<h3>2.2 Application-Level Dependencies</h3>

<h4>Python Code Relying on UNIQUE Constraint</h4>

<p><strong>CRITICAL FINDING:</strong> Application code does NOT rely on database-level uniqueness!</p>

<p><strong>Evidence:</strong></p>

<p><strong>A. Duplicate Detection in <code>definitie_repository.py</code> (lines 532-572)</strong></p>
<pre><code>def create_definitie(self, record: DefinitieRecord, allow_duplicate: bool = False) -&gt; int:
    """Maak nieuwe definitie aan."""
    try:
        with self._get_connection() as conn:
            # Check voor duplicates: permit indien expliciet toegestaan
            if not allow_duplicate:
                duplicates = self.find_duplicates(
                    record.begrip,
                    record.organisatorische_context,
                    record.juridische_context or "",
                    categorie=record.categorie,
                    wettelijke_basis=(
                        json.loads(record.wettelijke_basis)
                        if record.wettelijke_basis
                        else []
                    ),
                )
                if duplicates and any(
                    d.definitie_record.status != DefinitieStatus.ARCHIVED.value
                    for d in duplicates
                ):
                    msg = f"Definitie voor '{record.begrip}' bestaat al in deze context"
                    raise ValueError(msg)</code></pre>

<p><strong>Finding:</strong> Python code <strong>ALREADY</strong> checks for duplicates and raises <code>ValueError</code> <strong>BEFORE</strong> database INSERT.</p>

<p><strong>B. Duplicate Check in <code>definitie_checker.py</code> (lines 95-181)</strong></p>
<pre><code>def check_before_generation(
    self,
    begrip: str,
    organisatorische_context: str,
    juridische_context: str = "",
    categorie: OntologischeCategorie = OntologischeCategorie.TYPE,
    wettelijke_basis: list[str] | None = None,
) -&gt; DefinitieCheckResult:
    """Check voor bestaande definities voordat generatie start."""

    # Zoek exact match - inclusief categorie
    existing = self.repository.find_definitie(...)
    if existing:
        return self._handle_exact_match(existing, search_term=begrip)

    # Zoek duplicates/fuzzy matches
    duplicates = self.repository.find_duplicates(...)
    if duplicates:
        return self._handle_duplicates(duplicates)</code></pre>

<p><strong>Finding:</strong> Application-level duplicate detection is <strong>MORE SOPHISTICATED</strong> than database constraint:</p>
<ul>
<li>Handles fuzzy matches (70% similarity threshold)</li>
<li>Provides user choice for similar entries</li>
<li>Supports `force_generate` flag for intentional duplicates</li>
<li>Includes synonym detection</li>
</ul>

<p><strong>C. <code>allow_duplicate</code> Flag Support</strong></p>

<p><strong><code>definition_repository.py</code> (line 104):</strong></p>
<pre><code>result_id = self.legacy_repo.create_definitie(
    record, allow_duplicate=allow_duplicate
)</code></pre>

<p><strong><code>definition_import_service.py</code> (line 92):</strong></p>
<pre><code>def import_single(
    self,
    payload: dict[str, Any],
    *,
    allow_duplicate: bool = False,
    duplicate_strategy: str | None = None,
    created_by: str | None = None,
) -&gt; SingleImportResult:</code></pre>

<p><strong>Finding:</strong> Application <strong>already has infrastructure</strong> to allow duplicates when needed.</p>

<h3>2.3 IntegrityError Handling</h3>

<p><strong>SEARCH RESULT:</strong> Only 18 files mention <code>IntegrityError</code>, mostly in:</p>
<ul>
<li>Test files (expected)</li>
<li>Service layer (defensive error handling)</li>
<li>**NOT** in business logic flow</li>
</ul>

<p><strong>Conclusion:</strong> No critical business logic depends on catching <code>IntegrityError</code> for duplicate detection.</p>

<p>---</p>

<h2>Part 3: Business Logic Impact</h2>

<h3>3.1 Versioning System Compatibility</h3>

<p><strong>Schema design includes versioning:</strong></p>
<pre><code>version_number INTEGER NOT NULL DEFAULT 1,
previous_version_id INTEGER REFERENCES definities(id),</code></pre>

<p><strong>Versioning workflow (intended but currently blocked):</strong></p>

<pre><code>Step 1: Create initial definition
  → begrip="werkwoord", context="test", version=1

Step 2: Generate improved version (CURRENTLY FAILS)
  → begrip="werkwoord", context="test", version=2, previous_version_id=127

  ERROR: UNIQUE constraint violation!</code></pre>

<p><strong>Without UNIQUE INDEX:</strong></p>
<pre><code>Step 2 would succeed:
  → New record created with version=2
  → previous_version_id links to version 1
  → Both records coexist (version history preserved)</code></pre>

<p><strong>Status Workflow:</strong></p>
<pre><code>Draft (v1) → Review (v2) → Established (v3)
   ↓            ↓              ↓
 Edit again  Improve      New regulation
   ↓            ↓              ↓
New version  New version  New version</code></pre>

<p><strong>Current UNIQUE INDEX blocks all version creation workflows.</strong></p>

<h3>3.2 Legitimate Use Cases Being Blocked</h3>

<p><strong>Use Case 1: Iterative Improvement</strong></p>
<ul>
<li>User generates definition A</li>
<li>Not satisfied → wants to generate NEW definition B (not edit A)</li>
<li>Compare A vs B side-by-side</li>
<li>Choose better one</li>
<li>**BLOCKED:** Cannot generate B</li>
</ul>

<p><strong>Use Case 2: Regulatory Updates</strong></p>
<ul>
<li>Law changes → definition must be updated</li>
<li>Keep old version for historical reference (status=archived)</li>
<li>Create new version (version_number=2, previous_version_id → old)</li>
<li>**BLOCKED:** Cannot create new version while old is active</li>
</ul>

<p><strong>Use Case 3: Context Evolution</strong></p>
<ul>
<li>Same term gains additional meaning over time</li>
<li>Want to document both definitions</li>
<li>Link via previous_version_id</li>
<li>**BLOCKED:** Cannot create second definition</li>
</ul>

<p><strong>Use Case 4: Import + Manual Refinement</strong></p>
<ul>
<li>Import external definition (source_type='imported')</li>
<li>User wants to generate improved version (source_type='generated')</li>
<li>**BLOCKED:** Cannot have both</li>
</ul>

<h3>3.3 Python-Level Duplicate Detection</h3>

<p><strong>Intelligence NOT replicated in database constraint:</strong></p>

<p><strong>A. Fuzzy Matching</strong></p>
<pre><code># definitie_repository.py lines 858-897
if not matches:
    fuzzy_query = """
        SELECT * FROM definities
        WHERE begrip LIKE ? AND organisatorische_context = ?
        AND status != 'archived'
    """
    # ...
    similarity = self._calculate_similarity(begrip, record.begrip)
    if similarity &gt; 0.7:  # 70% threshold
        matches.append(DuplicateMatch(...))</code></pre>

<p><strong>Database UNIQUE INDEX:</strong> Cannot do fuzzy matching.</p>

<p><strong>B. Synonym Detection</strong></p>
<pre><code># definitie_repository.py lines 702-748
# Geen directe begrip-hit: probeer exacte synoniem‑match (case-insensitive)
syn_query = """
    SELECT d.*
    FROM definities d
    JOIN definitie_voorbeelden v ON v.definitie_id = d.id
    WHERE LOWER(v.voorbeeld_tekst) = LOWER(?)
      AND v.voorbeeld_type = 'synonyms'
      AND v.actief = TRUE
      AND d.organisatorische_context = ?
"""</code></pre>

<p><strong>Database UNIQUE INDEX:</strong> Cannot detect synonyms.</p>

<p><strong>C. User Choice Handling</strong></p>
<pre><code># definitie_checker.py lines 502-528
def _handle_duplicates(self, duplicates: list[DuplicateMatch]) -&gt; DefinitieCheckResult:
    best_match = duplicates[0]
    if best_match.match_score &gt; 0.9:
        return DefinitieCheckResult(
            action=CheckAction.USER_CHOICE,  # Let user decide!
            existing_definitie=best_match.definitie_record,
            duplicates=duplicates,
            message=f"Zeer vergelijkbare definitie gevonden...",
        )</code></pre>

<p><strong>Database UNIQUE INDEX:</strong> Hard failure, no user choice.</p>

<p>---</p>

<h2>Part 4: Safety Analysis</h2>

<h3>4.1 Data Corruption Risk</h3>

<p><strong>Question:</strong> Will removing the UNIQUE INDEX cause data corruption?</p>

<p><strong>Answer: NO</strong></p>

<p><strong>Reason:</strong></p>
<ol>
<li>**Python validation layer already prevents unintended duplicates** (lines 554-572 in `definitie_repository.py`)</li>
<li>**`allow_duplicate` flag provides explicit override** when versioning is intended</li>
<li>**Status field prevents logical conflicts:**</li>
</ol>
<ul>
<li>  - Only one 'established' definition should be active at a time (business rule, not database constraint)</li>
<li>  - Multiple 'draft' versions are semantically valid (work in progress)</li>
<li>  - 'archived' versions preserve history</li>
</ul>

<p><strong>Example of safe multi-version state:</strong></p>
<pre><code>ID=127 | begrip=werkwoord | context=test | status=draft     | version=1
ID=145 | begrip=werkwoord | context=test | status=review    | version=2 | prev=127
ID=163 | begrip=werkwoord | context=test | status=established | version=3 | prev=145</code></pre>

<p>This is <strong>VALID</strong> and represents definition evolution history.</p>

<h3>4.2 Performance Impact</h3>

<p><strong>Question:</strong> Will removing the index impact query performance?</p>

<p><strong>Answer: MINIMAL IMPACT</strong></p>

<p><strong>Current indexes remain:</strong></p>
<pre><code>CREATE INDEX idx_definities_begrip ON definities(begrip);
CREATE INDEX idx_definities_context ON definities(organisatorische_context, juridische_context);
CREATE INDEX idx_definities_status ON definities(status);
CREATE INDEX idx_definities_categorie ON definities(categorie);</code></pre>

<p><strong>Performance analysis:</strong></p>
<ul>
<li>**Duplicate check queries** use `idx_definities_begrip` + `idx_definities_context` → Fast</li>
<li>**UNIQUE INDEX was not used for SELECT queries** (only INSERT validation)</li>
<li>**Removing it only affects INSERT performance:**</li>
<li> - Before: Database checks uniqueness (~0.1ms)</li>
<li> - After: Python checks duplicates via SELECT query (~1-2ms)</li>
<li> - **Delta: ~1ms per insert** (negligible for single-user app)</li>
</ul>

<h3>4.3 Rollback Safety</h3>

<p><strong>Question:</strong> Can we safely rollback if removal causes issues?</p>

<p><strong>Answer: YES</strong></p>

<p><strong>Rollback procedure:</strong></p>
<pre><code>-- Check for duplicates created after removal
SELECT begrip, organisatorische_context, juridische_context,
       wettelijke_basis, categorie, COUNT(*)
FROM definities
WHERE status != 'archived'
GROUP BY begrip, organisatorische_context, juridische_context,
         wettelijke_basis, categorie
HAVING COUNT(*) &gt; 1;

-- If no duplicates, safely recreate index
CREATE UNIQUE INDEX idx_definities_unique_full
ON definities(
    begrip,
    organisatorische_context,
    juridische_context,
    wettelijke_basis,
    categorie
)
WHERE status != 'archived';</code></pre>

<p><strong>Worst case:</strong> If removal causes unintended duplicates:</p>
<ol>
<li>Identify duplicates (query above)</li>
<li>Merge or archive unwanted versions</li>
<li>Recreate index</li>
<li>Total downtime: < 5 minutes</li>
</ol>

<p>---</p>

<h2>Part 5: Alternative Solutions Considered</h2>

<h3>Alternative 1: Keep UNIQUE INDEX, Disable for Versioning</h3>

<p><strong>Approach:</strong> Add <code>version_number</code> to WHERE clause:</p>
<pre><code>CREATE UNIQUE INDEX idx_definities_unique_full
ON definities(begrip, organisatorische_context, juridische_context, wettelijke_basis, categorie)
WHERE status != 'archived' AND version_number = (
    SELECT MAX(version_number)
    FROM definities d2
    WHERE d2.begrip = definities.begrip
      AND d2.organisatorische_context = definities.organisatorische_context
);</code></pre>

<p><strong>Rejected because:</strong></p>
<ul>
<li>SQLite does not support correlated subqueries in partial index WHERE clause</li>
<li>Would require complex trigger-based enforcement</li>
<li>Adds unnecessary database complexity when Python handles it better</li>
</ul>

<h3>Alternative 2: Compound Key with Version</h3>

<p><strong>Approach:</strong> Make (begrip, context, version) unique instead of 5-field:</p>
<pre><code>CREATE UNIQUE INDEX idx_definities_unique_versioned
ON definities(begrip, organisatorische_context, version_number)
WHERE status != 'archived';</code></pre>

<p><strong>Rejected because:</strong></p>
<ul>
<li>Allows same definition (exact duplicate) with different version numbers → semantic error</li>
<li>Does not prevent accidental duplicates (user generates same def twice, gets v1 and v2 with identical content)</li>
<li>Python-level check is still needed → database constraint redundant</li>
</ul>

<h3>Alternative 3: Application-Level Lock</h3>

<p><strong>Approach:</strong> Use <code>allow_duplicate=False</code> (default) to prevent duplicates, require explicit flag for versioning.</p>

<p><strong>Assessment:</strong></p>
<ul>
<li>**Already implemented!** (see lines 532-572 in `definitie_repository.py`)</li>
<li>**More flexible than database constraint** (supports fuzzy matching, synonyms, user choice)</li>
<li>**UNIQUE INDEX is redundant** when this exists</li>
</ul>

<p><strong>This is the recommended solution: Remove database constraint, rely on existing Python validation.</strong></p>

<p>---</p>

<h2>Part 6: Migration Strategy</h2>

<h3>6.1 Removal Steps</h3>

<p><strong>Migration Script:</strong></p>
<pre><code>-- Migration 009: Remove ontological contradiction (DEF-138)
-- Author: System
-- Date: 2025-11-10
-- Description: Remove UNIQUE INDEX that blocks versioning system
--
-- Rationale:
--   - Schema has version_number + previous_version_id for version history
--   - UNIQUE INDEX prevents multiple active versions (contradiction)
--   - Python duplicate detection (definitie_checker.py) is more intelligent
--   - Supports fuzzy matching, synonyms, user choice
--
-- Safety: Application-level validation prevents unintended duplicates
-- Rollback: Recreate index if no duplicates exist (see rollback.sql)

DROP INDEX IF EXISTS idx_definities_unique_full;

-- Verification: Check for any duplicates that may have existed
-- (Should return 0 rows if migration 008 was successful)
SELECT
    begrip,
    organisatorische_context,
    juridische_context,
    wettelijke_basis,
    categorie,
    COUNT(*) as count
FROM definities
WHERE status != 'archived'
GROUP BY begrip, organisatorische_context, juridische_context, wettelijke_basis, categorie
HAVING COUNT(*) &gt; 1;</code></pre>

<p><strong>Rollback Script (009_rollback.sql):</strong></p>
<pre><code>-- Rollback for migration 009
-- Only run if duplicate prevention is needed at database level again

-- Step 1: Verify no duplicates exist
SELECT
    begrip,
    organisatorische_context,
    COUNT(*) as count
FROM definities
WHERE status != 'archived'
GROUP BY begrip, organisatorische_context, juridische_context, wettelijke_basis, categorie
HAVING COUNT(*) &gt; 1;

-- Step 2: If above returns 0 rows, safe to recreate index
CREATE UNIQUE INDEX idx_definities_unique_full
ON definities(
    begrip,
    organisatorische_context,
    juridische_context,
    wettelijke_basis,
    categorie
)
WHERE status != 'archived';</code></pre>

<h3>6.2 Testing Plan</h3>

<p><strong>Pre-Migration Tests:</strong></p>
<pre><code># tests/database/test_migration_009.py
def test_versioning_blocked_before_migration():
    """Verify UNIQUE INDEX currently blocks versioning."""
    repo = DefinitieRepository()

    # Create v1
    v1 = DefinitieRecord(
        begrip="werkwoord",
        definitie="definitie v1",
        categorie="proces",
        organisatorische_context="test",
        status="draft"
    )
    id1 = repo.create_definitie(v1)

    # Try to create v2 (should fail with IntegrityError)
    v2 = DefinitieRecord(
        begrip="werkwoord",
        definitie="definitie v2",  # Different content!
        categorie="proces",
        organisatorische_context="test",
        status="review",
        version_number=2,
        previous_version_id=id1
    )

    with pytest.raises(sqlite3.IntegrityError):
        repo.create_definitie(v2, allow_duplicate=True)</code></pre>

<p><strong>Post-Migration Tests:</strong></p>
<pre><code>def test_versioning_allowed_after_migration():
    """Verify versioning works after UNIQUE INDEX removal."""
    repo = DefinitieRepository()

    # Create v1
    v1 = DefinitieRecord(
        begrip="werkwoord",
        definitie="definitie v1",
        categorie="proces",
        organisatorische_context="test",
        status="draft"
    )
    id1 = repo.create_definitie(v1)

    # Create v2 (should succeed)
    v2 = DefinitieRecord(
        begrip="werkwoord",
        definitie="definitie v2 (improved)",
        categorie="proces",
        organisatorische_context="test",
        status="review",
        version_number=2,
        previous_version_id=id1
    )
    id2 = repo.create_definitie(v2, allow_duplicate=True)

    assert id2 &gt; 0
    assert id2 != id1

    # Verify both exist
    retrieved_v1 = repo.get_definitie(id1)
    retrieved_v2 = repo.get_definitie(id2)

    assert retrieved_v2.previous_version_id == id1
    assert retrieved_v2.version_number == 2

def test_duplicate_prevention_still_works():
    """Verify Python-level duplicate detection still prevents accidental duplicates."""
    repo = DefinitieRepository()

    # Create first definition
    d1 = DefinitieRecord(
        begrip="test_begrip",
        definitie="definitie 1",
        categorie="proces",
        organisatorische_context="test",
        status="draft"
    )
    repo.create_definitie(d1)

    # Try to create exact duplicate (should raise ValueError, not IntegrityError)
    d2 = DefinitieRecord(
        begrip="test_begrip",
        definitie="definitie 1",  # Same content
        categorie="proces",
        organisatorische_context="test",
        status="draft"
    )

    with pytest.raises(ValueError, match="bestaat al in deze context"):
        repo.create_definitie(d2)  # allow_duplicate=False (default)</code></pre>

<h3>6.3 Deployment Checklist</h3>

<ul>
<li>[ ] **Backup database** before migration</li>
<pre><code>  cp data/definities.db data/definities.db.backup_before_009</code></pre>
</ul>

<ul>
<li>[ ] **Run migration script**</li>
<pre><code>  sqlite3 data/definities.db &lt; src/database/migrations/009_remove_unique_index.sql</code></pre>
</ul>

<ul>
<li>[ ] **Verify index removal**</li>
<pre><code>  sqlite3 data/definities.db ".indices definities"
  # Should NOT show idx_definities_unique_full</code></pre>
</ul>

<ul>
<li>[ ] **Run post-migration tests**</li>
<pre><code>  pytest tests/database/test_migration_009.py -v</code></pre>
</ul>

<ul>
<li>[ ] **Test user scenario** (manual)</li>
<li> - Generate definition for "werkwoord" + "test" context</li>
<li> - Should succeed (previously failed)</li>
<li> - Verify duplicate check still prompts user</li>
</ul>

<ul>
<li>[ ] **Monitor for 24h** for any unintended duplicates</li>
<pre><code>  -- Run daily for first week
  SELECT begrip, COUNT(*)
  FROM definities
  WHERE status != 'archived'
  GROUP BY begrip, organisatorische_context, juridische_context, wettelijke_basis, categorie
  HAVING COUNT(*) &gt; 1;</code></pre>
</ul>

<p>---</p>

<h2>Part 7: Recommendations</h2>

<h3>7.1 Immediate Actions (DEF-138)</h3>

<p><strong>RECOMMENDATION: REMOVE UNIQUE INDEX</strong></p>

<p><strong>Rationale:</strong></p>
<ol>
<li>**Contradicts versioning system** built into schema</li>
<li>**Blocks legitimate use cases** (iterative improvement, regulatory updates)</li>
<li>**Redundant** - Python validation is more sophisticated</li>
<li>**Low risk** - Application layer already prevents unintended duplicates</li>
<li>**Easily reversible** if issues arise</li>
</ol>

<p><strong>Implementation:</strong></p>
<ul>
<li>Create migration 009 (DROP INDEX)</li>
<li>Add comprehensive tests (versioning, duplicate prevention)</li>
<li>Deploy with monitoring</li>
</ul>

<h3>7.2 Documentation Updates</h3>

<p><strong>Update <code>schema.sql</code> line 81:</strong></p>
<pre><code>-- OLD:
-- (UNIQUE constraint tijdelijk uitgeschakeld i.v.m. importstrategie)

-- NEW:
-- UNIQUE INDEX removed (Migration 009, DEF-138): Versioning system requires
-- multiple active definitions with same context. Duplicate prevention handled
-- by application layer (definitie_checker.py, definitie_repository.py).</code></pre>

<p><strong>Add comment to <code>definitie_repository.py</code> (line 532):</strong></p>
<pre><code>def create_definitie(self, record: DefinitieRecord, allow_duplicate: bool = False) -&gt; int:
    """Maak nieuwe definitie aan.

    Duplicate Prevention Strategy (DEF-138):
    - Database-level UNIQUE INDEX removed to support versioning
    - Application-level validation (this method) prevents unintended duplicates
    - Use allow_duplicate=True for intentional versioning
    - Supports fuzzy matching, synonyms, user choice (see definitie_checker.py)

    Args:
        record: DefinitieRecord object
        allow_duplicate: Allow duplicate when versioning (default: False)
    """</code></pre>

<h3>7.3 Future Enhancements</h3>

<p><strong>Consider (separate from DEF-138):</strong></p>

<p><strong>A. Explicit Versioning API</strong></p>
<pre><code># definitie_repository.py
def create_new_version(
    self,
    base_definitie_id: int,
    new_definitie: str,
    created_by: str,
) -&gt; int:
    """Create new version of existing definition.

    Automatically:
    - Increments version_number
    - Sets previous_version_id
    - Preserves context fields
    """
    base = self.get_definitie(base_definitie_id)
    new_record = DefinitieRecord(
        begrip=base.begrip,
        definitie=new_definitie,
        categorie=base.categorie,
        organisatorische_context=base.organisatorische_context,
        juridische_context=base.juridische_context,
        wettelijke_basis=base.wettelijke_basis,
        version_number=base.version_number + 1,
        previous_version_id=base_definitie_id,
        created_by=created_by,
    )
    return self.create_definitie(new_record, allow_duplicate=True)</code></pre>

<p><strong>B. Version History View</strong></p>
<pre><code>CREATE VIEW definitie_version_history AS
SELECT
    d1.id,
    d1.begrip,
    d1.version_number,
    d1.previous_version_id,
    d2.version_number as previous_version,
    d1.status,
    d1.created_at
FROM definities d1
LEFT JOIN definities d2 ON d1.previous_version_id = d2.id
ORDER BY d1.begrip, d1.version_number DESC;</code></pre>

<p><strong>C. Status Transition Validation</strong></p>
<pre><code># Only allow ONE 'established' definition per (begrip, context) combination
def validate_status_transition(record: DefinitieRecord, new_status: str):
    if new_status == 'established':
        existing_established = self.find_definitie(
            begrip=record.begrip,
            organisatorische_context=record.organisatorische_context,
            status=DefinitieStatus.ESTABLISHED
        )
        if existing_established and existing_established.id != record.id:
            raise ValueError(
                "Er bestaat al een vastgestelde definitie. "
                "Archiveer de oude versie eerst."
            )</code></pre>

<p>---</p>

<h2>Conclusion</h2>

<p><strong>SAFE TO REMOVE:</strong> The UNIQUE INDEX <code>idx_definities_unique_full</code> should be removed because:</p>

<ol>
<li>**Business Need:** Versioning system requires multiple active definitions</li>
<li>**Technical Safety:** Application-level validation prevents unintended duplicates</li>
<li>**Low Risk:** Easily reversible, comprehensive tests available</li>
<li>**Immediate Benefit:** Unblocks user's legitimate use case</li>
</ol>

<p><strong>Migration 009 is recommended for immediate deployment.</strong></p>

  </div>
</body>
</html>