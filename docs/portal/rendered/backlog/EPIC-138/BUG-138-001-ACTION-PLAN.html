<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BUG-138-001: False Positive Classifier Bug - Action Plan</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <h1>BUG-138-001: False Positive Classifier Bug - Action Plan</h1>

<p><strong>Priority:</strong> CRITICAL</p>
<p><strong>Impact:</strong> USER-FACING - Incorrect classifications for compound words</p>
<p><strong>Estimated Fix Time:</strong> 2-3 hours</p>
<p><strong>Status:</strong> READY FOR IMPLEMENTATION</p>

<p>---</p>

<h2>Problem Summary</h2>

<p>The new compound word patterns added in DEF-138 cause false positives:</p>

<pre><code># config/classification/term_patterns.yaml
TYPE:
  woord: 0.70  # Matches "woordvoerder" (wrong!)
  naam: 0.65   # Matches "naamsverminking" (wrong!)
  boek: 0.70   # Matches "boekhouding" (wrong!)</code></pre>

<p><strong>Examples of False Positives:</strong></p>
<ul>
<li>`woordvoerder` (spokesperson) → TYPE (should be PROCES)</li>
<li>`naamsverminking` (slander) → TYPE (should be PROCES)</li>
<li>`woordbreuk` (breaking word) → TYPE (should be PROCES/RESULTAAT)</li>
</ul>

<p><strong>Root Cause:</strong></p>
<p>Pattern matching in <code>improved_classifier.py:239</code> applies full weight to ANY word ending in suffix, without semantic validation.</p>

<p>---</p>

<h2>Solution Options</h2>

<h3>Option A: Add Exclusion Patterns (RECOMMENDED)</h3>

<p><strong>Pros:</strong></p>
<ul>
<li>Explicit control over edge cases</li>
<li>Easy to maintain and understand</li>
<li>No performance impact</li>
</ul>

<p><strong>Cons:</strong></p>
<ul>
<li>Requires maintaining exclusion list</li>
<li>Reactive (add exclusions as we find them)</li>
</ul>

<p><strong>Implementation:</strong></p>
<ol>
<li>Extend YAML schema to support exclusions:</li>
<pre><code>   TYPE:
     woord:
       weight: 0.70
       exclusions:
         - "woordvoerder"   # spokesperson = PROCES
         - "woordbreuk"     # breaking word = PROCES
         - "voorwoord"      # preface = TYPE (but contextual)</code></pre>
</ol>

<ol>
<li>Update `TermPatternConfig` dataclass:</li>
<pre><code>   @dataclass
   class SuffixPattern:
       weight: float
       exclusions: list[str] = field(default_factory=list)

   @dataclass
   class TermPatternConfig:
       suffix_weights: dict[str, dict[str, SuffixPattern | float]]  # Support both formats</code></pre>
</ol>

<ol>
<li>Update pattern matching in `improved_classifier.py`:</li>
<pre><code>   for suffix, pattern_data in suffix_weights.items():
       # Handle both old format (float) and new format (SuffixPattern)
       if isinstance(pattern_data, dict):
           weight = pattern_data.get("weight", 0.4)
           exclusions = pattern_data.get("exclusions", [])
       else:
           weight = pattern_data
           exclusions = []

       if begrip_lower in exclusions:
           continue  # Skip this pattern

       if begrip_lower.endswith(suffix):
           pattern_score += weight</code></pre>
</ol>

<p><strong>Estimated Time:</strong> 2 hours</p>

<p>---</p>

<h3>Option B: Lower Weights</h3>

<p><strong>Pros:</strong></p>
<ul>
<li>Quick fix (5 minutes)</li>
<li>No schema changes</li>
</ul>

<p><strong>Cons:</strong></p>
<ul>
<li>Might break correct classifications</li>
<li>Doesn't address root cause</li>
<li>Requires empirical tuning</li>
</ul>

<p><strong>Implementation:</strong></p>
<pre><code>TYPE:
  woord: 0.40  # Lowered from 0.70
  naam: 0.35   # Lowered from 0.65
  boek: 0.40   # Lowered from 0.70</code></pre>

<p><strong>Risk:</strong> Could cause TRUE positives (werkwoord, bijwoord) to lose to PROCES patterns.</p>

<p><strong>Estimated Time:</strong> 30 minutes + extensive testing</p>

<p>---</p>

<h3>Option C: Semantic Validation Layer</h3>

<p><strong>Pros:</strong></p>
<ul>
<li>Most robust solution</li>
<li>Handles future edge cases automatically</li>
<li>No manual exclusion list</li>
</ul>

<p><strong>Cons:</strong></p>
<ul>
<li>Complex implementation</li>
<li>Requires NLP/semantic analysis</li>
<li>Higher computational cost</li>
<li>Longer development time</li>
</ul>

<p><strong>Implementation:</strong></p>
<pre><code>def _is_linguistic_term(self, begrip: str) -&gt; bool:
    """Check if compound word is actual linguistic term (werkwoord, bijwoord) vs semantic compound."""
    # Use external dictionary or rule-based system
    linguistic_terms = {"werkwoord", "bijwoord", "voornaamwoord", "lidwoord", "handboek", "wetboek"}
    return begrip.lower() in linguistic_terms

def _check_suffix_with_semantics(self, begrip_lower: str, suffix: str, weight: float) -&gt; float:
    """Apply suffix match with semantic validation."""
    if begrip_lower.endswith(suffix):
        # Check if this is a linguistic term vs semantic compound
        if suffix in ["woord", "naam", "boek"]:
            if not self._is_linguistic_term(begrip_lower):
                # Semantic compound → reduce weight
                return weight * 0.3
        return weight  # Full weight for linguistic terms
    return 0.0</code></pre>

<p><strong>Estimated Time:</strong> 4-6 hours (research + implement + test)</p>

<p>---</p>

<h2>Recommended Implementation: OPTION A (Exclusion Patterns)</h2>

<h3>Step 1: Extend YAML Schema (30 min)</h3>

<p><strong>Before:</strong></p>
<pre><code>TYPE:
  woord: 0.70
  naam: 0.65</code></pre>

<p><strong>After:</strong></p>
<pre><code>TYPE:
  woord:
    weight: 0.70
    exclusions:
      - "woordvoerder"   # spokesperson = PROCES
      - "woordbreuk"     # breaking word = PROCES
  naam:
    weight: 0.65
    exclusions:
      - "naamsverminking"  # slander = PROCES
      - "naamgeving"       # naming = PROCES
  lijst: 0.65  # Keep simple format for patterns without exclusions
  boek:
    weight: 0.70
    exclusions:
      - "boekhouding"      # accounting = PROCES (context override wins anyway)</code></pre>

<p><strong>Migration:</strong> Support both formats (backward compatible).</p>

<p>---</p>

<h3>Step 2: Update TermPatternConfig (30 min)</h3>

<pre><code># src/services/classification/term_config.py

from typing import Union

@dataclass
class SuffixPattern:
    """Pattern with weight and optional exclusions."""
    weight: float
    exclusions: list[str] = field(default_factory=list)

@dataclass
class TermPatternConfig:
    """Config with support for complex suffix patterns."""
    domain_overrides: dict[str, str]
    suffix_weights: dict[str, dict[str, Union[float, dict]]]  # float or {weight, exclusions}
    category_priority: list[str]
    confidence_thresholds: dict[str, float]

    def get_suffix_data(self, category: str, suffix: str) -&gt; tuple[float, list[str]]:
        """Extract weight and exclusions from config.

        Returns:
            Tuple of (weight, exclusions_list)
        """
        pattern_data = self.suffix_weights.get(category, {}).get(suffix)

        if pattern_data is None:
            return 0.0, []

        if isinstance(pattern_data, (int, float)):
            # Simple format: just a weight
            return float(pattern_data), []

        if isinstance(pattern_data, dict):
            # Complex format: {weight, exclusions}
            weight = pattern_data.get("weight", 0.0)
            exclusions = pattern_data.get("exclusions", [])
            return weight, exclusions

        raise ValueError(f"Invalid suffix pattern format for {category}/{suffix}: {pattern_data}")</code></pre>

<p>---</p>

<h3>Step 3: Update Pattern Matching Logic (30 min)</h3>

<pre><code># src/ontologie/improved_classifier.py:230-245

# BEFORE
for suffix in patterns["suffixes"]:
    weight = suffix_weights.get(suffix, 0.4)

    if begrip_lower.endswith(suffix):
        pattern_score += weight
    elif suffix in begrip_lower:
        pattern_score += weight * 0.5

# AFTER
for suffix in patterns["suffixes"]:
    # Get weight and exclusions from config
    weight, exclusions = self.config.get_suffix_data(category_upper, suffix)

    # Check exclusions FIRST
    if begrip_lower in exclusions:
        logger.debug(f"Skipping pattern '{suffix}' for '{begrip_lower}' (excluded)")
        continue  # Skip this pattern entirely

    if begrip_lower.endswith(suffix):
        pattern_score += weight
    elif suffix in begrip_lower:
        pattern_score += weight * 0.5</code></pre>

<p>---</p>

<h3>Step 4: Add Tests (30 min)</h3>

<pre><code># tests/ontologie/test_classifier_exclusions.py

import pytest
from ontologie.improved_classifier import ImprovedOntologyClassifier
from domain.ontological_categories import OntologischeCategorie


def test_woord_suffix_exclusions():
    """DEF-138: Test that exclusions prevent false positives for -woord pattern."""
    classifier = ImprovedOntologyClassifier()

    # TRUE POSITIVES (should be TYPE)
    result = classifier.classify("werkwoord")
    assert result.categorie == OntologischeCategorie.TYPE
    assert result.confidence &gt;= 0.70  # High confidence

    result = classifier.classify("bijwoord")
    assert result.categorie == OntologischeCategorie.TYPE

    # FALSE POSITIVES (excluded, should NOT be TYPE)
    result = classifier.classify("woordvoerder")
    assert result.categorie == OntologischeCategorie.PROCES
    assert "woordvoerder" not in result.reasoning  # Pattern should not have matched

    result = classifier.classify("woordbreuk")
    assert result.categorie != OntologischeCategorie.TYPE


def test_naam_suffix_exclusions():
    """DEF-138: Test that exclusions prevent false positives for -naam pattern."""
    classifier = ImprovedOntologyClassifier()

    # TRUE POSITIVES (should be TYPE)
    result = classifier.classify("voornaam")
    assert result.categorie == OntologischeCategorie.TYPE

    # FALSE POSITIVES (excluded, should NOT be TYPE)
    result = classifier.classify("naamsverminking")
    assert result.categorie == OntologischeCategorie.PROCES

    result = classifier.classify("naamgeving")
    assert result.categorie == OntologischeCategorie.PROCES


def test_exclusion_list_validation():
    """Ensure exclusion list only contains lowercase terms."""
    from services.classification.term_config import load_term_config

    config = load_term_config()

    for category, patterns in config.suffix_weights.items():
        for suffix, pattern_data in patterns.items():
            if isinstance(pattern_data, dict):
                exclusions = pattern_data.get("exclusions", [])
                for term in exclusions:
                    assert term == term.lower(), f"Exclusion '{term}' must be lowercase"</code></pre>

<p>---</p>

<h3>Step 5: Documentation (15 min)</h3>

<p>Update <code>config/classification/term_patterns.yaml</code> with comments:</p>

<pre><code># ============================================================
# SUFFIX WEIGHTS - EXTENDED FORMAT (DEF-138 Bug Fix)
# ============================================================
# Two formats supported:
#
# 1. Simple format (backward compatible):
#    suffix: 0.70
#
# 2. Complex format (with exclusions):
#    suffix:
#      weight: 0.70
#      exclusions:
#        - "term1"  # Reason why excluded
#        - "term2"
#
# EXCLUSIONS: Prevent false positives by explicitly listing
# compound words that match the pattern but belong to different category.
# Example: "woordvoerder" ends in -woord but is PROCES, not TYPE.</code></pre>

<p>---</p>

<h2>Rollout Plan</h2>

<h3>Phase 1: Implementation (2 hours)</h3>
<ul>
<li>✅ Update YAML schema</li>
<li>✅ Update TermPatternConfig</li>
<li>✅ Update pattern matching logic</li>
<li>✅ Add exclusions for known false positives</li>
</ul>

<h3>Phase 2: Testing (30 min)</h3>
<ul>
<li>✅ Run new test suite</li>
<li>✅ Regression test: verify existing classifications still work</li>
<li>✅ Manual testing: spot-check 20 problematic terms</li>
</ul>

<h3>Phase 3: Deployment (15 min)</h3>
<ul>
<li>✅ Commit changes with conventional commit message</li>
<li>✅ Update DEF-138 ticket with resolution</li>
<li>✅ Monitor production logs for any new classification issues</li>
</ul>

<p>---</p>

<h2>Risk Assessment</h2>

<p><strong>Risk Level:</strong> LOW</p>
<ul>
<li>Backward compatible (both formats supported)</li>
<li>Explicit exclusions (easy to debug)</li>
<li>No performance impact (simple list check)</li>
</ul>

<p><strong>Rollback Plan:</strong></p>
<p>If issues arise, remove exclusions from YAML → classifier falls back to old behavior.</p>

<p>---</p>

<h2>Success Criteria</h2>

<ol>
<li>✅ `woordvoerder` classified as PROCES (not TYPE)</li>
<li>✅ `werkwoord` still classified as TYPE (not broken)</li>
<li>✅ All existing tests pass</li>
<li>✅ New test suite passes (100% coverage for exclusions)</li>
<li>✅ No performance regression (<5ms overhead)</li>
</ol>

<p>---</p>

<h2>Next Steps</h2>

<ol>
<li>**Implement Option A** (exclusion patterns)</li>
<li>**Run comprehensive test suite**</li>
<li>**Manual QA:** Test 20 known edge cases</li>
<li>**Update DEF-138 documentation**</li>
<li>**Monitor production:** Watch for new false positives in next 48h</li>
</ol>

<p>---</p>

<p><strong>Created:</strong> 2025-11-10</p>
<p><strong>Author:</strong> Debug Specialist</p>
<p><strong>Related:</strong> DEF-138, BUG_HUNT_REPORT_DEF138_COMPREHENSIVE.md</p>

  </div>
</body>
</html>