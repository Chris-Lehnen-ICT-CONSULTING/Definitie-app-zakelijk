<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>COMPREHENSIVE PROMPT BUILDING SYSTEM ANALYSIS - DefinitieAgent</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">â† Terug naar Portal</a>
    <h1>COMPREHENSIVE PROMPT BUILDING SYSTEM ANALYSIS - DefinitieAgent</h1>

<p><strong>Analysis Date:</strong> November 13, 2025  </p>
<p><strong>Project:</strong> DefinitieAgent  </p>
<p><strong>Focus:</strong> Context injection architecture and module organization  </p>
<p><strong>Thoroughness Level:</strong> VERY THOROUGH</p>

<p>---</p>

<h2>EXECUTIVE SUMMARY</h2>

<p>The DefinitieAgent prompt building system is a <strong>true modular architecture</strong> using an <strong>Orchestrator pattern</strong> with 16 specialized modules. The system is designed to generate complex legal definition prompts by orchestrating independent modules that each contribute specific prompt sections.</p>

<h3>Key Findings:</h3>

<ol>
<li>**16 Modules Total** - All registered and orchestrated by `PromptOrchestrator`</li>
<li>**Context Injection Scatter** - Context-related instructions are SCATTERED across **3 different modules**:</li>
</ol>
<ul>
<li>  - **ContextAwarenessModule** - Injects "ğŸ“Œ VERPLICHTE CONTEXT INFORMATIE"</li>
<li>  - **ErrorPreventionModule** - Injects "ğŸš¨ CONTEXT-SPECIFIEKE VERBODEN"  </li>
<li>  - **DefinitionTaskModule** - Contains "Context verwerkt zonder expliciete benoeming" in checklist</li>
</ul>

<ol>
<li>**Shared State Pattern** - Modules share context via `ModuleContext.shared_state` dictionary</li>
<li>**Dependency Management** - PromptOrchestrator resolves execution order using topological sort (Kahn's algorithm)</li>
</ol>

<p>---</p>

<h2>ARCHITECTURE OVERVIEW</h2>

<h3>System Components</h3>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROMPT BUILDING SYSTEM                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚      PromptServiceV2 (Entry Point)     â”‚
        â”‚  - Builds EnrichedContext                â”‚
        â”‚  - Calls UnifiedPromptBuilder            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     UnifiedPromptBuilder (Legacy)       â”‚
        â”‚  - Alternative prompt generation        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚        ModularPromptAdapter             â”‚
        â”‚  - Facade/Adapter pattern               â”‚
        â”‚  - Bridges old interface to new system  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       PromptOrchestrator                â”‚
        â”‚  - Module registration &amp; lifecycle     â”‚
        â”‚  - Dependency resolution               â”‚
        â”‚  - Parallel/sequential execution       â”‚
        â”‚  - Output combination                  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          16 SPECIALIZED MODULES         â”‚
        â”‚   (See details below - Section 3)       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<p>---</p>

<h2>SECTION 1: PROMPT ORCHESTRATOR ARCHITECTURE</h2>

<h3>File: `src/services/prompts/modules/prompt_orchestrator.py`</h3>

<p><strong>Purpose:</strong> Central orchestration of all prompt modules</p>

<p><strong>Key Responsibilities:</strong></p>
<ol>
<li>Module registration and lifecycle management</li>
<li>Dependency resolution using Kahn's algorithm</li>
<li>Parallel and sequential execution</li>
<li>Output combination and validation</li>
</ol>

<h3>Module Registration Flow</h3>

<pre><code># ModularPromptAdapter._setup_orchestrator() (line 120-130)
orchestrator = get_cached_orchestrator()  # Singleton pattern
modules = [
    ExpertiseModule(),
    OutputSpecificationModule(),
    GrammarModule(),
    ContextAwarenessModule(),        # â† CONTEXT INJECTION #1
    SemanticCategorisationModule(),
    TemplateModule(),
    # Rule modules (7 total)
    AraiRulesModule(),
    ConRulesModule(),
    EssRulesModule(),
    IntegrityRulesModule(),
    SamRulesModule(),
    StructureRulesModule(),
    VerRulesModule(),
    # Final modules
    ErrorPreventionModule(),         # â† CONTEXT INJECTION #2
    MetricsModule(),
    DefinitionTaskModule(),          # â† CONTEXT INJECTION #3
]

for module in modules:
    orchestrator.register_module(module)</code></pre>

<h3>Default Module Execution Order</h3>

<p>From <code>prompt_orchestrator.py</code>, lines 354-372:</p>

<pre><code>[
    "expertise",                    # Priority: 100
    "output_specification",
    "grammar",
    "context_awareness",            # Priority: 70
    "semantic_categorisation",
    "template",
    "arai_rules",                   # Validation rules
    "con_rules",
    "ess_rules",
    "structure_rules",
    "integrity_rules",
    "sam_rules",
    "ver_rules",
    "error_prevention",             # Priority: default
    "metrics",
    "definition_task",              # Final module
]</code></pre>

<h3>Execution Model</h3>

<p><strong>Sequential Batching (Lines 97-141):</strong></p>
<ul>
<li>Uses topological sort (Kahn's algorithm)</li>
<li>Determines dependencies between modules</li>
<li>Groups independent modules into batches</li>
<li>Executes batches sequentially, modules within batch in parallel</li>
</ul>

<p><strong>Parallel Workers:</strong></p>
<ul>
<li>Default: 4 max_workers</li>
<li>Uses ThreadPoolExecutor for batch execution</li>
<li>Thread-safe with proper error handling</li>
</ul>

<p>---</p>

<h2>SECTION 2: CONTEXT INJECTION POINTS - DETAILED MAPPING</h2>

<h3>INJECTION POINT #1: ContextAwarenessModule</h3>

<p><strong>File:</strong> <code>src/services/prompts/modules/context_awareness_module.py</code>  </p>
<p><strong>Module ID:</strong> <code>context_awareness</code>  </p>
<p><strong>Priority:</strong> 70  </p>
<p><strong>Dependencies:</strong> None</p>

<h4>Context Injection Locations:</h4>

<p><strong>Line 239 (Moderate Context - 0.5 â‰¤ score < 0.8):</strong></p>
<pre><code>sections.append("ğŸ“Œ VERPLICHTE CONTEXT INFORMATIE:")
sections.append(
    "âš ï¸ BELANGRIJKE INSTRUCTIE: Gebruik onderstaande context om de definitie "
    "specifiek te maken voor deze organisatorische, juridische en wettelijke context. "
    "Formuleer de definitie zodanig dat deze past binnen deze specifieke context, "
    "zonder de context expliciet te benoemen."
)</code></pre>

<p><strong>Line 201 (Rich Context - score â‰¥ 0.8):</strong></p>
<pre><code>sections.append("ğŸ“Š UITGEBREIDE CONTEXT ANALYSE:")
sections.append(
    "âš ï¸ VERPLICHT: Gebruik onderstaande specifieke context om de definitie te formuleren "
    "voor deze organisatorische, juridische en wettelijke setting. Maak de definitie "
    "contextspecifiek zonder de context expliciet te benoemen."
)</code></pre>

<p><strong>Line 277 (Minimal Context - score < 0.5):</strong></p>
<pre><code>return f"ğŸ“ VERPLICHTE CONTEXT: {context_text}\nâš ï¸ INSTRUCTIE: Formuleer de "
        f"definitie specifiek voor bovenstaande organisatorische, juridische en "
        f"wettelijke context zonder deze expliciet te benoemen."</code></pre>

<h4>Context Richness Scoring (Lines 143-184):</h4>

<pre><code>def _calculate_context_score(self, enriched_context) -&gt; float:
    """Calculates 0.0-1.0 score based on:
    - Base context items (max 0.3)
    - Sources confidence (max 0.4)  
    - Expanded terms (max 0.2)
    - Confidence scores (max 0.1)
    """</code></pre>

<h4>Shared State Distribution (Lines 368-395):</h4>

<p>The module shares context types via <code>context.set_shared()</code>:</p>
<pre><code># Line 388-392
context.set_shared("organization_contexts", org_contexts)      # Used by ErrorPreventionModule
context.set_shared("juridical_contexts", jur_contexts)        # Used by ErrorPreventionModule
context.set_shared("legal_basis_contexts", wet_contexts)      # Used by ErrorPreventionModule</code></pre>

<h4>Context Types Handled:</h4>

<p>From lines 382-384:</p>
<pre><code>org_contexts = self._extract_contexts(base_context.get("organisatorisch"))
jur_contexts = self._extract_contexts(base_context.get("juridisch"))
wet_contexts = self._extract_contexts(base_context.get("wettelijk"))</code></pre>

<p>These come from <code>EnrichedContext.base_context</code> which has keys:</p>
<ul>
<li>`organisatorisch` / `organisatorische_context`</li>
<li>`juridisch` / `juridische_context`</li>
<li>`wettelijk` / `wettelijke_basis`</li>
</ul>

<p>---</p>

<h3>INJECTION POINT #2: ErrorPreventionModule</h3>

<p><strong>File:</strong> <code>src/services/prompts/modules/error_prevention_module.py</code>  </p>
<p><strong>Module ID:</strong> <code>error_prevention</code>  </p>
<p><strong>Priority:</strong> Default (50)  </p>
<p><strong>Dependencies:</strong> <code>["context_awareness"]</code></p>

<h4>Context Injection Location:</h4>

<p><strong>Lines 95-100:</strong></p>
<pre><code>context_forbidden = self._build_context_forbidden(
    org_contexts, jur_contexts, wet_contexts
)
if context_forbidden:
    sections.append("\n### ğŸš¨ CONTEXT-SPECIFIEKE VERBODEN:")
    sections.extend(context_forbidden)</code></pre>

<h4>Context Injection Method (Lines 193-245):</h4>

<p><strong>Context Retrieval (Lines 75-79):</strong></p>
<pre><code># Haal context informatie op van ContextAwarenessModule (via shared state)
org_contexts = context.get_shared("organization_contexts", [])
jur_contexts = context.get_shared("juridical_contexts", [])
wet_contexts = context.get_shared("legal_basis_contexts", [])</code></pre>

<p><strong>Organization Mapping (Lines 209-219):</strong></p>
<pre><code>org_mappings = {
    "NP": "Nederlands Politie",
    "DJI": "Dienst JustitiÃ«le Inrichtingen",
    "OM": "Openbaar Ministerie",
    "ZM": "Zittende Magistratuur",
    "3RO": "Samenwerkingsverband Reclasseringsorganisaties",
    "CJIB": "Centraal Justitieel Incassobureau",
    "KMAR": "Koninklijke Marechaussee",
    "FIOD": "Fiscale Inlichtingen- en Opsporingsdienst",
}</code></pre>

<p><strong>Generated Forbidden Instructions (Lines 221-243):</strong></p>

<p>For each context type, generates specific warnings:</p>
<pre><code># Organisational context (line 222-231)
for org in org_contexts:
    forbidden.append(f"- Gebruik de term '{org}' of een variant daarvan "
                    f"niet letterlijk in de definitie.")
    if org in org_mappings:
        forbidden.append(f"- Gebruik de term '{org_mappings[org]}' of een "
                        f"variant daarvan niet letterlijk in de definitie.")

# Juridical context (lines 234-237)
for jur in jur_contexts:
    forbidden.append(f"- Vermijd expliciete vermelding van juridisch context "
                    f"'{jur}' in de definitie.")

# Legal basis context (lines 240-243)
for wet in wet_contexts:
    forbidden.append(f"- Vermijd expliciete vermelding van wetboek '{wet}' "
                    f"in de definitie.")</code></pre>

<h4>Validation Matrix (Lines 247-259):</h4>

<p>Also includes a validation matrix that references context handling:</p>
<ul>
<li>Line 256: "Letterlijke contextvermelding | âœ… | Noem context niet letterlijk"</li>
</ul>

<p>---</p>

<h3>INJECTION POINT #3: DefinitionTaskModule</h3>

<p><strong>File:</strong> <code>src/services/prompts/modules/definition_task_module.py</code>  </p>
<p><strong>Module ID:</strong> <code>definition_task</code>  </p>
<p><strong>Priority:</strong> Default (50)  </p>
<p><strong>Dependencies:</strong> <code>["semantic_categorisation"]</code></p>

<h4>Context References in Checklist:</h4>

<p><strong>Lines 172-204 - _build_checklist():</strong></p>

<p>The checklist includes this line (line 204):</p>
<pre><code>â†’ Context verwerkt zonder expliciete benoeming</code></pre>

<p>This is part of the construction guide that appears in the final checklist.</p>

<h4>Context-Aware Quality Control (Lines 206-223):</h4>

<pre><code>def _build_quality_control(self, has_context: bool) -&gt; str:
    context_vraag = "de gegeven context" if has_context else "algemeen gebruik"
    
    return f"""#### ğŸ” KWALITEITSCONTROLE:
Stel jezelf deze vragen:
1. Is direct duidelijk WAT het begrip is (niet het doel)?
2. Kan iemand hiermee bepalen of iets wel/niet onder dit begrip valt?
3. Is de formulering specifiek genoeg voor {context_vraag}?
4. Bevat de definitie alleen essentiÃ«le informatie?"""</code></pre>

<h4>Context Detection in Execute (Lines 84-104):</h4>

<pre><code># Derive context from enriched_context.base_context
base_ctx = context.enriched_context.base_context if context and context.enriched_context else {}
jur_contexts = base_ctx.get("juridische_context") or base_ctx.get("juridisch") or []
wet_basis = base_ctx.get("wettelijke_basis") or base_ctx.get("wettelijk") or []
has_context = bool(org_contexts or jur_contexts or wet_basis)</code></pre>

<h4>Metadata Generation (Lines 259-299):</h4>

<p>Generates context metadata including:</p>
<pre><code>if jur_contexts:
    lines.append(f"- Juridische context: {', '.join(jur_contexts)}")
else:
    lines.append("- Juridische context: geen")

if wet_basis:
    lines.append(f"- Wettelijke basis: {', '.join(wet_basis)}")
else:
    lines.append("- Wettelijke basis: geen")</code></pre>

<p>---</p>

<h2>SECTION 3: COMPLETE MODULE INVENTORY</h2>

<h3>All 16 Modules with Context Handling</h3>

<p>| # | Module ID | Class Name | Priority | Dependencies | Context Role | File |</p>
<p>|---|-----------|-----------|----------|--------------|--------------|------|</p>
<p>| 1 | expertise | ExpertiseModule | 100 | None | Sets "word_type" | expertise_module.py |</p>
<p>| 2 | output_specification | OutputSpecificationModule | - | None | Validates output | output_specification_module.py |</p>
<p>| 3 | grammar | GrammarModule | - | None | Grammar rules | grammar_module.py |</p>
<p>| 4 | <strong>context_awareness</strong> | <strong>ContextAwarenessModule</strong> | <strong>70</strong> | <strong>None</strong> | <strong>ğŸš¨ INJECTS CONTEXT</strong> | context_awareness_module.py |</p>
<p>| 5 | semantic_categorisation | SemanticCategorisationModule | - | None | Sets "ontological_category" | semantic_categorisation_module.py |</p>
<p>| 6 | template | TemplateModule | 60 | None | Uses ontological_category | template_module.py |</p>
<p>| 7 | arai_rules | AraiRulesModule | - | None | General validation rules | arai_rules_module.py |</p>
<p>| 8 | con_rules | ConRulesModule | - | None | Context validation rules | con_rules_module.py |</p>
<p>| 9 | ess_rules | EssRulesModule | - | None | Essence validation rules | ess_rules_module.py |</p>
<p>| 10 | structure_rules | StructureRulesModule | - | None | Structure validation rules | structure_rules_module.py |</p>
<p>| 11 | integrity_rules | IntegrityRulesModule | 65 | None | Integrity validation rules | integrity_rules_module.py |</p>
<p>| 12 | sam_rules | SamRulesModule | - | None | Coherence validation rules | sam_rules_module.py |</p>
<p>| 13 | ver_rules | VerRulesModule | - | None | Form validation rules | ver_rules_module.py |</p>
<p>| 14 | <strong>error_prevention</strong> | <strong>ErrorPreventionModule</strong> | <strong>50</strong> | <strong>context_awareness</strong> | <strong>ğŸš¨ INJECTS FORBIDDEN</strong> | error_prevention_module.py |</p>
<p>| 15 | metrics | MetricsModule | - | None | Quality metrics | metrics_module.py |</p>
<p>| 16 | <strong>definition_task</strong> | <strong>DefinitionTaskModule</strong> | <strong>50</strong> | <strong>semantic_categorisation</strong> | <strong>ğŸš¨ CONTEXT METADATA</strong> | definition_task_module.py |</p>

<h3>Context Dependency Map</h3>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ContextAwarenessModule              â”‚
â”‚  - Calculates context richness       â”‚
â”‚  - Injects "VERPLICHTE CONTEXT"      â”‚
â”‚  - Shares context via set_shared()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â”œâ”€â†’ Shares to ErrorPreventionModule
                   â”‚   - organization_contexts
                   â”‚   - juridical_contexts  
                   â”‚   - legal_basis_contexts
                   â”‚
                   â””â”€â†’ Shares to DefinitionTaskModule
                       (indirectly via base_context)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ErrorPreventionModule               â”‚
â”‚  - Depends on ContextAwarenessModule â”‚
â”‚  - Injects "CONTEXT-SPECIFIEKE       â”‚
â”‚    VERBODEN"                         â”‚
â”‚  - Maps org names to full names      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DefinitionTaskModule                â”‚
â”‚  - Mentions "Context verwerkt        â”‚
â”‚    zonder expliciete benoeming"      â”‚
â”‚  - Generates context metadata        â”‚
â”‚  - Modifies quality control          â”‚
â”‚    instructions based on context     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<p>---</p>

<h2>SECTION 4: CONTEXT FLOW - ENTRY TO OUTPUT</h2>

<h3>Step 1: Entry Point - PromptServiceV2</h3>

<p><strong>File:</strong> <code>src/services/prompts/prompt_service_v2.py</code> (Lines 84-142)</p>

<pre><code>async def build_generation_prompt(
    self,
    request: GenerationRequest,
    feedback_history: list[dict] | None = None,
    context: dict[str, Any] | None = None,
) -&gt; PromptResult:
    # Build enriched context via HybridContextManager
    enriched_context = await self.context_manager.build_enriched_context(request)
    
    # Add ontologische_categorie to metadata
    if request.ontologische_categorie:
        enriched_context.metadata["ontologische_categorie"] = cat</code></pre>

<h3>Step 2: Context Enrichment</h3>

<p><strong>EnrichedContext Structure:</strong></p>
<pre><code>{
    "base_context": {
        "organisatorisch": ["NP", "DJI"],
        "organisatorische_context": ["Netherlands Police"],
        "juridisch": ["Criminal Code"],
        "juridische_context": ["Criminal Code"],
        "wettelijk": ["Wetboek van Strafrecht"],
        "wettelijke_basis": ["Wetboek van Strafrecht"],
    },
    "sources": [...],
    "expanded_terms": {...},
    "confidence_scores": {...},
    "metadata": {
        "ontologische_categorie": "proces",
        "semantic_category": "Proces",
        ...
    }
}</code></pre>

<h3>Step 3: Module Execution - ContextAwarenessModule</h3>

<pre><code>INPUT: EnrichedContext with base_context values
  â†“
CALCULATION: context_score = f(base_context size, sources, expanded_terms, confidence)
  â†“
OUTPUT FORMAT SELECTION:
  - score â‰¥ 0.8: Rich formatting with detailed categories + sources + abbreviations
  - 0.5 â‰¤ score &lt; 0.8: Moderate formatting with context list
  - score &lt; 0.5: Minimal formatting
  â†“
SHARED STATE DISTRIBUTION:
  - context.set_shared("organization_contexts", org_contexts)
  - context.set_shared("juridical_contexts", jur_contexts)
  - context.set_shared("legal_basis_contexts", wet_contexts)
  â†“
OUTPUT TO PROMPT: Formatted context section with warnings</code></pre>

<h3>Step 4: Module Execution - ErrorPreventionModule</h3>

<pre><code>INPUT: Shared state from ContextAwarenessModule
  â†“
RETRIEVAL:
  org_contexts = context.get_shared("organization_contexts", [])
  jur_contexts = context.get_shared("juridical_contexts", [])
  wet_contexts = context.get_shared("legal_basis_contexts", [])
  â†“
PROCESSING:
  - Map organization codes to full names
  - Generate "CONTEXT-SPECIFIEKE VERBODEN" for each context item
  - Add validation matrix
  â†“
OUTPUT TO PROMPT: Forbidden patterns section with context-specific rules</code></pre>

<h3>Step 5: Module Execution - DefinitionTaskModule</h3>

<pre><code>INPUT: EnrichedContext + shared state
  â†“
CONTEXT DETECTION:
  has_context = bool(org_contexts or jur_contexts or wet_basis)
  â†“
OUTPUT MODIFICATIONS:
  - Quality control questions adapt based on has_context
  - Metadata section lists all active contexts
  - Checklist includes "Context verwerkt zonder expliciete benoeming"
  â†“
OUTPUT TO PROMPT: Final instructions with context metadata</code></pre>

<h3>Step 6: Final Prompt Assembly</h3>

<p><strong>PromptOrchestrator._combine_outputs()</strong> (Lines 307-335):</p>

<pre><code># Combines outputs in default module order:
ordered_sections = [
    expertise_output,
    output_specification_output,
    grammar_output,
    context_awareness_output,            # â† CONTEXT #1
    semantic_categorisation_output,
    template_output,
    arai_rules_output,
    con_rules_output,
    ess_rules_output,
    structure_rules_output,
    integrity_rules_output,
    sam_rules_output,
    ver_rules_output,
    error_prevention_output,             # â† CONTEXT #2
    metrics_output,
    definition_task_output,              # â† CONTEXT #3
]

final_prompt = "\n\n".join(ordered_sections)</code></pre>

<p>---</p>

<h2>SECTION 5: CONTEXT INJECTION DUPLICATION ANALYSIS</h2>

<h3>Problem Summary</h3>

<p>Context-related instructions are <strong>SCATTERED across 3 modules</strong> instead of being <strong>CONSOLIDATED</strong>:</p>

<p>| Aspect | Location 1 | Location 2 | Location 3 |</p>
<p>|--------|-----------|-----------|-----------|</p>
<p>| <strong>Module</strong> | ContextAwarenessModule | ErrorPreventionModule | DefinitionTaskModule |</p>
<p>| <strong>File</strong> | context_awareness_module.py | error_prevention_module.py | definition_task_module.py |</p>
<p>| <strong>Lines</strong> | 239, 201, 277 | 99 | 204 |</p>
<p>| <strong>Injection Type</strong> | Context instructions | Forbidden patterns | Metadata + checklist |</p>
<p>| <strong>What it says</strong> | "VERPLICHTE CONTEXT INFORMATIE" | "CONTEXT-SPECIFIEKE VERBODEN" | "Context verwerkt zonder..." |</p>
<p>| <strong>Data Dependency</strong> | Direct from base_context | Shared state from module above | Direct from base_context |</p>
<p>| <strong>Duplication Risk</strong> | Score-based formatting | Re-lists contexts | Static text in checklist |</p>

<h3>Current Problem: Multiple Instruction Points</h3>

<p>Users see context instructions in <strong>3 different parts of prompt</strong>:</p>

<ol>
<li>**Early (After Grammar):** ContextAwarenessModule injects "ğŸ“Œ VERPLICHTE CONTEXT INFORMATIE"</li>
<li>**Middle (Before Metrics):** ErrorPreventionModule injects "ğŸš¨ CONTEXT-SPECIFIEKE VERBODEN"</li>
<li>**End (Final Section):** DefinitionTaskModule mentions "Context verwerkt zonder..." in checklist</li>
</ol>

<h3>Redundancy Issues</h3>

<ol>
<li>**Context Information Repeated**</li>
</ol>
<ul>
<li>  - ContextAwarenessModule lists contexts in formatted section</li>
<li>  - ErrorPreventionModule re-lists contexts as "verboden" for each one</li>
<li>  - DefinitionTaskModule generates metadata listing contexts again</li>
</ul>

<ol>
<li>**Instructions Scattered**</li>
</ol>
<ul>
<li>  - Instruction to "use context but don't mention it literally" appears at **3 places**</li>
<li>  - Score-based formatting in ContextAwarenessModule vs. static text in DefinitionTaskModule</li>
<li>  - No single source of truth for context handling guidance</li>
</ul>

<ol>
<li>**Shared State Dependencies**</li>
</ol>
<ul>
<li>  - ErrorPreventionModule depends on ContextAwarenessModule's shared state</li>
<li>  - DefinitionTaskModule doesn't use shared state, reads base_context directly</li>
<li>  - Creates tight coupling and fragile data flow</li>
</ul>

<ol>
<li>**Token Usage Impact**</li>
</ol>
<ul>
<li>  - Each module reformats context information</li>
<li>  - Score-based strategy in ContextAwarenessModule doesn't fully propagate to other modules</li>
<li>  - ErrorPreventionModule generates forbidden lists that could be reused</li>
</ul>

<p>---</p>

<h2>SECTION 6: MODULE DEPENDENCY GRAPH</h2>

<h3>Explicit Dependencies</h3>

<pre><code>Definition of "dependency" per BasePromptModule.get_dependencies():
- Module A depends on Module B if get_dependencies() returns [B.module_id]
- Orchestrator uses Kahn's algorithm to order execution

Current explicit dependencies:
â”œâ”€â”€ ErrorPreventionModule
â”‚   â””â”€â”€ depends on: ["context_awareness"]
â”‚
â””â”€â”€ DefinitionTaskModule
    â””â”€â”€ depends on: ["semantic_categorisation"]

All other modules:
â””â”€â”€ depend on: [] (no explicit dependencies)</code></pre>

<h3>Implicit Dependencies (via shared_state)</h3>

<pre><code>Context Awareness Module (PRODUCER)
â”œâ”€â”€ Sets: "context_richness_score"
â”œâ”€â”€ Sets: "organization_contexts"
â”œâ”€â”€ Sets: "juridical_contexts"
â”œâ”€â”€ Sets: "legal_basis_contexts"
â””â”€â”€ Sets: "word_type"

Error Prevention Module (CONSUMER)
â”œâ”€â”€ Reads: "organization_contexts"
â”œâ”€â”€ Reads: "juridical_contexts"
â””â”€â”€ Reads: "legal_basis_contexts"

Definition Task Module (CONSUMER)
â”œâ”€â”€ Reads: "word_type"
â”œâ”€â”€ Reads: "ontological_category"
â””â”€â”€ Also reads: base_context directly (not via shared_state)

Semantic Categorisation Module (PRODUCER)
â”œâ”€â”€ Sets: "ontological_category"
â””â”€â”€ Sets: "organization_contexts" (indirectly)

Template Module (CONSUMER)
â”œâ”€â”€ Reads: "semantic_category" (from metadata)
â””â”€â”€ Reads: "word_type"</code></pre>

<h3>Execution Order vs Dependency Analysis</h3>

<pre><code>Default order (lines 354-372):
1. expertise                    [no deps]
2. output_specification         [no deps]
3. grammar                      [no deps]
4. context_awareness           [no deps] â† PRODUCER of shared contexts
5. semantic_categorisation     [no deps]
6. template                    [no deps]
7. arai_rules                  [no deps]
8. con_rules                   [no deps]
9. ess_rules                   [no deps]
10. structure_rules             [no deps]
11. integrity_rules             [no deps]
12. sam_rules                   [no deps]
13. ver_rules                   [no deps]
14. error_prevention            [context_awareness] â† CONSUMER of shared contexts
15. metrics                     [no deps]
16. definition_task             [semantic_categorisation]

Observation: ErrorPreventionModule's explicit dependency on context_awareness
is correct and enforced by Kahn's algorithm.</code></pre>

<p>---</p>

<h2>SECTION 7: DATA FLOW - CONTEXT THROUGH MODULES</h2>

<h3>Base Context Entry Point</h3>

<p>From <code>prompt_service_v2.py</code>, the GenerationRequest is converted to EnrichedContext:</p>

<pre><code>request.organisatorische_context        â†’ enriched_context.base_context["organisatorisch"]
request.juridische_context              â†’ enriched_context.base_context["juridisch"]
request.wettelijke_basis                â†’ enriched_context.base_context["wettelijk"]</code></pre>

<h3>Context Awareness Module Processing</h3>

<pre><code>INPUT base_context:
{
    "organisatorisch": ["NP"],
    "juridisch": ["Strafrecht"],
    "wettelijk": ["Wetboek van Strafrecht"],
}

CALCULATION:
score = base_items/10 (max 0.3)
      + source_confidence * 0.4 (max 0.4)
      + expanded_terms/5 (max 0.2)
      + avg_confidence * 0.1 (max 0.1)
      = variable between 0.0-1.0

FORMATTING (based on score):
if score â‰¥ 0.8:
    - "ğŸ“Š UITGEBREIDE CONTEXT ANALYSE:"
    - Detailed context with categories
    - Sources with confidence indicators
    - Abbreviations detailed
elif 0.5 â‰¤ score &lt; 0.8:
    - "ğŸ“Œ VERPLICHTE CONTEXT INFORMATIE:"
    - Simple context list with warning
    - Abbreviations simple
else:
    - "ğŸ“ VERPLICHTE CONTEXT:"
    - Minimal formatting

OUTPUT shared_state:
- organization_contexts: ["NP"]
- juridical_contexts: ["Strafrecht"]
- legal_basis_contexts: ["Wetboek van Strafrecht"]
- context_richness_score: 0.35 (example)</code></pre>

<h3>Error Prevention Module Processing</h3>

<pre><code>INPUT shared_state:
- organization_contexts: ["NP"]
- juridical_contexts: ["Strafrecht"]
- legal_basis_contexts: ["Wetboek van Strafrecht"]

PROCESSING:
for org in organization_contexts:
    output += f"- Gebruik de term '{org}' niet letterlijk"
    if org in mappings:
        output += f"- Gebruik de term '{mappings[org]}' niet letterlijk"

for jur in juridical_contexts:
    output += f"- Vermijd expliciete vermelding van '{jur}'"

for wet in legal_basis_contexts:
    output += f"- Vermijd expliciete vermelding van '{wet}'"

OUTPUT:
"### ğŸš¨ CONTEXT-SPECIFIEKE VERBODEN:
- Gebruik de term 'NP' niet letterlijk in de definitie.
- Gebruik de term 'Nederlands Politie' niet letterlijk in de definitie.
- Vermijd expliciete vermelding van juridisch context 'Strafrecht' in de definitie.
- Vermijd expliciete vermelding van wetboek 'Wetboek van Strafrecht' in de definitie."</code></pre>

<h3>Definition Task Module Processing</h3>

<pre><code>INPUT enriched_context.base_context:
{
    "organisatorisch": ["NP"],
    "juridisch": ["Strafrecht"],
    "wettelijk": ["Wetboek van Strafrecht"],
}

DETECTION:
has_context = bool(org_contexts or jur_contexts or wet_basis)
            = bool(["NP"] or ["Strafrecht"] or ["Wetboek..."])
            = True

MODIFICATION 1 - Quality Control:
if has_context:
    q3 = "Is de formulering specifiek genoeg voor de gegeven context?"
else:
    q3 = "Is de formulering specifiek genoeg voor algemeen gebruik?"

MODIFICATION 2 - Metadata:
metadata += "- Organisatorische context: NP"
metadata += "- Juridische context: Strafrecht"
metadata += "- Wettelijke basis: Wetboek van Strafrecht"

MODIFICATION 3 - Checklist:
â†’ Context verwerkt zonder expliciete benoeming (static text)

OUTPUT:
3 different context-related outputs in final prompt section</code></pre>

<p>---</p>

<h2>SECTION 8: CONFIGURATION & INITIALIZATION</h2>

<h3>Configuration Flow</h3>

<p>From <code>modular_prompt_adapter.py</code> lines 136-213:</p>

<pre><code>def _convert_config_to_module_configs(self) -&gt; dict[str, dict[str, Any]]:
    """Converts PromptComponentConfig to per-module configs"""
    
    return {
        "context_awareness": {
            "adaptive_formatting": not config.compact_mode,
            "confidence_indicators": config.enable_component_metadata,
            "include_abbreviations": config.include_examples_in_rules,
        },
        "error_prevention": {
            "include_validation_matrix": not config.compact_mode,
            "extended_forbidden_list": not config.compact_mode,
        },
        "definition_task": {
            "include_quality_control": not config.compact_mode,
            "include_metadata": config.enable_component_metadata,
        },
        # ... other modules
    }</code></pre>

<h3>Singleton Pattern</h3>

<p>From <code>modular_prompt_adapter.py</code> lines 42-88:</p>

<pre><code>def get_cached_orchestrator() -&gt; PromptOrchestrator:
    """Singleton pattern with double-check locking"""
    global _global_orchestrator
    
    if _global_orchestrator is None:
        with _orchestrator_lock:
            if _global_orchestrator is None:
                orchestrator = PromptOrchestrator(max_workers=4)
                # Register all 16 modules
                _global_orchestrator = orchestrator
    
    return _global_orchestrator</code></pre>

<p><strong>Benefit:</strong> Modules only instantiated once per Streamlit session</p>

<p>---</p>

<h2>SECTION 9: EXECUTION FLOW - COMPLETE SEQUENCE</h2>

<h3>Full Call Stack</h3>

<pre><code>1. UI Tab (e.g., definition_generator_tab.py)
   â†“
2. async_bridge.run_async(build_generation_prompt)
   â†“
3. PromptServiceV2.build_generation_prompt(request)
   â†“
4. HybridContextManager.build_enriched_context(request)
   â†“
5. UnifiedPromptBuilder.build_prompt(begrip, enriched_context)
   â†“
6. ModularPromptAdapter.build_prompt(begrip, enriched_context, config)
   â†“
7. PromptOrchestrator.build_prompt(begrip, enriched_context, config)
   â”œâ”€ resolve_execution_order() â†’ [batch1, batch2, ..., batchN]
   â”œâ”€ For each batch:
   â”‚  â”œâ”€ _execute_batch_parallel() or _execute_module()
   â”‚  â”œâ”€ module.validate_input(context)
   â”‚  â”œâ”€ module.execute(context) â† Generates prompt section
   â”‚  â””â”€ Returns ModuleOutput(content, metadata, success)
   â””â”€ _combine_outputs() â†’ Final prompt text
   â†“
8. Return complete prompt to UI
   â†“
9. UI passes prompt to UnifiedDefinitionGenerator for API call</code></pre>

<h3>Module Execution Timeline</h3>

<pre><code>Timeline for 16 modules (parallel execution in batches):

Batch 1 (t=0):
  expertise
  output_specification
  grammar
  â†’ No dependencies, all run in parallel

Batch 2 (t=T1):
  context_awareness        â† Produces shared context data
  semantic_categorisation
  template
  â†’ Depends on Batch 1, can run in parallel

Batch 3 (t=T1+T2):
  arai_rules
  con_rules
  ess_rules
  structure_rules
  integrity_rules
  sam_rules
  ver_rules
  â†’ Depend on Batch 2, run in parallel

Batch 4 (t=T1+T2+T3):
  error_prevention         â† Consumes context_awareness output
  metrics
  â†’ error_prevention explicitly depends on context_awareness (enforced)

Batch 5 (t=T1+T2+T3+T4):
  definition_task          â† Consumes semantic_categorisation
  â†’ Depends on semantic_categorisation (enforced)

Final: _combine_outputs() concatenates in defined order</code></pre>

<p>---</p>

<h2>SECTION 10: CURRENT ISSUES & CONSOLIDATION OPPORTUNITIES</h2>

<h3>Issue 1: Context Instructions Scattered</h3>

<p><strong>Root Cause:</strong></p>
<ul>
<li>Each module that needs context information generates its own instructions</li>
<li>No single point where context handling is consolidated</li>
<li>Three different modules each contribute context-related text</li>
</ul>

<p><strong>Impact:</strong></p>
<ul>
<li>Users see repetitive warnings about using context</li>
<li>Token usage is higher than necessary</li>
<li>If context handling needs updating, must change 3 modules</li>
</ul>

<p><strong>Example - Token Waste:</strong></p>
<pre><code>ContextAwarenessModule outputs:
"ğŸ“Œ VERPLICHTE CONTEXT INFORMATIE: ... gebruik context ... zonder expliciet..."
(~200 tokens)

ErrorPreventionModule outputs:
"ğŸš¨ CONTEXT-SPECIFIEKE VERBODEN:
- Gebruik 'NP' niet letterlijk
- Gebruik 'Netherlands Police' niet letterlijk
- Vermijd 'Strafrecht'
- Vermijd 'Wetboek van Strafrecht'"
(~100 tokens)

DefinitionTaskModule outputs:
"â†’ Context verwerkt zonder expliciete benoeming"
+ Quality control adapted
+ Metadata section
(~80 tokens)

Total: ~380 tokens for context-related content across 3 modules</code></pre>

<h3>Issue 2: Shared State vs Direct Access</h3>

<p><strong>Root Cause:</strong></p>
<ul>
<li>ErrorPreventionModule uses shared_state from ContextAwarenessModule</li>
<li>DefinitionTaskModule reads base_context directly</li>
<li>Inconsistent data access pattern</li>
</ul>

<p><strong>Impact:</strong></p>
<ul>
<li>If context structure changes, must update multiple modules</li>
<li>Harder to trace context flow through codebase</li>
<li>Possible desynchronization if shared_state and base_context diverge</li>
</ul>

<h3>Issue 3: Score-Based Formatting Not Propagated</h3>

<p><strong>Root Cause:</strong></p>
<ul>
<li>ContextAwarenessModule calculates context_richness_score (0.0-1.0)</li>
<li>Other modules don't use this score to adapt their output</li>
<li>ErrorPreventionModule generates same "forbidden" output regardless of context richness</li>
</ul>

<p><strong>Impact:</strong></p>
<ul>
<li>Opportunity for smarter, more concise context handling missed</li>
<li>Could use low-richness-score to shorten context sections</li>
</ul>

<h3>Issue 4: Organization Name Mapping Duplication</h3>

<p><strong>Root Cause:</strong></p>
<ul>
<li>ErrorPreventionModule has hardcoded mapping:</li>
<pre><code>  org_mappings = {
      "NP": "Nederlands Politie",
      "DJI": "Dienst JustitiÃ«le Inrichtingen",
      ...
  }</code></pre>
<li>This mapping could be centralized in context manager or configuration</li>
</ul>

<p><strong>Impact:</strong></p>
<ul>
<li>Maintenance burden if mappings change</li>
<li>Not reusable by other modules</li>
<li>Creates knowledge silos in codebase</li>
</ul>

<p>---</p>

<h2>SECTION 11: TECHNICAL SPECIFICATIONS FOR ANALYSIS</h2>

<h3>Module Interface</h3>

<p>All modules implement <code>BasePromptModule</code> with:</p>

<pre><code>class BasePromptModule(ABC):
    def __init__(self, module_id: str, module_name: str, priority: int = 50)
    def initialize(self, config: dict[str, Any]) -&gt; None
    def validate_input(self, context: ModuleContext) -&gt; tuple[bool, str | None]
    def execute(self, context: ModuleContext) -&gt; ModuleOutput
    def get_dependencies(self) -&gt; list[str]
    def get_info(self) -&gt; dict[str, Any]</code></pre>

<h3>ModuleContext Structure</h3>

<pre><code>@dataclass
class ModuleContext:
    begrip: str                              # The term to define
    enriched_context: EnrichedContext        # Full context with base_context, sources
    config: UnifiedGeneratorConfig           # Generator configuration
    shared_state: dict[str, Any]             # Inter-module communication
    
    def get_metadata(self, key: str, default: Any = None) -&gt; Any
    def set_shared(self, key: str, value: Any) -&gt; None
    def get_shared(self, key: str, default: Any = None) -&gt; Any</code></pre>

<h3>EnrichedContext Structure</h3>

<pre><code>@dataclass
class EnrichedContext:
    base_context: dict[str, list[str]]       # Context types (organisatorisch, juridisch, etc)
    sources: list[Source]                    # External sources
    expanded_terms: dict[str, str]           # Abbreviations
    confidence_scores: dict[str, float]      # Confidence per item
    metadata: dict[str, Any]                 # Flexible metadata</code></pre>

<h3>ModuleOutput Structure</h3>

<pre><code>@dataclass
class ModuleOutput:
    content: str                             # Prompt section generated
    metadata: dict[str, Any]                 # Execution metadata
    success: bool = True                     # Execution succeeded?
    error_message: str | None = None         # Error if failed
    
    @property
    def is_empty(self) -&gt; bool               # True if content empty</code></pre>

<p>---</p>

<h2>SECTION 12: CONSOLIDATION DESIGN PATTERNS</h2>

<h3>Pattern 1: Unified Context Module</h3>

<p><strong>Proposed approach:</strong></p>
<ul>
<li>Create single `ContextInjectionModule` that handles ALL context-related output</li>
<li>Takes context_richness_score into account for output sizing</li>
<li>Generates:</li>
</ul>
<ol>
<li>Initial context instructions (adaptive based on score)</li>
<li>Context-specific forbidden patterns</li>
<li>Context metadata</li>
</ol>
<ul>
<li>Other modules only read context via shared_state, don't generate context output</li>
</ul>

<p><strong>Benefits:</strong></p>
<ul>
<li>Single source of truth for context guidance</li>
<li>Reduces token usage through consolidation</li>
<li>Easier maintenance and updates</li>
<li>Clear responsibility separation</li>
</ul>

<h3>Pattern 2: Context Service</h3>

<p><strong>Proposed approach:</strong></p>
<ul>
<li>Extract context handling logic into separate service</li>
<li>Service provides:</li>
</ul>
<ol>
<li>`calculate_context_richness(base_context) â†’ float`</li>
<li>`generate_context_instructions(score, contexts) â†’ str`</li>
<li>`generate_forbidden_patterns(contexts) â†’ list[str]`</li>
<li>`map_organization_names(codes) â†’ dict[str, str]`</li>
</ol>
<ul>
<li>Modules use service instead of implementing logic directly</li>
</ul>

<p><strong>Benefits:</strong></p>
<ul>
<li>Reusable across codebase</li>
<li>Centralized organization mappings</li>
<li>Consistent calculations</li>
<li>Testable</li>
</ul>

<h3>Pattern 3: Tiered Context Output</h3>

<p><strong>Proposed approach:</strong></p>
<ul>
<li>Define 3 output "levels" based on context_richness_score:</li>
<li> - **Level 1 (score < 0.3):** Minimal context warning + metadata</li>
<li> - **Level 2 (0.3-0.7):** Standard context instructions + specific forbiddens</li>
<li> - **Level 3 (score â‰¥ 0.7):** Detailed context analysis + rich formatting</li>
<li>Single module generates appropriate level output</li>
<li>Reduces redundancy and token waste</li>
</ul>

<p>---</p>

<h2>CONCLUSION</h2>

<p>The DefinitieAgent prompt building system uses a well-designed <strong>16-module orchestrator pattern</strong> with proper dependency management and parallel execution. However, <strong>context-related instructions are scattered across 3 different modules</strong>, creating redundancy and maintenance challenges.</p>

<h3>Key Takeaways:</h3>

<ol>
<li>**Architecture is sound** - Modular design, proper orchestration, dependency handling</li>
<li>**Context injection is scattered** - Instructions repeated across ContextAwarenessModule, ErrorPreventionModule, DefinitionTaskModule</li>
<li>**Consolidation opportunity** - Significant token savings and maintenance improvement possible</li>
<li>**Data flow is mostly clean** - Uses shared_state pattern effectively (with one exception: DefinitionTaskModule reads base_context directly)</li>
<li>**Organization mappings are hardcoded** - Should be centralized</li>
</ol>

<h3>Recommendations:</h3>

<ol>
<li>**High Priority:** Consolidate context injection into single module</li>
<li>**Medium Priority:** Centralize organization name mappings</li>
<li>**Medium Priority:** Ensure consistent context data access (shared_state everywhere)</li>
<li>**Low Priority:** Utilize context_richness_score in all context-aware modules</li>
<li>**Enhancement:** Create reusable ContextService for cross-module use</li>
</ol>

<p>---</p>

<p><strong>Analysis Complete</strong> - Ready for implementation planning</p>

  </div>
</body>
</html>