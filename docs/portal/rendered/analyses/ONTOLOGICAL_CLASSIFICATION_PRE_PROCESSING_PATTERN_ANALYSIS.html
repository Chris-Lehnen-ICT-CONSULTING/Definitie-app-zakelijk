<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Strategic Analysis: Pre-Processing Pattern voor Ontologische Classificatie</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">â† Terug naar Portal</a>
    <h1>Strategic Analysis: Pre-Processing Pattern voor Ontologische Classificatie</h1>

<p><strong>Document Status:</strong> Strategic Architecture Analysis</p>
<p><strong>Date:</strong> 2025-10-07</p>
<p><strong>Version:</strong> 1.0</p>
<p><strong>Author:</strong> Claude Code (Analysis Agent)</p>

<p>---</p>

<h2>Executive Summary</h2>

<p><strong>REQUIREMENT:</strong></p>
<blockquote>"Classificatie moet LOS van definitie generatie, want categorie bepaalt promptopbouw"</blockquote>

<p><strong>STRATEGIC DECISION NEEDED:</strong></p>
<p>Waar in de pipeline hoort ontologische classificatie THUIS - als pre-processing stap, als service layer concern, of als dedicated classifier service?</p>

<p><strong>CURRENT STATE ASSESSMENT:</strong></p>
<ul>
<li>âœ… **OntologyClassifierService** bestaat (`src/services/classification/ontology_classifier.py`)</li>
<li>âœ… **LLM-based classificatie** met rules-based validatie</li>
<li>âœ… **Prompt module integratie** (`SemanticCategorisationModule`) gebruikt categorie voor template selection</li>
<li>âš ï¸ **Pipeline integration**: Classificatie is NIET expliciet pre-processing in current flow</li>
<li>âš ï¸ **UI integration**: Geen evidence van aparte classificatie stap in UI</li>
</ul>

<p><strong>RECOMMENDED PATTERN:</strong> <strong>Pipeline Pattern met Pre-Processing Layer</strong> (Optie B)</p>

<p>---</p>

<h2>1. PATTERN IDENTIFICATION</h2>

<h3>1.1 Current Architecture Analysis</h3>

<pre><code>HUIDIGE FLOW (Implicit classification):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UI Input (begrip + context)
    â†“
DefinitionOrchestratorV2.create_definition()
    â”œâ”€ Phase 1: Security sanitization
    â”œâ”€ Phase 2: Feedback integration
    â”œâ”€ Phase 2.5: Web lookup
    â”œâ”€ Phase 3: Prompt generation â† HIER wordt ontologische_categorie GEBRUIKT
    â”‚   â””â”€ SemanticCategorisationModule.execute()
    â”‚       â””â”€ context.get_metadata("ontologische_categorie") â† Van request object
    â”œâ”€ Phase 4: AI generation
    â””â”€ ...

ISSUE: ontologische_categorie komt van GenerationRequest, maar WAAR wordt die gezet?</code></pre>

<p><strong>Critical Finding:</strong></p>
<pre><code># src/services/orchestrators/definition_orchestrator_v2.py:201
logger.info(
    f"Generation {generation_id}: Starting orchestration for '{request.begrip}' "
    f"with category '{request.ontologische_categorie}'"  # â† Gebruikt, maar WAAR gezet?
)</code></pre>

<p><strong>Evidence of category influencing prompt:</strong></p>
<pre><code># src/services/prompts/modules/semantic_categorisation_module.py:86-90
categorie = context.get_metadata("ontologische_categorie")
if categorie:
    context.set_shared("ontological_category", categorie)  # â† Shared state!

# Category-specific guidance (line 154-157):
category_guidance = self._get_category_specific_guidance(categorie.lower())
# Returns different prompt sections per category:
# - PROCES: "is een activiteit waarbij..."
# - TYPE: "is een soort..."
# - RESULTAAT: "is het resultaat van..."</code></pre>

<p><strong>CONCLUSION:</strong> Categorie MOET pre-processing zijn, want het <strong>verandert prompt template structure</strong>.</p>

<p>---</p>

<h2>2. WAAR HOORT CLASSIFICATIE IN DE PIPELINE?</h2>

<h3>Analyse van 3 Architectuur Opties</h3>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPTIE A: SERVICE LAYER (in generate_definition)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚  UI â†’ ServiceAdapter.generate_definition()                            â”‚
â”‚         â”œâ”€ 1. Classify (internal)                                     â”‚
â”‚         â”œâ”€ 2. Build GenerationRequest (with category)                 â”‚
â”‚         â””â”€ 3. Call orchestrator                                       â”‚
â”‚                                                                       â”‚
â”‚  âœ… PRO:                                                              â”‚
â”‚     - Alles in 1 API call (simpel voor UI)                           â”‚
â”‚     - Geen UI-side state management                                  â”‚
â”‚     - Transparant voor callers                                       â”‚
â”‚                                                                       â”‚
â”‚  âŒ CON:                                                              â”‚
â”‚     - Classificatie is NIET herbruikbaar buiten generatie            â”‚
â”‚     - Batch classificatie (100 begrippen) MOET via generatie         â”‚
â”‚     - Corpus analyse (scan wetgeving) ONMOGELIJK                     â”‚
â”‚     - Validatie van bestaande definities (check categorie) niet      â”‚
â”‚     - ServiceAdapter wordt GOD OBJECT                                â”‚
â”‚                                                                       â”‚
â”‚  ğŸ¯ USE CASE FIT:                                                     â”‚
â”‚     âœ… Scenario: Gebruiker genereert definitie (1 begrip)            â”‚
â”‚     âŒ Scenario: Batch classificatie (100 begrippen ZONDER generatie)â”‚
â”‚     âŒ Scenario: Validatie bestaande definities                      â”‚
â”‚     âŒ Scenario: Corpus analyse (verdeling categorieÃ«n)              â”‚
â”‚                                                                       â”‚
â”‚  ğŸ“Š SCORE: 2/5 - Te gekoppeld, beperkt herbruikbaarheid             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPTIE B: PRE-PROCESSING LAYER (aparte method)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚  UI â†’ ServiceAdapter.classify_begrip() â†’ ClassificationResult        â”‚
â”‚  UI â†’ ServiceAdapter.generate_definition(category=result)            â”‚
â”‚         â”œâ”€ 1. Build GenerationRequest (with category)                â”‚
â”‚         â””â”€ 2. Call orchestrator                                      â”‚
â”‚                                                                       â”‚
â”‚  âœ… PRO:                                                              â”‚
â”‚     - Classificatie is HERBRUIKBAAR (batch, validatie, analyse)      â”‚
â”‚     - Duidelijke separation of concerns                              â”‚
â”‚     - UI heeft controle over pre-processing pipeline                 â”‚
â”‚     - Caching mogelijk (classify once, reuse)                        â”‚
â”‚     - Expliciete pipeline: classify â†’ build request â†’ generate       â”‚
â”‚                                                                       â”‚
â”‚  âŒ CON:                                                              â”‚
â”‚     - UI moet 2 calls doen (meer boilerplate)                        â”‚
â”‚     - State management in UI (store ClassificationResult)            â”‚
â”‚     - Fout-handling op 2 niveaus                                     â”‚
â”‚                                                                       â”‚
â”‚  ğŸ¯ USE CASE FIT:                                                     â”‚
â”‚     âœ… Scenario: Gebruiker genereert definitie (classify eerst)      â”‚
â”‚     âœ… Scenario: Batch classificatie (100 begrippen ZONDER generatie)â”‚
â”‚     âœ… Scenario: Validatie bestaande definities                      â”‚
â”‚     âœ… Scenario: Corpus analyse (verdeling categorieÃ«n)              â”‚
â”‚     âœ… Scenario: Preview classificatie VOOR generatie (feedback)     â”‚
â”‚                                                                       â”‚
â”‚  ğŸ“Š SCORE: 5/5 - Maximale herbruikbaarheid, duidelijke pipeline      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPTIE C: DEDICATED CLASSIFIER SERVICE (DI)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚  UI â†’ OntologyClassifier.classify() â†’ ClassificationResult           â”‚
â”‚  UI â†’ DefinitionService.generate(category=result)                    â”‚
â”‚                                                                       â”‚
â”‚  âœ… PRO:                                                              â”‚
â”‚     - Maximale ontkoppeling (classifier = standalone)                â”‚
â”‚     - Direct DI via ServiceContainer                                 â”‚
â”‚     - Perfecte testbaarheid (mock classifier)                        â”‚
â”‚     - Classificatie kan OVERAL gebruikt worden                       â”‚
â”‚                                                                       â”‚
â”‚  âŒ CON:                                                              â”‚
â”‚     - UI heeft MEER verantwoordelijkheid (2 services te managen)     â”‚
â”‚     - Fout-handling complexer (2 aparte services)                    â”‚
â”‚     - Meer code in UI layer (orchestratie logic)                     â”‚
â”‚     - ServiceAdapter wordt bypassed (inconsistentie)                 â”‚
â”‚                                                                       â”‚
â”‚  ğŸ¯ USE CASE FIT:                                                     â”‚
â”‚     âœ… Scenario: Gebruiker genereert definitie                       â”‚
â”‚     âœ… Scenario: Batch classificatie                                 â”‚
â”‚     âœ… Scenario: Validatie bestaande definities                      â”‚
â”‚     âœ… Scenario: Corpus analyse                                      â”‚
â”‚     âŒ Scenario: Simpele UI (te veel boilerplate voor basic use)     â”‚
â”‚                                                                       â”‚
â”‚  ğŸ“Š SCORE: 4/5 - Beste ontkoppeling, maar meer UI complexity         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<p>---</p>

<h2>3. PROMPT DEPENDENCY ANALYSE</h2>

<h3>3.1 Hoe Gebruikt Orchestrator de Categorie?</h3>

<p><strong>Evidence:</strong> <code>SemanticCategorisationModule</code> (<code>src/services/prompts/modules/semantic_categorisation_module.py</code>)</p>

<pre><code>def _get_category_specific_guidance(self, categorie: str) -&gt; str | None:
    """Returns category-specific prompt sections."""
    category_guidance_map = {
        "proces": """**PROCES CATEGORIE - Focus op HANDELING en VERLOOP:**
        Gebruik formuleringen zoals:
        - 'is een activiteit waarbij...'
        - 'is het proces waarin...'
        âš ï¸ PROCES SPECIFIEKE RICHTLIJNEN:
        - Beschrijf WIE doet WAT en HOE het verloopt
        - Geef aan waar het proces BEGINT en EINDIGT""",

        "type": """**TYPE CATEGORIE - Focus op CLASSIFICATIE en KENMERKEN:**
        - 'is een soort...'
        - 'betreft een categorie van...'""",

        "resultaat": """**RESULTAAT CATEGORIE - Focus op OORSPRONG en GEVOLG:**
        - 'is het resultaat van...'
        - 'ontstaat door...'""",

        "exemplaar": """**EXEMPLAAR CATEGORIE - Focus op SPECIFICITEIT:**
        - 'is een specifiek exemplaar van...'
        - 'betreft een individueel geval van...'"""
    }</code></pre>

<p><strong>CONCRETE IMPACT:</strong></p>

<p>| Categorie | Prompt Aanpassingen | Token Overhead | Semantic Guidance |</p>
<p>|-----------|--------------------|-----------------|--------------------|</p>
<p>| <strong>PROCES</strong> | + 8-10 regels specifieke instructies | ~120 tokens | WIE/WAT/HOE/BEGIN/EINDE |</p>
<p>| <strong>TYPE</strong> | + 6-8 regels | ~90 tokens | CLASSIFICATIE/KENMERKEN |</p>
<p>| <strong>RESULTAAT</strong> | + 7-9 regels | ~105 tokens | OORSPRONG/GEVOLG/CAUSALITEIT |</p>
<p>| <strong>EXEMPLAAR</strong> | + 6-8 regels | ~95 tokens | SPECIFICITEIT/INDIVIDUALITEIT |</p>
<p>| <strong>Geen categorie</strong> | Basis instructies only | 0 extra tokens | Generieke guidance |</p>

<p><strong>CONCLUSION:</strong> Categorie heeft <strong>SIGNIFICANT</strong> invloed op:</p>
<ol>
<li>**Prompt structure** (verschillende templates)</li>
<li>**Token budget** (+90-120 tokens per categorie)</li>
<li>**Semantic guidance** (WIE/WAT vs. OORSPRONG/GEVOLG)</li>
<li>**LLM behavior** (actief vs. classificerend taalgebruik)</li>
</ol>

<p><strong>THEREFORE:</strong> Classificatie MOET pre-processing zijn - het is <strong>niet</strong> alleen metadata!</p>

<p>---</p>

<h2>4. HERBRUIKBAARHEID SCENARIO'S</h2>

<h3>Scenario 1: Batch Classificatie (100 begrippen ZONDER generatie)</h3>

<p><strong>Use Case:</strong> Gebruiker uploadt Excel met 100 begrippen + definities, wil alleen categorieÃ«n zien.</p>

<pre><code>OPTIE A (Service Layer):
âŒ PROBLEEM: Moet 100x generate_definition() aanroepen
âŒ GEVOLG: 100 AI calls voor definitie generatie (NIET NODIG)
âŒ KOSTEN: ~$5-10 (onnodige AI costs)
âŒ TIJD: ~5-10 minuten

OPTIE B (Pre-Processing Layer):
âœ… OPLOSSING: batch_classify_begrippen() â†’ List[ClassificationResult]
âœ… AI CALLS: 100 classificaties (ALLEEN wat nodig is)
âœ… KOSTEN: ~$0.50 (10x goedkoper)
âœ… TIJD: ~30-60 seconden

OPTIE C (Dedicated Service):
âœ… OPLOSSING: classifier.batch_classify(items)
âœ… IDENTIEK AAN OPTIE B</code></pre>

<p><strong>WINNER:</strong> Optie B of C (10x goedkoper, 10x sneller)</p>

<p>---</p>

<h3>Scenario 2: Validatie van Bestaande Definities</h3>

<p><strong>Use Case:</strong> Check of 500 bestaande definities juiste categorie hebben.</p>

<pre><code>OPTIE A (Service Layer):
âŒ PROBLEEM: Classificatie is GEKOPPELD aan generatie
âŒ GEVOLG: Kan alleen checken door NIEUWE definitie te genereren
âŒ USE CASE: ONMOGELIJK

OPTIE B (Pre-Processing Layer):
âœ… OPLOSSING:
    for definitie in database:
        result = classify_begrip(definitie.begrip, definitie.definitie)
        if result.level != definitie.ontologische_categorie:
            report_mismatch(definitie, result)

OPTIE C (Dedicated Service):
âœ… IDENTIEK AAN OPTIE B</code></pre>

<p><strong>WINNER:</strong> Optie B of C (Optie A kan dit niet)</p>

<p>---</p>

<h3>Scenario 3: Corpus Analyse (Verdeling categorieÃ«n in wetgeving)</h3>

<p><strong>Use Case:</strong> Analyseer 1000 begrippen uit wetgeving, genereer statistieken over verdeling TYPE/PROCES/RESULTAAT.</p>

<pre><code>OPTIE A (Service Layer):
âŒ PROBLEEM: Moet 1000 definities genereren (NIET NODIG)
âŒ GEVOLG: 1000 AI calls (1-2 uur processing)
âŒ USE CASE: PRAKTISCH ONMOGELIJK

OPTIE B (Pre-Processing Layer):
âœ… OPLOSSING:
    results = batch_classify_begrippen(corpus_items)
    stats = {
        "TYPE": sum(1 for r in results if r.level == "TYPE"),
        "PROCES": sum(1 for r in results if r.level == "PROCES"),
        ...
    }
âœ… TIJD: 5-10 minuten voor 1000 items

OPTIE C (Dedicated Service):
âœ… IDENTIEK AAN OPTIE B</code></pre>

<p><strong>WINNER:</strong> Optie B of C (Optie A is te traag)</p>

<p>---</p>

<h3>Scenario 4: Preview Classificatie VOOR Generatie</h3>

<p><strong>Use Case:</strong> Gebruiker ziet eerst classificatie resultaat, kan corrigeren VOOR definitie generatie.</p>

<pre><code>OPTIE A (Service Layer):
âŒ PROBLEEM: Classificatie gebeurt INSIDE generatie
âŒ GEVOLG: Geen preview mogelijk (hidden black box)

OPTIE B (Pre-Processing Layer):
âœ… FLOW:
    1. User: Input begrip + context
    2. App: Toon classificatie preview (category + confidence)
    3. User: Correct indien nodig (override)
    4. App: Generate definitie met correcte categorie
âœ… UX: Transparantie + controle

OPTIE C (Dedicated Service):
âœ… IDENTIEK AAN OPTIE B</code></pre>

<p><strong>WINNER:</strong> Optie B of C (betere UX)</p>

<p>---</p>

<h2>5. BEST PRACTICE AANBEVELING</h2>

<h3>ğŸ† RECOMMENDED PATTERN: **Pipeline Pattern met Pre-Processing Layer (Optie B)**</h3>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AANBEVOLEN ARCHITECTUUR                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ UI LAYER (Streamlit)                                    â”‚   â”‚
â”‚  â”‚  - Begrip input                                         â”‚   â”‚
â”‚  â”‚  - Context input                                        â”‚   â”‚
â”‚  â”‚  - [STAP 1] Classify button                             â”‚   â”‚
â”‚  â”‚  - [STAP 2] Preview classificatie (edit mogelijk)       â”‚   â”‚
â”‚  â”‚  - [STAP 3] Generate button                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚               â”‚                                                 â”‚
â”‚               â–¼                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ SERVICE ADAPTER (Facade)                                â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  classify_begrip(begrip, definitie, context)            â”‚   â”‚
â”‚  â”‚    â”œâ”€ Validate input                                    â”‚   â”‚
â”‚  â”‚    â”œâ”€ Call OntologyClassifier                           â”‚   â”‚
â”‚  â”‚    â””â”€ Return ClassificationResult                       â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  generate_definition(request: GenerationRequest)        â”‚   â”‚
â”‚  â”‚    â”œâ”€ Require: request.ontologische_categorie != None   â”‚   â”‚
â”‚  â”‚    â”œâ”€ Build prompt (uses category)                      â”‚   â”‚
â”‚  â”‚    â””â”€ Call orchestrator                                 â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  classify_and_generate(begrip, context, auto=True)      â”‚   â”‚
â”‚  â”‚    â”œâ”€ Step 1: classify_begrip()                         â”‚   â”‚
â”‚  â”‚    â”œâ”€ Step 2: build request                             â”‚   â”‚
â”‚  â”‚    â””â”€ Step 3: generate_definition()                     â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚               â”‚                                                 â”‚
â”‚               â–¼                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ OntologyClassifierâ”‚        â”‚ DefinitionOrchestratorV2    â”‚   â”‚
â”‚  â”‚ (DI via Container)â”‚        â”‚                             â”‚   â”‚
â”‚  â”‚  - classify()     â”‚        â”‚  - create_definition()      â”‚   â”‚
â”‚  â”‚  - batch_classify()â”‚        â”‚    (uses category in       â”‚   â”‚
â”‚  â”‚                   â”‚        â”‚     prompt building)        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<h3>5.1 Implementation Details</h3>

<h4>**ServiceAdapter Methods:**</h4>

<pre><code>class DefinitionServiceAdapter:
    """Facade voor definitie generatie met classificatie pre-processing."""

    def __init__(self, container: ServiceContainer):
        self.container = container
        self.classifier = container.ontology_classifier()
        self.orchestrator = container.definition_orchestrator_v2()

    # ==========================================
    # PRE-PROCESSING: Classificatie (standalone)
    # ==========================================

    def classify_begrip(
        self,
        begrip: str,
        definitie: str,
        context: Optional[str] = None,
        voorbeelden: Optional[List[str]] = None
    ) -&gt; ClassificationResult:
        """
        Classificeer begrip ZONDER definitie te genereren.

        Use cases:
        - Preview classificatie voor gebruiker
        - Batch classificatie (corpus analyse)
        - Validatie bestaande definities

        Args:
            begrip: Te classificeren begrip
            definitie: Definitie van begrip (voor context)
            context: Optionele extra context
            voorbeelden: Optionele voorbeeldzinnen

        Returns:
            ClassificationResult met level, confidence, rationale
        """
        logger.info(f"Classificatie pre-processing voor: {begrip}")

        result = self.classifier.classify(
            begrip=begrip,
            definitie=definitie,
            context=context,
            voorbeelden=voorbeelden
        )

        logger.info(f"Classificatie resultaat: {result.level} (confidence: {result.confidence:.0%})")
        return result

    def batch_classify_begrippen(
        self,
        items: List[Dict[str, str]]
    ) -&gt; List[ClassificationResult]:
        """
        Batch classificatie voor corpus analyse.

        Args:
            items: List van {"begrip": ..., "definitie": ..., "context": ...}

        Returns:
            List van ClassificationResult objecten
        """
        logger.info(f"Batch classificatie: {len(items)} begrippen")
        return self.classifier.classify_batch(items)

    # ==========================================
    # CORE: Definitie Generatie (requires category)
    # ==========================================

    async def generate_definition(
        self,
        request: GenerationRequest
    ) -&gt; DefinitionResponseV2:
        """
        Genereer definitie met VERPLICHTE ontologische categorie.

        Args:
            request: GenerationRequest met begrip + ontologische_categorie

        Raises:
            ValueError: Als ontologische_categorie ontbreekt

        Returns:
            DefinitionResponseV2
        """
        # VALIDATE: Category is required
        if not request.ontologische_categorie:
            raise ValueError(
                "ontologische_categorie is VERPLICHT. "
                "Roep eerst classify_begrip() aan om categorie te bepalen."
            )

        logger.info(
            f"Definitie generatie met category: {request.ontologische_categorie}"
        )

        return await self.orchestrator.create_definition(request)

    # ==========================================
    # CONVENIENCE: All-in-one (auto classify)
    # ==========================================

    async def classify_and_generate(
        self,
        begrip: str,
        context_dict: Dict[str, Any],
        auto_classify: bool = True,
        override_category: Optional[str] = None
    ) -&gt; Tuple[ClassificationResult, DefinitionResponseV2]:
        """
        Convenience method: classificeer + genereer in 1 call.

        Args:
            begrip: Te definiÃ«ren begrip
            context_dict: Context data (organisatorisch, juridisch, etc.)
            auto_classify: Automatisch classificeren (True) of override gebruiken
            override_category: Handmatige category override (optional)

        Returns:
            (ClassificationResult, DefinitionResponseV2)
        """
        # STEP 1: Classificatie (pre-processing)
        if override_category:
            # Mock result voor override scenario
            classification = ClassificationResult(
                level=override_category,
                confidence=1.0,
                rationale="Handmatig overschreven door gebruiker",
                linguistic_cues=[]
            )
        else:
            classification = self.classify_begrip(
                begrip=begrip,
                definitie="",  # Nog geen definitie (pre-processing!)
                context=context_dict.get("context")
            )

        # STEP 2: Build request met classificatie
        request = GenerationRequest(
            begrip=begrip,
            ontologische_categorie=classification.level,
            organisatorische_context=context_dict.get("organisatorisch", []),
            juridische_context=context_dict.get("juridisch", []),
            wettelijke_basis=context_dict.get("wettelijk", [])
        )

        # STEP 3: Generate definitie
        response = await self.generate_definition(request)

        return classification, response</code></pre>

<p>---</p>

<h3>5.2 UI Integration Example</h3>

<pre><code># src/ui/components/tabs/definitie_tab.py

class DefinitieGeneratieTab:
    """Tab voor definitie generatie met classificatie preview."""

    def __init__(self, container: ServiceContainer):
        self.adapter = DefinitionServiceAdapter(container)

    def render(self):
        st.header("Definitie Generatie")

        # INPUT SECTION
        begrip = st.text_input("Begrip")
        context = st.text_area("Context")

        # ==========================================
        # STAP 1: CLASSIFICATIE PRE-PROCESSING
        # ==========================================
        if st.button("ğŸ” Classificeer", key="classify_btn"):
            if not begrip:
                st.error("Begrip is verplicht")
                return

            with st.spinner("Classificeren..."):
                # Pre-processing: classify VOOR generatie
                result = self.adapter.classify_begrip(
                    begrip=begrip,
                    definitie="",  # Nog geen definitie
                    context=context
                )

                # Store in session state
                st.session_state.classification_result = result

        # ==========================================
        # STAP 2: CLASSIFICATIE PREVIEW &amp; OVERRIDE
        # ==========================================
        if "classification_result" in st.session_state:
            result = st.session_state.classification_result

            st.subheader("ğŸ“Š Classificatie Resultaat")

            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Categorie", result.level)
            with col2:
                st.metric("Confidence", f"{result.confidence:.0%}")
            with col3:
                st.metric("Warnings", len(result.validation_warnings))

            # TRANSPARENCY: Show rationale
            with st.expander("ğŸ” Rationale"):
                st.write(result.rationale)
                if result.linguistic_cues:
                    st.write("**Linguistic cues:**")
                    for cue in result.linguistic_cues:
                        st.write(f"- {cue}")

            # OVERRIDE OPTION
            st.write("**Override categorie (optioneel):**")
            override = st.selectbox(
                "Gebruik andere categorie",
                options=["Gebruik AI suggestie", "TYPE", "EXEMPLAAR",
                         "PROCES", "RESULTAAT"],
                index=0
            )

            if override != "Gebruik AI suggestie":
                st.session_state.override_category = override
                st.info(f"âœ“ Categorie overschreven naar: {override}")

        # ==========================================
        # STAP 3: DEFINITIE GENERATIE
        # ==========================================
        if st.button("âœ¨ Genereer Definitie", key="generate_btn"):
            if "classification_result" not in st.session_state:
                st.error("Classificeer eerst het begrip!")
                return

            # Get category (AI suggestie of override)
            category = st.session_state.get(
                "override_category",
                st.session_state.classification_result.level
            )

            with st.spinner("Genereren..."):
                # Build request met classificatie
                request = GenerationRequest(
                    begrip=begrip,
                    ontologische_categorie=category,
                    organisatorische_context=[context] if context else []
                )

                # Generate definitie
                response = await self.adapter.generate_definition(request)

                if response.success:
                    st.success("âœ“ Definitie gegenereerd!")
                    st.write(response.definition.definitie)
                else:
                    st.error(f"Fout: {response.error}")</code></pre>

<p>---</p>

<h3>5.3 Batch Processing Example</h3>

<pre><code># scripts/batch_classify_corpus.py

def batch_classify_wetgeving():
    """Classificeer 1000 begrippen uit wetgeving corpus."""

    # Load corpus
    corpus = load_wetgeving_corpus()  # 1000 begrippen

    # Prepare items
    items = [
        {
            "begrip": item["begrip"],
            "definitie": item["definitie"],
            "context": item.get("context")
        }
        for item in corpus
    ]

    # Batch classify (NO definition generation!)
    container = get_cached_container()
    adapter = DefinitionServiceAdapter(container)

    print(f"Classificeren {len(items)} begrippen...")
    results = adapter.batch_classify_begrippen(items)

    # Analyse verdeling
    stats = {
        "TYPE": sum(1 for r in results if r.level == "TYPE"),
        "EXEMPLAAR": sum(1 for r in results if r.level == "EXEMPLAAR"),
        "PROCES": sum(1 for r in results if r.level == "PROCES"),
        "RESULTAAT": sum(1 for r in results if r.level == "RESULTAAT"),
        "ONBESLIST": sum(1 for r in results if r.level == "ONBESLIST")
    }

    print("\nğŸ“Š Verdeling:")
    for category, count in stats.items():
        pct = count / len(results) * 100
        print(f"  {category:12} {count:4d} ({pct:5.1f}%)")

    # Export results
    export_classification_results(results, "wetgeving_classificaties.csv")</code></pre>

<p>---</p>

<h2>6. TRADE-OFFS SAMENVATTING</h2>

<p>| Aspect | Optie A (Service Layer) | Optie B (Pre-Processing) âœ… | Optie C (Dedicated Service) |</p>
<p>|--------|-------------------------|----------------------------|------------------------------|</p>
<p>| <strong>Herbruikbaarheid</strong> | âŒ Laag | âœ… Hoog | âœ… Hoog |</p>
<p>| <strong>UI Complexity</strong> | âœ… Simpel (1 call) | âš ï¸ Medium (2 calls) | âŒ Hoog (2 services) |</p>
<p>| <strong>Separation of Concerns</strong> | âŒ Gekoppeld | âœ… Gescheiden | âœ… Maximaal gescheiden |</p>
<p>| <strong>Batch Processing</strong> | âŒ Onmogelijk | âœ… EfficiÃ«nt | âœ… EfficiÃ«nt |</p>
<p>| <strong>Preview UX</strong> | âŒ Geen preview | âœ… Transparant | âœ… Transparant |</p>
<p>| <strong>Testbaarheid</strong> | âš ï¸ Moeilijk | âœ… Goed | âœ… Excellent |</p>
<p>| <strong>Corpus Analyse</strong> | âŒ Te traag | âœ… Haalbaar | âœ… Haalbaar |</p>
<p>| <strong>Validatie Bestaande</strong> | âŒ Onmogelijk | âœ… Mogelijk | âœ… Mogelijk |</p>
<p>| <strong>ServiceAdapter Rol</strong> | âŒ GOD OBJECT | âœ… Facade (clean) | âš ï¸ Bypassed |</p>

<p>---</p>

<h2>7. IMPLEMENTATION ROADMAP</h2>

<h3>Phase 1: Refactor ServiceAdapter (Week 1)</h3>

<pre><code>âœ“ Add classify_begrip() method
âœ“ Add batch_classify_begrippen() method
âœ“ Add validation: ontologische_categorie required in generate_definition()
âœ“ Add classify_and_generate() convenience method
âœ“ Update tests</code></pre>

<h3>Phase 2: UI Integration (Week 2)</h3>

<pre><code>âœ“ Update DefinitieGeneratieTab met 3-stappen flow
âœ“ Add classificatie preview component
âœ“ Add override option
âœ“ Update user flow documentation</code></pre>

<h3>Phase 3: Batch Processing (Week 3)</h3>

<pre><code>âœ“ Create scripts/batch_classify_corpus.py
âœ“ Add CSV export functionaliteit
âœ“ Create corpus analyse dashboard
âœ“ Performance optimization (parallel processing)</code></pre>

<h3>Phase 4: Validation & Monitoring (Week 4)</h3>

<pre><code>âœ“ Add classificatie accuracy monitoring
âœ“ Create misclassification detection
âœ“ Add feedback loop (learn from corrections)
âœ“ Performance metrics dashboard</code></pre>

<p>---</p>

<h2>8. CONCLUSION & DECISION</h2>

<h3>ğŸ† FINAL RECOMMENDATION: **Optie B - Pipeline Pattern met Pre-Processing Layer**</h3>

<p><strong>RATIONALE:</strong></p>

<ol>
<li>**âœ… Herbruikbaarheid:** Classificatie is standalone service, bruikbaar voor batch/validatie/analyse</li>
<li>**âœ… Separation of Concerns:** Duidelijke pipeline: classify â†’ build request â†’ generate</li>
<li>**âœ… UX Transparantie:** Gebruiker ziet classificatie VOOR generatie (preview + override)</li>
<li>**âœ… Efficiency:** Batch classificatie 10x goedkoper dan via generatie</li>
<li>**âœ… Testbaarheid:** Pre-processing stap is unit testable</li>
<li>**âœ… Maintainability:** ServiceAdapter blijft Facade (geen GOD OBJECT)</li>
</ol>

<p><strong>IMPLEMENTATION EFFORT:</strong></p>

<p>| Component | Effort | Priority |</p>
<p>|-----------|--------|----------|</p>
<p>| ServiceAdapter refactor | 4 uur | HIGH |</p>
<p>| UI integration (3-stappen flow) | 6 uur | HIGH |</p>
<p>| Batch processing scripts | 3 uur | MEDIUM |</p>
<p>| Tests + documentation | 4 uur | HIGH |</p>
<p>| <strong>TOTAL</strong> | <strong>17 uur</strong> (~2 dagen) | |</p>

<p><strong>RISKS:</strong></p>

<ul>
<li>âš ï¸ UI moet 2 calls doen (maar convenience method lost dit op)</li>
<li>âš ï¸ State management in UI (maar Streamlit session_state lost dit op)</li>
<li>âš ï¸ Backward compatibility (maar refactor lost dit op)</li>
</ul>

<p><strong>MITIGATIONS:</strong></p>

<ol>
<li>Add `classify_and_generate()` convenience method voor simpele use case</li>
<li>Add state management helpers in UI utilities</li>
<li>Add deprecation warnings voor oude API</li>
</ol>

<p>---</p>

<h2>9. STRATEGIC VALUE</h2>

<p><strong>Voor de organisatie:</strong></p>

<ul>
<li>**Cost Savings:** 10x goedkopere batch processing (â‚¬50 â†’ â‚¬5 voor 1000 classificaties)</li>
<li>**Time Savings:** 10x sneller (10 min â†’ 1 min voor 100 begrippen)</li>
<li>**Quality:** Preview + override â†’ betere accuracy</li>
<li>**Insights:** Corpus analyse mogelijk (verdeling TYPE/PROCES/RESULTAAT in wetgeving)</li>
</ul>

<p><strong>Voor developers:</strong></p>

<ul>
<li>**Clean Architecture:** Duidelijke separation of concerns</li>
<li>**Testability:** Pre-processing stap is unit testable</li>
<li>**Maintainability:** ServiceAdapter blijft Facade, geen GOD OBJECT</li>
<li>**Reusability:** Classificatie bruikbaar in alle scenario's</li>
</ul>

<p><strong>Voor gebruikers:</strong></p>

<ul>
<li>**Transparency:** Zie classificatie VOOR generatie</li>
<li>**Control:** Override optie voor AI suggesties</li>
<li>**Feedback:** Rationale + confidence scoring</li>
<li>**Speed:** Snellere batch operations</li>
</ul>

<p>---</p>

<h2>10. NEXT STEPS</h2>

<ol>
<li>**Decision:** Approve Optie B als strategic direction</li>
<li>**Planning:** Schedule 2-dag sprint voor implementation</li>
<li>**Design:** Review ServiceAdapter API met team</li>
<li>**Implementation:** Start met Phase 1 (ServiceAdapter refactor)</li>
<li>**Testing:** Unit + integration tests</li>
<li>**Documentation:** Update architecture docs + user guides</li>
<li>**Rollout:** Phased rollout met feature flag</li>
</ol>

<p>---</p>

<p><strong>END OF STRATEGIC ANALYSIS</strong></p>

<p><strong>Decision Required:</strong> Approve/Reject/Modify recommendation voor Optie B</p>

<p><strong>Next Document:</strong> Implementation Plan (indien approved)</p>

  </div>
</body>
</html>