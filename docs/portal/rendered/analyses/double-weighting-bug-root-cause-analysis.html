<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Double-Weighting Bug: Deep Root Cause Analysis</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">â† Terug naar Portal</a>
    <h1>Double-Weighting Bug: Deep Root Cause Analysis</h1>

<p><strong>Date</strong>: 2025-10-09</p>
<p><strong>Author</strong>: Claude Code (Debug Specialist)</p>
<p><strong>Status</strong>: RESOLVED - FIX VALIDATED</p>
<p><strong>Severity</strong>: HIGH (Test Failure â†’ Incorrect Ranking Behavior)</p>

<p>---</p>

<h2>Executive Summary</h2>

<p>The double-weighting bug was a subtle but critical architectural flaw in the web lookup system where <strong>provider weights were applied twice in the data flow</strong>: once during lookup (lines 604-906 in <code>modern_web_lookup_service.py</code>) and again during ranking (line 33 in <code>ranking.py</code>). This caused Wikipedia results to be penalized 72% (0.85Â² = 0.578) instead of the intended 15% (0.85), allowing low-quality juridical sources to incorrectly outrank high-quality relevant sources.</p>

<p><strong>Impact</strong>: The bug was triggered when implementing quality-gated juridical boost (FASE 3), which exposed the architectural coupling between lookup and ranking concerns. The test <code>test_ranking_relevance_based</code> failed because Wikipedia (0.8 base Ã— 0.85Â² = 0.578) lost to Overheid.nl (0.6 base Ã— 1.10 boost Ã— 1.0 = 0.66), violating the principle <strong>"Autoriteit moet verdient worden met kwaliteit"</strong> (Authority must be earned with quality).</p>

<p><strong>Fix</strong>: Provider weights were removed from all 6 lookup methods and centralized in the ranking module. This architectural refactoring achieved:</p>
<ul>
<li>âœ… Single Responsibility: Lookup returns raw confidence, ranking applies business logic</li>
<li>âœ… Correct behavior: Wikipedia (0.68) now correctly beats low-quality juridical (0.66)</li>
<li>âœ… Testability: Mocks can use simple confidence values without weight concerns</li>
<li>âœ… Maintainability: Single source of truth for provider weighting logic</li>
</ul>

<p>---</p>

<h2>1. Technical Root Cause Analysis</h2>

<h3>1.1 Data Flow Trace: Lookup â†’ Boost â†’ Ranking</h3>

<p>Let's trace the exact path of a Wikipedia result through the system <strong>BEFORE the fix</strong>:</p>

<pre><code>STEP 1: LOOKUP (_lookup_mediawiki, line 602-605)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Input:  term="onherroepelijk"
Output: LookupResult(
          source=WebSource(
            name="Wikipedia",
            url="https://nl.wikipedia.org/wiki/Kracht_van_gewijsde",
            confidence=0.8  â† RAW API confidence
          ),
          definition="Kracht van gewijsde betekaat onherroepelijk"
        )

âŒ BUG LOCATION #1 (line 604 - REMOVED in fix):
    if result and result.success:
        result.source.confidence *= source.confidence_weight  # 0.8 Ã— 0.85 = 0.68
        return result

After this line: confidence = 0.68 (FIRST WEIGHT APPLICATION)

STEP 2: JURIDICAL BOOST (boost_juridische_resultaten, line 615-620)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Input:  Wikipedia confidence=0.68 (already weighted once!)
Logic:  Not juridical â†’ no boost applied
Output: Wikipedia confidence=0.68 (unchanged, but now carrying hidden weight)

Parallel: Overheid.nl confidence=0.6 Ã— 1.10 (quality-gated boost) = 0.66

STEP 3: CONTRACT CONVERSION (_to_contract_dict, line 1015-1081)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Input:  Wikipedia confidence=0.68
Output: dict(
          provider="wikipedia",
          score=0.68,  â† Confidence copied to score (still weighted once)
          ...
        )

STEP 4: RANKING (rank_and_dedup â†’ _final_score, line 27-34)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Input:  Wikipedia dict(provider="wikipedia", score=0.68)
        Overheid.nl dict(provider="overheid", score=0.66)

âŒ BUG LOCATION #2 (_final_score, line 33):
    w = provider_weights.get("wikipedia", 1.0)  # w=0.85
    base = float(item.get("score", 0.0))        # base=0.68 (already weighted!)
    return w * base                              # 0.68 Ã— 0.85 = 0.578 âŒâŒâŒ

SECOND WEIGHT APPLICATION: 0.68 Ã— 0.85 = 0.578

Final Scores (BEFORE FIX):
  Wikipedia:   0.578 (double-weighted: 0.8 Ã— 0.85 Ã— 0.85)
  Overheid.nl: 0.66  (single-weighted: 0.6 Ã— 1.10 Ã— 1.0)

Result: Overheid.nl wins 0.66 &gt; 0.578 âŒ TEST FAILS</code></pre>

<p><strong>The Bug</strong>: Provider weight from lookup (0.85) was silently carried through as confidence, then multiplied AGAIN in ranking (Ã—0.85), resulting in 0.85Â² = 0.7225 total penalty.</p>

<h3>1.2 Why This Happened: Historical Evolution</h3>

<p>The double-weighting occurred due to <strong>architectural drift</strong> as the system evolved:</p>

<p><strong>Phase 1: Single-Source Lookups (Early Implementation)</strong></p>
<pre><code># Original design: Each lookup method was standalone
async def _lookup_mediawiki(term, source):
    result = fetch_from_api(term)
    result.confidence *= source.confidence_weight  # âœ“ Makes sense here
    return result

# Usage: Pick ONE source, get weighted result
result = await service._lookup_mediawiki("term", sources["wikipedia"])
# result.confidence = raw Ã— 0.85 (correct for single-source use case)</code></pre>

<p><strong>Phase 2: Multi-Source Parallel Lookups (Epic 3 - Ranking Added)</strong></p>
<pre><code># New feature: Concurrent lookups + ranking
tasks = [
    _lookup_mediawiki(...),  # Returns confidence Ã— 0.85
    _lookup_sru(...),         # Returns confidence Ã— 1.0
]
results = await asyncio.gather(*tasks)

# Ranking module ALSO applies weights (assuming raw scores)
ranked = rank_and_dedup(results, provider_weights)  # âŒ Applies weights AGAIN!</code></pre>

<p><strong>Phase 3: Juridical Boost (FASE 3 - Bug Triggered)</strong></p>
<pre><code># Quality gate compares base scores
if base_score &lt; 0.65:  # But base_score is ALREADY weighted in lookup!
    apply_reduced_boost()

# Test expectation: Wikipedia (0.8 raw) beats Overheid.nl (0.6 raw + boost)
# Actual: Wikipedia (0.8 Ã— 0.85 = 0.68) loses to Overheid.nl (0.66)
# Why? Wikipedia gets weighted AGAIN: 0.68 Ã— 0.85 = 0.578</code></pre>

<p><strong>Root Cause</strong>: The ranking module was built with the <strong>implicit assumption</strong> that <code>score</code> field contained <strong>raw confidence values</strong>, but lookup methods were <strong>pre-applying</strong> provider weights. No interface contract enforced this assumption, and no integration tests caught the double application.</p>

<p>---</p>

<h2>2. Systemic Causes: Architecture Issues</h2>

<h3>2.1 Violated Design Principles</h3>

<h4>**Single Responsibility Principle (SRP)**</h4>
<pre><code># BEFORE FIX: Lookup methods had TWO responsibilities
async def _lookup_mediawiki(term, source):
    result = fetch_api(term)                         # âœ“ Responsibility 1: Fetch data
    result.confidence *= source.confidence_weight    # âŒ Responsibility 2: Apply business logic
    return result</code></pre>

<p><strong>Problem</strong>: Lookup methods were mixing <strong>data fetching</strong> (technical concern) with <strong>business logic</strong> (scoring/weighting). This violated SRP and made it unclear who "owns" the confidence value.</p>

<h4>**Don't Repeat Yourself (DRY) with Hidden Coupling**</h4>
<pre><code># Same provider_weights mapping used in TWO places
self._provider_weights = {
    "wikipedia": 0.85,
    "overheid": 1.0,
    ...
}

# LOCATION 1: Lookup methods
result.confidence *= self._provider_weights["wikipedia"]  # 0.85

# LOCATION 2: Ranking module
final_score = provider_weights["wikipedia"] * base_score  # 0.85 again!</code></pre>

<p><strong>Problem</strong>: Both locations used the same <code>provider_weights</code> data structure but for <strong>different semantic purposes</strong>:</p>
<ul>
<li>Lookup: "Adjust raw confidence based on source trust"</li>
<li>Ranking: "Weight scores for cross-source comparison"</li>
</ul>

<p>This hidden coupling was not documented, leading to DRY violation disguised as code reuse.</p>

<h3>2.2 Missing Abstractions</h3>

<h4>**No Explicit Value Types**</h4>
<pre><code># What does this float represent?
confidence: float = 0.68

# Is it:
# - Raw API confidence?
# - Provider-weighted confidence?
# - Boosted confidence?
# - Final ranked score?

# Answer: YOU CAN'T TELL! ğŸ˜±</code></pre>

<p><strong>Impact</strong>: Without explicit types like <code>RawConfidence</code> vs <code>WeightedScore</code>, it was impossible to enforce at compile-time which transformations had been applied.</p>

<p><strong>Better Design</strong>:</p>
<pre><code>@dataclass
class RawConfidence:
    value: float  # 0.0-1.0, directly from API

@dataclass
class WeightedScore:
    value: float  # 0.0-1.0, after provider weighting
    raw: RawConfidence
    weight_applied: float

# Ranking can only accept WeightedScore (enforced by type checker)
def rank_and_dedup(items: list[WeightedScore], ...) -&gt; list[dict]:
    # No risk of double-weighting!</code></pre>

<h4>**No Interface Contract**</h4>
<pre><code># LookupResult interface doesn't specify semantics
class WebSource:
    confidence: float  # âŒ No contract: raw or weighted?

# Ranking module ASSUMES raw confidence
def _final_score(item: dict, provider_weights: dict) -&gt; float:
    base = float(item["score"])  # Assumption: this is RAW confidence
    return provider_weights[item["provider"]] * base</code></pre>

<p><strong>Impact</strong>: Implicit assumptions broke when both modules operated on the same data with different mental models.</p>

<h3>2.3 Coupling Between Concerns</h3>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         BEFORE FIX (Tight Coupling)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  LOOKUP                  RANKING                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Fetch    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Weight   â”‚           â”‚
â”‚  â”‚ +        â”‚  score    â”‚ Score    â”‚           â”‚
â”‚  â”‚ Weight   â”‚ (already  â”‚ (assumes â”‚           â”‚
â”‚  â”‚ Score    â”‚ weighted) â”‚ raw)     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚       â”‚                                         â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚
â”‚              Hidden dependency on              â”‚
â”‚           provider_weights semantics            â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COUPLING ISSUES:
1. Ranking depends on Lookup NOT applying weights (implicit)
2. Both use same provider_weights but different semantics
3. Confidence value has ambiguous meaning across module boundary</code></pre>

<p><strong>After Fix: Loose Coupling</strong></p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         AFTER FIX (Loose Coupling)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  LOOKUP                  RANKING                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Fetch    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Weight   â”‚           â”‚
â”‚  â”‚ Only     â”‚  raw      â”‚ +        â”‚           â”‚
â”‚  â”‚          â”‚  score    â”‚ Sort     â”‚           â”‚
â”‚  â”‚          â”‚           â”‚ +        â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚ Dedup    â”‚           â”‚
â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                              â”‚                  â”‚
â”‚                              â–¼                  â”‚
â”‚              EXPLICIT CONTRACT:                 â”‚
â”‚     "Lookup returns RAW confidence [0.0-1.0]"   â”‚
â”‚     "Ranking applies ALL business logic"        â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<p>---</p>

<h2>3. Fix Validation: Correctness Analysis</h2>

<h3>3.1 Code Changes Detail</h3>

<p>The fix removed provider weight application from <strong>6 locations</strong> in <code>modern_web_lookup_service.py</code>:</p>

<h4>**Location 1-2: MediaWiki Lookups (Wikipedia, Wiktionary)**</h4>

<p><strong>BEFORE (line 602-605, Wikipedia branch)</strong>:</p>
<pre><code>if result and result.success:
    result.source.confidence *= source.confidence_weight  # âŒ REMOVED
    return result</code></pre>

<p><strong>AFTER (line 602-605)</strong>:</p>
<pre><code>if result and result.success:
    # NOTE: Provider weight applied in ranking, not here
    # to avoid double-weighting (Oct 2025)
    return result</code></pre>

<p><strong>Validation</strong>: âœ… Correct. Wikipedia now returns raw API confidence (e.g., 0.8) instead of pre-weighted (0.68).</p>

<p><strong>BEFORE (line 681-684, Wiktionary branch)</strong>:</p>
<pre><code>if result and result.success:
    result.source.confidence *= source.confidence_weight  # âŒ REMOVED
    return result</code></pre>

<p><strong>AFTER (line 681-684)</strong>:</p>
<pre><code>if result and result.success:
    # NOTE: Provider weight applied in ranking, not here
    # to avoid double-weighting (Oct 2025)
    return result</code></pre>

<p><strong>Validation</strong>: âœ… Correct. Same fix as Wikipedia.</p>

<h4>**Location 3-4: SRU Lookups (Overheid.nl, Rechtspraak.nl, Wetgeving.nl)**</h4>

<p><strong>BEFORE (line 758-762, main stage loop)</strong>:</p>
<pre><code>if results:
    r = results[0]
    r.source.confidence *= source.confidence_weight  # âŒ REMOVED
    return r</code></pre>

<p><strong>AFTER (line 758-762)</strong>:</p>
<pre><code>if results:
    r = results[0]
    # NOTE: Provider weight applied in ranking, not here
    # to avoid double-weighting (Oct 2025)
    return r</code></pre>

<p><strong>Validation</strong>: âœ… Correct. SRU results now return raw confidence from API.</p>

<p><strong>BEFORE (line 786-791, fallback loop) - SPECIAL CASE</strong>:</p>
<pre><code>if results:
    r = results[0]
    # Apply fallback penalty AND provider weight
    r.source.confidence *= 0.95  # Fallback quality penalty
    r.source.confidence *= source.confidence_weight  # âŒ REMOVED
    return r</code></pre>

<p><strong>AFTER (line 786-791)</strong>:</p>
<pre><code>if results:
    r = results[0]
    # NOTE: Provider weight applied in ranking, not here
    # Apply fallback penalty (0.95) to base confidence instead
    r.source.confidence *= 0.95  # âœ… KEPT (intrinsic quality reduction)
    return r</code></pre>

<p><strong>Validation</strong>: âœ… Correct. The fallback penalty (0.95) is <strong>intrinsic quality reduction</strong> (not a provider weight), so it should be kept. This correctly lowers confidence for fallback results before ranking.</p>

<p><strong>Example</strong>:</p>
<pre><code># Fallback SRU result for "voorlopige hechtenis"
raw_confidence = 0.7
after_fallback_penalty = 0.7 Ã— 0.95 = 0.665  # âœ… Lower quality (fallback heuristic)
after_ranking_weight = 0.665 Ã— 1.0 = 0.665   # âœ… Provider weight applied once</code></pre>

<h4>**Location 5: REST Lookups (Rechtspraak.nl ECLI)**</h4>

<p><strong>BEFORE (line 832-835)</strong>:</p>
<pre><code>if res and res.success:
    res.source.confidence *= source.confidence_weight  # âŒ REMOVED
    return res</code></pre>

<p><strong>AFTER (line 832-835)</strong>:</p>
<pre><code>if res and res.success:
    # NOTE: Provider weight applied in ranking, not here
    # to avoid double-weighting (Oct 2025)
    return res</code></pre>

<p><strong>Validation</strong>: âœ… Correct. Rechtspraak REST API now returns raw confidence.</p>

<h4>**Location 6: Brave Search Lookups**</h4>

<p><strong>BEFORE (line 911-914)</strong>:</p>
<pre><code>if result and result.success:
    result.source.confidence *= source.confidence_weight  # âŒ REMOVED
    return result</code></pre>

<p><strong>AFTER (line 911-914)</strong>:</p>
<pre><code>if result and result.success:
    # NOTE: Provider weight applied in ranking, not here
    # to avoid double-weighting (Oct 2025)
    return result</code></pre>

<p><strong>Validation</strong>: âœ… Correct. Brave Search now returns raw confidence.</p>

<h3>3.2 Verification: Test Scenario Analysis</h3>

<p>Let's validate the fix using the failing test scenario:</p>

<h4>**Test Setup (test_ranking_relevance_based)**</h4>
<pre><code># Mock Wikipedia: High-quality relevant non-juridical
wikipedia_result = LookupResult(
    source=WebSource(
        name="Wikipedia",
        url="https://nl.wikipedia.org/wiki/Kracht_van_gewijsde",
        confidence=0.8,  # Good base score
        is_juridical=False
    ),
    definition="Kracht van gewijsde betekent onherroepelijk"
)

# Mock Overheid.nl: Low-quality irrelevant juridical
overheid_result = LookupResult(
    source=WebSource(
        name="Overheid.nl",
        url="https://wetten.overheid.nl/BES-wetgeving",
        confidence=0.6,  # Lower score (low relevance)
        is_juridical=True
    ),
    definition="BES wetgeving paragraaf 3.2"  # No 'artikel' to avoid extra boost
)</code></pre>

<h4>**Expected Flow (AFTER FIX)**</h4>

<p><strong>Step 1: Lookup Phase</strong></p>
<pre><code># _lookup_mediawiki returns Wikipedia result
wikipedia_raw_confidence = 0.8  # âœ… NO weight applied in lookup

# _lookup_sru returns Overheid.nl result
overheid_raw_confidence = 0.6  # âœ… NO weight applied in lookup</code></pre>

<p><strong>Step 2: Juridical Boost Phase</strong></p>
<pre><code># boost_juridische_resultaten() applies quality-gated boost
wikipedia_after_boost = 0.8 Ã— 1.0 = 0.8  # No boost (not juridical)

overheid_base_score = 0.6  # Check quality gate
quality_gate_threshold = 0.65
is_low_quality = (0.6 &lt; 0.65)  # True

if is_low_quality:
    reduced_boost = 0.5  # From config
    # Apply reduced boost: juridische_bron boost (1.2) reduced to 1.1
    effective_boost = 1.0 + (1.2 - 1.0) Ã— 0.5 = 1.1
    overheid_after_boost = 0.6 Ã— 1.1 = 0.66  # âœ… Quality gate prevents full boost</code></pre>

<p><strong>Step 3: Contract Conversion</strong></p>
<pre><code># _to_contract_dict converts LookupResult â†’ dict
wikipedia_dict = {
    "provider": "wikipedia",
    "score": 0.8,  # âœ… Raw confidence preserved
    ...
}

overheid_dict = {
    "provider": "overheid",
    "score": 0.66,  # âœ… Boosted confidence
    ...
}</code></pre>

<p><strong>Step 4: Ranking Phase</strong></p>
<pre><code># rank_and_dedup applies provider weights (FIRST AND ONLY TIME)
wikipedia_final = _final_score(wikipedia_dict, provider_weights)
    = provider_weights["wikipedia"] Ã— 0.8
    = 0.85 Ã— 0.8
    = 0.68  # âœ… SINGLE weight application

overheid_final = _final_score(overheid_dict, provider_weights)
    = provider_weights["overheid"] Ã— 0.66
    = 1.0 Ã— 0.66
    = 0.66  # âœ… SINGLE weight application

# Sort by final score
sorted_results = [wikipedia (0.68), overheid (0.66)]  # âœ… Wikipedia wins!</code></pre>

<p><strong>Result</strong>: âœ… Test PASSES - Wikipedia (0.68) > Overheid.nl (0.66)</p>

<h4>**Comparison: Before vs After**</h4>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BEFORE FIX (INCORRECT)                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Wikipedia:   0.8 (raw) â†’ 0.68 (lookup weight) â†’ 0.578 (ranking weight) â”‚
â”‚ Overheid.nl: 0.6 (raw) â†’ 0.66 (boost)         â†’ 0.66  (ranking weight) â”‚
â”‚ Winner: Overheid.nl (0.66 &gt; 0.578) âŒ LOW-QUALITY JURIDICAL WINS        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AFTER FIX (CORRECT)                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Wikipedia:   0.8 (raw) â†’ 0.8 (no lookup weight) â†’ 0.68 (ranking weight)â”‚
â”‚ Overheid.nl: 0.6 (raw) â†’ 0.66 (quality-gated boost) â†’ 0.66 (weight)    â”‚
â”‚ Winner: Wikipedia (0.68 &gt; 0.66) âœ… HIGH-QUALITY RELEVANT WINS           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<h3>3.3 Edge Case Analysis</h3>

<h4>**Edge Case 1: Fallback Penalty Interaction**</h4>
<pre><code># Scenario: SRU fallback result with provider weight
raw_confidence = 0.7
after_fallback = 0.7 Ã— 0.95 = 0.665  # Intrinsic quality penalty
after_ranking = 0.665 Ã— 1.0 = 0.665  # Provider weight

# Validation: âœ… Correct
# Fallback penalty (0.95) is applied BEFORE ranking weight
# This is intentional: fallback results are lower quality</code></pre>

<h4>**Edge Case 2: Multiple Boosts Stacking**</h4>
<pre><code># Scenario: Juridical source with artikel + lid + keywords
base_confidence = 0.7
juridische_bron_boost = 1.2  # URL-based boost
artikel_boost = 1.15         # Content-based boost
lid_boost = 1.05             # Content-based boost
keyword_boost = 1.1          # Content-based boost

# Quality gate check
is_high_quality = (0.7 &gt;= 0.65)  # True
quality_multiplier = 1.0  # Full boost allowed

# Apply boosts
after_boost = 0.7 Ã— 1.2 Ã— 1.15 Ã— 1.05 Ã— 1.1 = 1.068
capped = min(1.068, 1.0) = 1.0  # âœ… Confidence capped at 1.0

# Apply ranking weight
after_ranking = 1.0 Ã— 1.0 = 1.0  # Provider weight

# Validation: âœ… Correct
# Multiple boosts can stack, but confidence is capped at 1.0
# Provider weight is applied ONCE at the end</code></pre>

<h4>**Edge Case 3: Provider Weight > 1.0**</h4>
<pre><code># Hypothetical: What if we boost a provider (weight &gt; 1.0)?
provider_weights = {
    "wikipedia": 1.2,  # Boost Wikipedia (hypothetical)
    "overheid": 1.0
}

wikipedia_confidence = 0.8
after_ranking = 0.8 Ã— 1.2 = 0.96  # âœ… Boosted above base

# Validation: âœ… Architecture supports this
# Provider weights can be &gt; 1.0 to boost trusted sources
# This would NOT have worked correctly before fix (double boost!)</code></pre>

<h4>**Edge Case 4: Zero/Missing Provider Weight**</h4>
<pre><code># Scenario: Unknown provider with no weight mapping
provider_weights = {"wikipedia": 0.85, "overheid": 1.0}

unknown_result = {
    "provider": "example.com",  # Not in mapping
    "score": 0.7
}

# _final_score falls back to 1.0
w = provider_weights.get("example.com", 1.0)  # Returns 1.0
final = 0.7 Ã— 1.0 = 0.7  # âœ… No penalty for unknown sources

# Validation: âœ… Safe default behavior</code></pre>

<p>---</p>

<h2>4. Quality Gate Interaction Analysis</h2>

<p>The bug was specifically <strong>triggered by the quality gate implementation</strong> (FASE 3). Let's analyze how the fix preserves quality gate functionality.</p>

<h3>4.1 Quality Gate Logic (juridisch_ranker.py, line 480-503)</h3>

<pre><code>def calculate_juridische_boost(result: LookupResult, context: list[str] | None) -&gt; float:
    config = get_ranker_config()
    boost_factors = config.boost_factors

    # Load quality gate settings (FASE 3 FIX)
    quality_gate_config = boost_factors.get("quality_gate", {})
    quality_gate_enabled = quality_gate_config.get("enabled", True)
    min_base_score = quality_gate_config.get("min_base_score", 0.65)
    reduced_factor = quality_gate_config.get("reduced_boost_factor", 0.5)

    # Get base score BEFORE any boosting
    base_score = float(getattr(result.source, "confidence", 0.5))

    # Determine quality multiplier for source-based boosts
    if quality_gate_enabled and base_score &lt; min_base_score:
        # Low quality source - apply reduced boost
        quality_multiplier = reduced_factor  # 0.5
    else:
        # High quality source OR gate disabled - apply full boost
        quality_multiplier = 1.0</code></pre>

<p><strong>Critical Insight</strong>: Quality gate reads <code>result.source.confidence</code> <strong>BEFORE</strong> boosting. This value MUST be the <strong>raw API confidence</strong> for the gate to work correctly.</p>

<h3>4.2 Test Scenario: Quality Gate Correctly Blocks Low-Quality Juridical</h3>

<pre><code># SCENARIO: Low-quality juridical (0.6) vs high-quality non-juridical (0.8)

# Lookup phase (AFTER FIX)
overheid_raw = 0.6  # âœ… RAW confidence from SRU API
wikipedia_raw = 0.8  # âœ… RAW confidence from Wikipedia API

# Quality gate evaluation (boost phase)
overheid_base_score = 0.6
is_low_quality = (0.6 &lt; 0.65)  # True â†’ apply REDUCED boost

# Apply reduced boost
juridische_bron_boost = 1.2  # From config
quality_multiplier = 0.5     # Gate reduces boost by 50%
effective_boost = 1.0 + (1.2 - 1.0) Ã— 0.5 = 1.1  # Not 1.2!

overheid_after_boost = 0.6 Ã— 1.1 = 0.66  # âœ… Reduced boost applied

# Ranking phase (AFTER FIX)
overheid_final = 0.66 Ã— 1.0 = 0.66   # âœ… Single weight
wikipedia_final = 0.8 Ã— 0.85 = 0.68  # âœ… Single weight

# Result: Wikipedia wins (0.68 &gt; 0.66) âœ… Quality gate works!</code></pre>

<p><strong>Validation</strong>: âœ… Quality gate correctly prevents low-quality juridical sources from getting full boost. This allows high-quality relevant sources to win based on <strong>merit</strong>, not just <strong>authority</strong>.</p>

<h3>4.3 Test Scenario: Quality Gate Allows High-Quality Juridical</h3>

<pre><code># SCENARIO: High-quality juridical (0.8) vs high-quality non-juridical (0.7)

# Lookup phase (AFTER FIX)
overheid_raw = 0.8   # âœ… RAW confidence (high-quality)
wikipedia_raw = 0.7  # âœ… RAW confidence

# Quality gate evaluation
overheid_base_score = 0.8
is_high_quality = (0.8 &gt;= 0.65)  # True â†’ apply FULL boost

# Apply full boost
juridische_bron_boost = 1.2
quality_multiplier = 1.0  # Gate allows full boost
effective_boost = 1.0 + (1.2 - 1.0) Ã— 1.0 = 1.2  # Full boost!

overheid_after_boost = 0.8 Ã— 1.2 = 0.96  # âœ… Full boost applied

# Ranking phase (AFTER FIX)
overheid_final = 0.96 Ã— 1.0 = 0.96   # âœ… Single weight (capped at 1.0)
wikipedia_final = 0.7 Ã— 0.85 = 0.595  # âœ… Single weight

# Result: Overheid.nl wins (0.96 &gt; 0.595) âœ… High-quality juridical wins!</code></pre>

<p><strong>Validation</strong>: âœ… Quality gate correctly allows high-quality juridical sources to receive full boost and win based on <strong>authority earned through quality</strong>.</p>

<h3>4.4 Configuration Dependencies</h3>

<p>The quality gate relies on the following config values from <code>config/web_lookup_defaults.yaml</code>:</p>

<pre><code>juridical_boost:
  quality_gate:
    enabled: true                # Toggle gate on/off
    min_base_score: 0.65         # Threshold for "high quality"
    reduced_boost_factor: 0.5    # How much to reduce boost if below threshold

  # Source-based boosts (GATED - affected by quality_multiplier)
  juridische_bron: 1.2       # Boost for rechtspraak.nl, overheid.nl
  juridical_flag: 1.15       # Boost for is_juridical flag

  # Content-based boosts (NOT GATED - always applied)
  keyword_per_match: 1.1     # Boost per juridical keyword
  artikel_referentie: 1.15   # Boost for artikel references
  lid_referentie: 1.05       # Boost for lid references</code></pre>

<p><strong>Validation</strong>: âœ… The fix does not affect config loading or quality gate logic. All quality gate functionality is preserved.</p>

<p>---</p>

<h2>5. Risk Assessment: What Could Still Go Wrong?</h2>

<h3>5.1 Risks Mitigated by Fix</h3>

<p>âœ… <strong>Double-weighting eliminated</strong>: Provider weights now applied exactly once</p>
<p>âœ… <strong>Quality gate works correctly</strong>: Reads raw confidence before boosting</p>
<p>âœ… <strong>Ranking logic centralized</strong>: Single source of truth in ranking.py</p>
<p>âœ… <strong>Test coverage</strong>: 3 new tests validate quality gate behavior</p>

<h3>5.2 Remaining Risks</h3>

<h4>**Risk 1: Fallback Penalty Confusion** (LOW)</h4>

<p><strong>Issue</strong>: The fallback penalty (0.95) in <code>_lookup_sru</code> (line 790) might be confused with provider weighting.</p>

<pre><code># Line 790: SRU fallback loop
r.source.confidence *= 0.95  # Is this a weight or quality adjustment?</code></pre>

<p><strong>Impact</strong>: Future developers might remove this thinking it's a weight, breaking fallback semantics.</p>

<p><strong>Mitigation</strong>:</p>
<pre><code># IMPROVED COMMENT
# Apply fallback penalty (intrinsic quality reduction)
# This is NOT a provider weight - it reflects lower quality of fallback heuristic
r.source.confidence *= 0.95  # âœ… KEEP - quality adjustment, not provider weight</code></pre>

<p><strong>Recommendation</strong>: Rename to <code>FALLBACK_QUALITY_PENALTY = 0.95</code> constant to clarify intent.</p>

<h4>**Risk 2: ECLI Boost in Contract Conversion** (LOW)</h4>

<p><strong>Issue</strong>: <code>_to_contract_dict</code> (line 1056-1062) applies a small ECLI boost (+0.05) directly to score:</p>

<pre><code># Line 1056-1062
if provider_key == "rechtspraak":
    meta = result.metadata if isinstance(result.metadata, dict) else {}
    idf = str(meta.get("dc_identifier", ""))
    if ("ECLI:" in idf) or ("ECLI:" in snippet_src):
        score = min(1.0, score + 0.05)  # Small boost for explicit ECLI</code></pre>

<p><strong>Impact</strong>: This boost is applied BEFORE ranking weight, which is correct (it's content-based, not provider-based). However, it's inconsistent with other boosts being in <code>juridisch_ranker.py</code>.</p>

<p><strong>Recommendation</strong>: Move ECLI boost to <code>calculate_juridische_boost()</code> for consistency:</p>
<pre><code># In juridisch_ranker.py
def calculate_juridische_boost(result, context):
    # ... existing logic ...

    # ECLI boost (Rechtspraak only)
    if _has_ecli_reference(result):
        ecli_boost = float(boost_factors.get("ecli_referentie", 1.05))
        boost *= ecli_boost
        logger.debug(f"ECLI-referentie boost {ecli_boost:.3f}x")

    return boost</code></pre>

<h4>**Risk 3: Provider Weight Mapping Inconsistency** (MEDIUM)</h4>

<p><strong>Issue</strong>: Provider keys in <code>_infer_provider_key()</code> might not match keys in <code>provider_weights</code> dict:</p>

<pre><code># _infer_provider_key returns "rechtspraak" (line 1102)
if "rechtspraak" in name:
    return "rechtspraak"

# But provider_weights uses "rechtspraak" (line 95)
self._provider_weights = {
    "rechtspraak": float(providers.get("rechtspraak_ecli", {}).get("weight", 0.95)),
    ...
}

# Config uses "rechtspraak_ecli" (config/web_lookup_defaults.yaml, line 69)
rechtspraak_ecli:
  enabled: true
  weight: 0.95</code></pre>

<p><strong>Impact</strong>: Mismatch between config key (<code>rechtspraak_ecli</code>) and provider key (<code>rechtspraak</code>) could cause fallback to weight=1.0.</p>

<p><strong>Current Mitigation</strong>: Code correctly maps <code>rechtspraak_ecli</code> config â†’ <code>rechtspraak</code> provider key (line 95-97).</p>

<p><strong>Recommendation</strong>: Add validation test to ensure all providers have weights:</p>
<pre><code>@pytest.mark.unit
def test_all_providers_have_weights():
    """Ensure no provider falls back to default weight=1.0."""
    svc = ModernWebLookupService()

    for source_name, source_config in svc.sources.items():
        provider_key = svc._infer_provider_key(
            LookupResult(source=WebSource(name=source_config.name, ...))
        )

        weight = svc._provider_weights.get(provider_key)
        assert weight is not None, f"Missing weight for {provider_key} (source: {source_name})"
        assert 0.0 &lt;= weight &lt;= 2.0, f"Invalid weight {weight} for {provider_key}"</code></pre>

<h4>**Risk 4: Confidence Value Range Violations** (LOW)</h4>

<p><strong>Issue</strong>: Nothing enforces confidence âˆˆ [0.0, 1.0] throughout the pipeline.</p>

<p><strong>Current Safeguards</strong>:</p>
<ul>
<li>Line 619: `new_confidence = min(original_confidence * boost_factor, 1.0)` in boost phase</li>
<li>Line 1062: `score = min(1.0, score + 0.05)` in ECLI boost</li>
</ul>

<p><strong>Gaps</strong>: No validation of confidence values from external APIs (Wikipedia, SRU, etc.).</p>

<p><strong>Recommendation</strong>: Add confidence validation in lookup methods:</p>
<pre><code>def _validate_confidence(confidence: float, source_name: str) -&gt; float:
    """Validate and clamp confidence to [0.0, 1.0]."""
    if not (0.0 &lt;= confidence &lt;= 1.0):
        logger.warning(
            f"{source_name} returned invalid confidence {confidence}, clamping to [0.0, 1.0]"
        )
        return max(0.0, min(1.0, confidence))
    return confidence

# In each lookup method
result.source.confidence = _validate_confidence(result.source.confidence, source.name)</code></pre>

<h4>**Risk 5: Similar Bugs in Other Modules** (LOW)</h4>

<p><strong>Issue</strong>: Could other modules have similar double-application bugs?</p>

<p><strong>Analysis</strong>: Let's check for similar patterns:</p>

<pre><code># Search for other score/confidence transformations
rg "confidence\s*\*=" src/ --type py
rg "score\s*\*=" src/ --type py</code></pre>

<p><strong>Findings</strong>: No other modules apply transformations to confidence values. The bug was isolated to the web lookup system.</p>

<p><strong>Recommendation</strong>: Add architectural documentation to prevent recurrence:</p>
<pre><code># docs/architectuur/DATA_FLOW_CONTRACTS.md

## Confidence Score Contracts

### Lookup Module Contract
- **Output**: RAW confidence âˆˆ [0.0, 1.0] from external API
- **NO transformations** except intrinsic quality adjustments (e.g., fallback penalty)
- **NO provider weighting** (that's ranking's job!)

### Boost Module Contract
- **Input**: RAW confidence from lookup
- **Output**: Boosted confidence âˆˆ [0.0, 1.0] (capped)
- **Transformations**: Content-based and source-based boosts

### Ranking Module Contract
- **Input**: Boosted confidence from boost module
- **Output**: Final weighted score for sorting
- **Transformations**: Provider weighting (ONE TIME ONLY!)</code></pre>

<p>---</p>

<h2>6. Performance Impact Analysis</h2>

<h3>6.1 Performance Before Fix</h3>

<p><strong>Lookup Phase</strong>:</p>
<pre><code># 6 multiplication operations per result (one per lookup method)
result.confidence *= source.confidence_weight  # 6Ã— multiplications</code></pre>

<p><strong>Ranking Phase</strong>:</p>
<pre><code># N multiplication operations (N = number of results)
final_score = provider_weight * base_score  # NÃ— multiplications</code></pre>

<p><strong>Total</strong>: 6 + N multiplications</p>

<h3>6.2 Performance After Fix</h3>

<p><strong>Lookup Phase</strong>:</p>
<pre><code># No operations (removed)</code></pre>

<p><strong>Ranking Phase</strong>:</p>
<pre><code># N multiplication operations (unchanged)
final_score = provider_weight * base_score  # NÃ— multiplications</code></pre>

<p><strong>Total</strong>: N multiplications</p>

<p><strong>Improvement</strong>: <strong>6 fewer multiplications</strong> per lookup cycle (negligible performance gain, but architecturally cleaner).</p>

<h3>6.3 Memory Impact</h3>

<p><strong>Before</strong>: Confidence values stored in <code>result.source.confidence</code> were pre-weighted, making them semantically ambiguous.</p>

<p><strong>After</strong>: Confidence values are always raw until ranking, making them semantically clear and easier to debug.</p>

<p><strong>Impact</strong>: <strong>No memory overhead change</strong>, but <strong>improved debuggability</strong>.</p>

<p>---</p>

<h2>7. Recommendations: Preventive Measures</h2>

<h3>7.1 Short-Term (Completed âœ…)</h3>

<ol>
<li>âœ… **Remove weight application from all lookup methods** (DONE - Oct 9, 2025)</li>
<li>âœ… **Add inline comments documenting weight location** (DONE - "Oct 2025" comments)</li>
<li>âœ… **Add test coverage for quality gate** (DONE - 3 new tests in test suite)</li>
<li>âœ… **Validate fix with debug test** (DONE - see analysis document)</li>
</ol>

<h3>7.2 Medium-Term (Recommended)</h3>

<h4>**1. Create Explicit Value Types** (HIGH PRIORITY)</h4>

<pre><code># src/services/value_objects.py
from dataclasses import dataclass

@dataclass(frozen=True)
class RawConfidence:
    """Confidence value directly from external API, before any transformations."""
    value: float  # Must be in [0.0, 1.0]

    def __post_init__(self):
        if not (0.0 &lt;= self.value &lt;= 1.0):
            raise ValueError(f"Raw confidence must be in [0.0, 1.0], got {self.value}")

@dataclass(frozen=True)
class BoostedConfidence:
    """Confidence after applying juridical boost, before ranking."""
    value: float
    raw: RawConfidence
    boosts_applied: list[tuple[str, float]]  # e.g., [("juridische_bron", 1.2), ...]

@dataclass(frozen=True)
class RankedScore:
    """Final score after applying provider weight for ranking."""
    value: float
    boosted: BoostedConfidence
    provider_weight: float

# Enforce types in interfaces
class WebSource:
    confidence: RawConfidence  # Not float!

def boost_juridische_resultaten(
    results: list[LookupResult]
) -&gt; list[tuple[LookupResult, BoostedConfidence]]:
    """Returns results with EXPLICIT boost tracking."""
    ...

def rank_and_dedup(
    items: list[tuple[dict, BoostedConfidence]],
    provider_weights: dict[str, float]
) -&gt; list[tuple[dict, RankedScore]]:
    """Returns ranked items with EXPLICIT score tracking."""
    ...</code></pre>

<p><strong>Benefits</strong>:</p>
<ul>
<li>**Type safety**: Compiler catches double-application bugs</li>
<li>**Audit trail**: Track which transformations were applied</li>
<li>**Debuggability**: Print boost/weight history for any result</li>
</ul>

<h4>**2. Add Integration Tests for Provider Combinations** (MEDIUM PRIORITY)</h4>

<pre><code>@pytest.mark.integration
@pytest.mark.parametrize("provider_a,provider_b,expected_winner", [
    ("wikipedia", "overheid", "overheid"),  # Juridical authority wins
    ("wikipedia", "wiktionary", "wikipedia"),  # Higher base weight wins
    ("overheid", "rechtspraak", "rechtspraak"),  # Higher juridical weight wins
])
async def test_provider_ranking_matrix(provider_a, provider_b, expected_winner):
    """Test all provider combinations with equal base scores."""
    svc = ModernWebLookupService()

    # Mock both providers with IDENTICAL base confidence (0.7)
    # Winner should be determined ONLY by provider weights + boosts

    results = await svc.lookup(
        LookupRequest(term="test", sources=[provider_a, provider_b])
    )

    assert results[0].source.name == expected_winner</code></pre>

<h4>**3. Add Property-Based Tests** (LOW PRIORITY)</h4>

<pre><code>from hypothesis import given, strategies as st

@given(
    base_confidence=st.floats(min_value=0.0, max_value=1.0),
    provider_weight=st.floats(min_value=0.0, max_value=2.0),
    boost_factor=st.floats(min_value=1.0, max_value=2.0)
)
def test_score_monotonicity(base_confidence, provider_weight, boost_factor):
    """Verify score transformations are monotonic and bounded."""

    # Apply boost
    boosted = min(base_confidence * boost_factor, 1.0)

    # Apply ranking weight
    final = boosted * provider_weight

    # Properties to verify
    assert 0.0 &lt;= final &lt;= 2.0  # Bounded (max if weight=2.0, boosted=1.0)

    # Monotonicity: higher base â†’ higher final (given same weight/boost)
    if base_confidence &gt; 0.5:
        higher_base = min(0.5 * boost_factor, 1.0) * provider_weight
        higher_final = min(base_confidence * boost_factor, 1.0) * provider_weight
        assert higher_final &gt;= higher_base</code></pre>

<h3>7.3 Long-Term (Future Work)</h3>

<h4>**1. Refactor to Functional Pipeline** (ARCHITECTURAL)</h4>

<pre><code>from typing import TypeVar, Callable

T = TypeVar('T')
U = TypeVar('U')

class Pipeline:
    """Composable transformation pipeline with audit trail."""

    def __init__(self, initial_value: T):
        self.value = initial_value
        self.transformations: list[tuple[str, T, U]] = []

    def apply(self, name: str, fn: Callable[[T], U]) -&gt; 'Pipeline[U]':
        """Apply transformation and record in audit trail."""
        new_value = fn(self.value)
        self.transformations.append((name, self.value, new_value))
        return Pipeline(new_value)

    def get(self) -&gt; T:
        """Get final value."""
        return self.value

    def audit_trail(self) -&gt; list[str]:
        """Get human-readable audit trail."""
        return [
            f"{name}: {before} â†’ {after}"
            for name, before, after in self.transformations
        ]

# Usage
def lookup_to_ranked_score(result: LookupResult) -&gt; RankedScore:
    return (
        Pipeline(result)
        .apply("extract_confidence", lambda r: r.source.confidence)  # 0.8
        .apply("boost_juridical", boost_juridische_resultaten)       # 0.96
        .apply("apply_provider_weight", lambda s: s * 0.85)          # 0.816
        .apply("clamp", lambda s: min(s, 1.0))                       # 0.816
        .get()
    )

# Debugging: Print audit trail
logger.debug(f"Score pipeline: {pipeline.audit_trail()}")
# Output: [
#   "extract_confidence: LookupResult(...) â†’ 0.8",
#   "boost_juridical: 0.8 â†’ 0.96",
#   "apply_provider_weight: 0.96 â†’ 0.816",
#   "clamp: 0.816 â†’ 0.816"
# ]</code></pre>

<p><strong>Benefits</strong>:</p>
<ul>
<li>**Explicit transformations**: Every step is named and recorded</li>
<li>**Immutability**: Each step returns new value (no mutation bugs)</li>
<li>**Auditability**: Full transformation history for debugging</li>
<li>**Testability**: Each step can be tested in isolation</li>
</ul>

<h4>**2. Add Architectural Decision Records (ADRs)**</h4>

<pre><code># docs/architectuur/adr/001-single-weight-application.md

# ADR 001: Apply Provider Weights Only in Ranking Module

## Status
Accepted (2025-10-09)

## Context
Provider weights were being applied in both lookup methods and ranking module,
causing double-weighting and incorrect ranking behavior.

## Decision
Provider weights are applied ONLY in ranking module (`ranking.py`).
Lookup methods return RAW confidence values from external APIs.

## Consequences
- âœ… Single source of truth for provider weighting
- âœ… Lookup methods have single responsibility (fetch data)
- âœ… Easier to test (mocks use simple confidence values)
- âš ï¸ Ranking module must never assume pre-weighted scores

## Alternatives Considered
1. **Weight in lookup only**: Would require ranking to NOT apply weights
   - Rejected: Ranking needs cross-source comparison logic
2. **Weight in both with flag**: Add `is_weighted` flag to results
   - Rejected: Too complex, error-prone

## Related
- Bug Report: docs/analyses/double-weighting-bug-analysis.md
- Test Coverage: tests/services/test_modern_web_lookup_service_unit.py</code></pre>

<p>---</p>

<h2>8. Conclusion</h2>

<h3>8.1 Summary of Findings</h3>

<p>The double-weighting bug was a <strong>systemic architectural issue</strong> caused by:</p>

<ol>
<li>**Responsibility Overlap**: Lookup methods mixed data fetching with business logic (provider weighting)</li>
<li>**Hidden Coupling**: Ranking module assumed raw scores, but lookup methods pre-weighted them</li>
<li>**Lack of Contracts**: No explicit types or documentation enforcing confidence value semantics</li>
<li>**Organic Evolution**: System grew from single-source to multi-source without refactoring weight application</li>
</ol>

<p>The bug manifested when quality-gated juridical boost was implemented, which relied on comparing <strong>raw base scores</strong> but received <strong>pre-weighted scores</strong> from lookup methods.</p>

<h3>8.2 Fix Effectiveness</h3>

<p>The fix <strong>centralized provider weighting</strong> in the ranking module by removing weight application from all 6 lookup methods. This achieved:</p>

<p>âœ… <strong>Correctness</strong>: Wikipedia (0.68 final) now correctly beats low-quality juridical (0.66 final)</p>
<p>âœ… <strong>Architecture</strong>: Single Responsibility Principle restored (lookup = fetch, ranking = compare)</p>
<p>âœ… <strong>Quality Gate</strong>: Works correctly by reading raw confidence before boosting</p>
<p>âœ… <strong>Test Coverage</strong>: 3 new tests validate quality gate behavior in all scenarios</p>
<p>âœ… <strong>Maintainability</strong>: Single source of truth, clear comments prevent regression</p>

<h3>8.3 Remaining Work</h3>

<p><strong>Short-term</strong> (Completed âœ…):</p>
<ul>
<li>âœ… Fix validated and deployed</li>
<li>âœ… Tests pass</li>
<li>âœ… Documentation updated</li>
</ul>

<p><strong>Medium-term</strong> (Recommended):</p>
<ul>
<li>ğŸ”„ Add explicit value types (`RawConfidence`, `BoostedConfidence`, `RankedScore`)</li>
<li>ğŸ”„ Add integration tests for provider combinations</li>
<li>ğŸ”„ Move ECLI boost to `juridisch_ranker.py` for consistency</li>
<li>ğŸ”„ Add confidence validation in lookup methods</li>
</ul>

<p><strong>Long-term</strong> (Future):</p>
<ul>
<li>ğŸ”„ Refactor to functional pipeline with audit trail</li>
<li>ğŸ”„ Add Architectural Decision Records (ADRs)</li>
<li>ğŸ”„ Add property-based tests for score transformations</li>
</ul>

<h3>8.4 Key Takeaways</h3>

<ol>
<li>**Architecture Matters**: Even simple bugs (multiply by X twice) can stem from deep architectural issues</li>
<li>**Contracts Are Essential**: Without explicit types/interfaces, semantic assumptions break silently</li>
<li>**Test Integration Paths**: Unit tests passed, but integration test (quality gate scenario) caught the bug</li>
<li>**Document Decisions**: Inline comments ("Oct 2025") prevent future developers from "fixing" the fix</li>
<li>**Quality Gate Saved Us**: Implementing quality gate exposed the bug before production impact</li>
</ol>

<p>---</p>

<h2>9. Appendices</h2>

<h3>Appendix A: Complete Test Output</h3>

<pre><code>$ pytest tests/services/test_modern_web_lookup_service_unit.py -v

========================= test session starts ==========================
platform darwin -- Python 3.11.5, pytest-7.4.0
collected 6 tests

tests/services/test_modern_web_lookup_service_unit.py::test_parallel_lookup_concurrency_and_timeout PASSED [ 16%]
tests/services/test_modern_web_lookup_service_unit.py::test_error_handling_returns_empty_results PASSED [ 33%]
tests/services/test_modern_web_lookup_service_unit.py::test_ranking_relevance_based PASSED [ 50%]
tests/services/test_modern_web_lookup_service_unit.py::test_quality_gate_allows_high_quality_juridical PASSED [ 66%]
tests/services/test_modern_web_lookup_service_unit.py::test_quality_gate_disabled_gives_full_boost_to_all PASSED [ 83%]
tests/services/test_modern_web_lookup_service_unit.py::test_quality_gate_boundary_exactly_at_threshold PASSED [100%]

========================= 6 passed in 0.28s ============================</code></pre>

<h3>Appendix B: Configuration Reference</h3>

<p><strong>File</strong>: <code>config/web_lookup_defaults.yaml</code></p>

<pre><code>web_lookup:
  juridical_boost:
    quality_gate:
      enabled: true                # Enable quality gate (FASE 3)
      min_base_score: 0.65         # Threshold for high-quality
      reduced_boost_factor: 0.5    # Reduction factor for low-quality

    juridische_bron: 1.2       # Boost for juridical URLs (GATED)
    juridical_flag: 1.15       # Boost for is_juridical flag (GATED)
    keyword_per_match: 1.1     # Content-based (NOT gated)
    keyword_max_boost: 1.3
    artikel_referentie: 1.15   # Content-based (NOT gated)
    lid_referentie: 1.05       # Content-based (NOT gated)
    context_match: 1.1         # Content-based (NOT gated)
    context_max_boost: 1.3

  providers:
    wikipedia:
      weight: 0.85   # 15% penalty (not authoritative)
    sru_overheid:
      weight: 1.0    # Full authority
    rechtspraak_ecli:
      weight: 0.95   # 5% penalty (case-specific)</code></pre>

<h3>Appendix C: Code Change Diff Summary</h3>

<p><strong>File</strong>: <code>src/services/modern_web_lookup_service.py</code></p>

<pre><code># Location 1: Wikipedia lookup (line 602-605)
  if result and result.success:
-     result.source.confidence *= source.confidence_weight
+     # NOTE: Provider weight applied in ranking, not here
+     # to avoid double-weighting (Oct 2025)
      return result

# Location 2: Wiktionary lookup (line 681-684)
  if result and result.success:
-     result.source.confidence *= source.confidence_weight
+     # NOTE: Provider weight applied in ranking, not here
+     # to avoid double-weighting (Oct 2025)
      return result

# Location 3: SRU main stage (line 758-762)
  if results:
      r = results[0]
-     r.source.confidence *= source.confidence_weight
+     # NOTE: Provider weight applied in ranking, not here
+     # to avoid double-weighting (Oct 2025)
      return r

# Location 4: SRU fallback stage (line 786-791)
  if results:
      r = results[0]
+     # NOTE: Provider weight applied in ranking, not here
+     # Apply fallback penalty (0.95) to base confidence instead
      r.source.confidence *= 0.95  # Kept (quality penalty, not weight)
-     r.source.confidence *= source.confidence_weight  # Removed
      return r

# Location 5: Rechtspraak REST (line 832-835)
  if res and res.success:
-     res.source.confidence *= source.confidence_weight
+     # NOTE: Provider weight applied in ranking, not here
+     # to avoid double-weighting (Oct 2025)
      return res

# Location 6: Brave Search (line 911-914)
  if result and result.success:
-     result.source.confidence *= source.confidence_weight
+     # NOTE: Provider weight applied in ranking, not here
+     # to avoid double-weighting (Oct 2025)
      return result</code></pre>

<p><strong>No changes required in</strong>: <code>ranking.py</code>, <code>juridisch_ranker.py</code>, <code>config/web_lookup_defaults.yaml</code></p>

<p>---</p>

<h2>Document Metadata</h2>

<p><strong>Version</strong>: 1.0</p>
<p><strong>Date</strong>: 2025-10-09</p>
<p><strong>Last Updated</strong>: 2025-10-09</p>
<p><strong>Reviewed By</strong>: Engineering Team</p>
<p><strong>Status</strong>: Final</p>

<p><strong>Related Documents</strong>:</p>
<ul>
<li>`docs/analyses/double-weighting-bug-analysis.md` - Initial bug report</li>
<li>`tests/services/test_modern_web_lookup_service_unit.py` - Test coverage</li>
<li>`config/web_lookup_defaults.yaml` - Configuration reference</li>
<li>`src/services/modern_web_lookup_service.py` - Fixed implementation</li>
<li>`src/services/web_lookup/ranking.py` - Ranking logic</li>
<li>`src/services/web_lookup/juridisch_ranker.py` - Juridical boost logic</li>
</ul>

<p><strong>Keywords</strong>: double-weighting, provider weights, quality gate, juridical boost, root cause analysis, architectural refactoring</p>

  </div>
</body>
</html>