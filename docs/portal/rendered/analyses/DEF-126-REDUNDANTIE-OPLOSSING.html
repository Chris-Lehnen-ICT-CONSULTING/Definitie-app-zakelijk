<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DEF-126: Oplossing voor Redundante Instructies</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <h1>DEF-126: Oplossing voor Redundante Instructies</h1>

<h2>Probleem Analyse</h2>

<h3>1. Context Redundantie (3x dezelfde instructie)</h3>

<p><strong>Huidige situatie:</strong></p>
<pre><code>Regel 64: ContextAwarenessModule (rich context &gt;= 0.8)
  ‚Üí "Gebruik onderstaande context om de definitie specifiek te maken..."

Regel 242: ContextAwarenessModule (moderate context 0.5-0.8)
  ‚Üí "Gebruik onderstaande context om de definitie specifiek te maken..."

Regel 204: Context verwerkt zonder expliciete benoeming
  ‚Üí In de checklist</code></pre>

<p><strong>Oorzaak:</strong> <code>ContextAwarenessModule</code> genereert verschillende secties gebaseerd op context score, maar herhaalt dezelfde instructie.</p>

<h3>2. Ontologische Categorie Redundantie (4x overlappende instructies)</h3>

<p><strong>Huidige situatie:</strong></p>
<pre><code>ExpertiseModule (regel 3):
  ‚Üí "Als het begrip een resultaat is, beschrijf het dan als uitkomst van een proces"
  ‚Üí Gebaseerd op "woordsoort" (werkwoord/deverbaal/overig)

SemanticCategorisationModule (regels 70-116):
  ‚Üí Uitgebreide ESS-02 instructies voor 4 categorie√´n
  ‚Üí Gebaseerd op "ontologische_categorie" (type/proces/resultaat/exemplaar)

TemplateModule (regels 117-131):
  ‚Üí Templates per categorie
  ‚Üí Gebruikt beide: word_type EN semantic_category

DefinitionTaskModule (regel 395):
  ‚Üí "Focus: Dit is een **type** (soort/categorie)"
  ‚Üí Herhaalt categorie informatie</code></pre>

<p><strong>Probleem:</strong> Meerdere modules proberen hetzelfde te bepalen:</p>
<ul>
<li>"deverbaal" (ExpertiseModule) ‚âà "resultaat" (SemanticCategorisationModule)</li>
<li>"werkwoord" (ExpertiseModule) ‚âà "proces" (SemanticCategorisationModule)</li>
</ul>

<h2>Voorgestelde Oplossing</h2>

<h3>Principe: Single Source of Truth per Concern</h3>

<pre><code>graph TD
    A[Ontologische Categorie] --&gt;|Single Source| B[SemanticCategorisationModule]
    C[Context Instructie] --&gt;|Single Source| D[ContextAwarenessModule]

    B --&gt; E[Shared State]
    D --&gt; E

    E --&gt; F[TemplateModule]
    E --&gt; G[DefinitionTaskModule]
    E --&gt; H[ExpertiseModule]

    style B fill:#90EE90
    style D fill:#90EE90</code></pre>

<h3>Implementatie Aanpassingen</h3>

<h4>1. ContextAwarenessModule - E√©n Context Instructie</h4>

<pre><code>class ContextAwarenessModule(BasePromptModule):
    def execute(self, context: ModuleContext) -&gt; ModuleOutput:
        # Bereken context score
        context_score = self._calculate_context_score(context.enriched_context)

        # NIEUW: Slechts √©√©n keer de instructie, aanpassing in formatting
        if context_score &gt; 0.0:
            content = self._build_unified_context_section(context, context_score)
        else:
            content = "üìç Context: Geen specifieke context beschikbaar."

    def _build_unified_context_section(self, context, score):
        """√â√©n uniforme context sectie, formatting varieert op score."""
        sections = []

        # E√©n keer de instructie
        sections.append("üìå VERPLICHTE CONTEXT INFORMATIE:")
        sections.append(
            "‚ö†Ô∏è Gebruik onderstaande context om de definitie specifiek te maken "
            "voor deze setting, zonder de context expliciet te benoemen."
        )

        # Varieer alleen de PRESENTATIE op basis van score
        if score &gt;= 0.8:
            # Rich: Gedetailleerde context met categorie√´n
            sections.extend(self._format_detailed_context(context))
        elif score &gt;= 0.5:
            # Moderate: Standaard context
            sections.extend(self._format_standard_context(context))
        else:
            # Minimal: Compacte context
            sections.extend(self._format_compact_context(context))

        return "\n".join(sections)</code></pre>

<h4>2. ExpertiseModule - Geen Categorie Advies Meer</h4>

<pre><code>class ExpertiseModule(BasePromptModule):
    def execute(self, context: ModuleContext) -&gt; ModuleOutput:
        # Bouw alleen expert rol en basis vereisten
        sections = []
        sections.append(self._build_role_definition())
        sections.append(self._build_task_instruction())
        # VERWIJDER: word_type_advice - dit is verantwoordelijkheid van SemanticCategorisationModule
        sections.append(self._build_basic_requirements())

        return ModuleOutput(content="\n".join(sections))</code></pre>

<h4>3. SemanticCategorisationModule - Primaire Categorie Owner</h4>

<pre><code>class SemanticCategorisationModule(BasePromptModule):
    def execute(self, context: ModuleContext) -&gt; ModuleOutput:
        # Deze module is DE bron voor ontologische categorie
        categorie = self._determine_category(context)

        # Sla op voor ALLE andere modules
        context.set_shared("ontological_category", categorie)
        context.set_shared("category_instruction", self._get_single_instruction(categorie))

        # Genereer EENMALIG de juiste instructie
        content = self._build_category_specific_section(categorie)
        return ModuleOutput(content=content)

    def _determine_category(self, context):
        """Intelligente categorie bepaling op basis van begrip."""
        begrip = context.begrip.lower()

        # Check metadata eerst (UI/user override)
        if context.get_metadata("ontologische_categorie"):
            return context.get_metadata("ontologische_categorie")

        # Anders: Intelligente detectie
        if begrip.endswith(("ing", "atie", "isatie", "tie")):
            # Kan proces OF resultaat zijn
            if self._is_process_word(begrip):
                return "proces"
            else:
                return "resultaat"
        elif begrip.endswith("aar") or "persoon" in begrip:
            return "type"  # Actor type
        else:
            return "type"  # Default</code></pre>

<h4>4. TemplateModule - Gebruik Alleen Shared State</h4>

<pre><code>class TemplateModule(BasePromptModule):
    def execute(self, context: ModuleContext) -&gt; ModuleOutput:
        # Gebruik ALLEEN de gedeelde categorie
        category = context.get_shared("ontological_category", "type")

        # Geen eigen bepaling meer!
        template = self._get_category_template(category)
        # ...</code></pre>

<h4>5. DefinitionTaskModule - Geen Herhaling</h4>

<pre><code>class DefinitionTaskModule(BasePromptModule):
    def _build_checklist(self, ontological_category: str | None) -&gt; str:
        # Gebruik de instructie uit shared state, NIET opnieuw genereren
        category_instruction = context.get_shared("category_instruction", "")

        return f"""üìã **CONSTRUCTIE GUIDE:**
‚Üí Begint met zelfstandig naamwoord
‚Üí E√©n enkele zin zonder punt
‚Üí {category_instruction}  # Gebruik de GEDEELDE instructie
‚Üí Context verwerkt zonder expliciete benoeming"""</code></pre>

<h3>Configuratie voor Conditional Loading</h3>

<pre><code># config/module_activation_rules.yaml
activation_rules:
  semantic_categorisation:
    # Deze module bepaalt ALTIJD de categorie
    always_active: true
    priority: 95  # Heel vroeg, zodat andere modules kunnen gebruiken

  expertise:
    # Alleen basis rol, geen categorie advies
    provides: ["role_definition", "basic_requirements"]
    NOT_provides: ["word_type_advice"]  # Deprecated

  template:
    # Alleen actief als categorie bekend is
    requires: ["ontological_category"]
    active_when: "context.get_shared('ontological_category') is not None"

  context_awareness:
    # Adaptieve activatie op context score
    modes:
      - minimal: "score &lt; 0.3"  # Skip module entirely
      - compact: "0.3 &lt;= score &lt; 0.5"
      - standard: "0.5 &lt;= score &lt; 0.8"
      - rich: "score &gt;= 0.8"</code></pre>

<h2>Resultaat na Implementatie</h2>

<h3>Voorheen (423 regels):</h3>
<ul>
<li>3x context instructie</li>
<li>4x overlappende categorie instructies</li>
<li>Inconsistente terminologie (deverbaal vs resultaat)</li>
<li>Modules die elkaars werk herhalen</li>
</ul>

<h3>Na implementatie (~350 regels geschat):</h3>
<ul>
<li>1x context instructie (adaptieve formatting)</li>
<li>1x categorie instructie (single source)</li>
<li>Consistente terminologie</li>
<li>Heldere module verantwoordelijkheden</li>
</ul>

<h3>Concrete Winst:</h3>
<ol>
<li>**-73 regels** (17% reductie)</li>
<li>**Consistentere prompts**</li>
<li>**Makkelijker te onderhouden**</li>
<li>**Snellere generatie** (minder tokens)</li>
</ol>

<h2>Implementatie Stappen</h2>

<ol>
<li>**Refactor ContextAwarenessModule**</li>
</ol>
<ul>
<li>  - Implementeer `_build_unified_context_section()`</li>
<li>  - Test met verschillende context scores</li>
</ul>

<ol>
<li>**Simplify ExpertiseModule**</li>
</ol>
<ul>
<li>  - Verwijder `_build_word_type_advice()`</li>
<li>  - Verwijder woordsoort bepaling</li>
</ul>

<ol>
<li>**Enhance SemanticCategorisationModule**</li>
</ol>
<ul>
<li>  - Wordt primaire categorie bepaler</li>
<li>  - Implementeer intelligente categorie detectie</li>
</ul>

<ol>
<li>**Update afhankelijke modules**</li>
</ol>
<ul>
<li>  - TemplateModule: gebruik shared state</li>
<li>  - DefinitionTaskModule: geen duplicatie</li>
</ul>

<ol>
<li>**Test end-to-end**</li>
</ol>
<ul>
<li>  - Vergelijk output kwaliteit</li>
<li>  - Meet token reductie</li>
<li>  - Valideer consistentie</li>
</ul>

<h2>Risico's en Mitigatie</h2>

<p>| Risico | Impact | Mitigatie |</p>
<p>|--------|--------|-----------|</p>
<p>| Breaking change voor bestaande prompts | Hoog | Feature flag voor geleidelijke rollout |</p>
<p>| Categorie detectie faalt | Medium | Fallback naar "type" als default |</p>
<p>| Module dependencies breken | Laag | Uitgebreide unit tests per module |</p>

<h2>Conclusie</h2>

<p>Door het Single Source of Truth principe toe te passen:</p>
<ul>
<li>**ContextAwarenessModule** wordt de enige bron voor context instructies</li>
<li>**SemanticCategorisationModule** wordt de enige bron voor categorie bepaling</li>
<li>Andere modules gebruiken alleen shared state, geen eigen bepalingen</li>
</ul>

<p>Dit resulteert in een cleaner, effici√´nter systeem met ~17% minder tokens in de prompt.</p>
  </div>
</body>
</html>