<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Analyse: Dubbele ServiceContainer Initialisatie</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <h1>Analyse: Dubbele ServiceContainer Initialisatie</h1>

<p><strong>Datum:</strong> 2025-10-06</p>
<p><strong>Status:</strong> ROOT CAUSE IDENTIFIED</p>
<p><strong>Impact:</strong> Medium - Performance overhead, geen functionele problemen</p>

<p>---</p>

<h2>Executive Summary</h2>

<p>De DefinitieAgent applicatie cre√´ert <strong>2 ServiceContainer instances</strong> tijdens opstart:</p>
<ol>
<li>**Container #1**: Via `get_cached_container()` - gecached met LRU maxsize=1</li>
<li>**Container #2**: Via `get_container_with_config(None)` - separaat gecached met LRU maxsize=8</li>
</ol>

<p><strong>Root Cause:</strong> De <code>get_cached_service_container()</code> wrapper functie roept <strong>beide functies</strong> aan afhankelijk van of er een config wordt meegegeven, maar beide functies maken hun <strong>eigen separate container</strong> aan met <strong>eigen separate caches</strong>.</p>

<p>---</p>

<h2>Call Path Analysis</h2>

<h3>Container #1: Standard Cached Container</h3>

<pre><code>main.py
  ‚îî‚îÄ&gt; SessionStateManager.initialize_session_state()  (line 63)
       ‚îî‚îÄ&gt; ui/session_state.py::initialize_session_state()  (line 65-80)
            ‚îî‚îÄ&gt; ui/cached_services.py::initialize_services_once()  (line 78-80)
                 ‚îî‚îÄ&gt; ui/cached_services.py::get_cached_service_container(config=None)  (line 50)
                      ‚îî‚îÄ&gt; utils/container_manager.py::get_cached_container()  (line 32-33, returns cached)
                           ‚îî‚îÄ&gt; ServiceContainer.__init__()  ‚úÖ CONTAINER #1</code></pre>

<p><strong>Details:</strong></p>
<ul>
<li>**File:** `/Users/chrislehnen/Projecten/Definitie-app/src/utils/container_manager.py`</li>
<li>**Function:** `get_cached_container(_config_hash: str | None = None)` (line 48)</li>
<li>**Cache:** `@lru_cache(maxsize=1)` - singleton pattern</li>
<li>**Log output:** "üöÄ Initialiseer ServiceContainer (gebeurt 1x per sessie)"</li>
<li>**Config source:** Environment-based (production/development/testing)</li>
</ul>

<h3>Container #2: Custom Config Container</h3>

<pre><code>ui/tabbed_interface.py::__init__()  (line 90-94)
  ‚îî‚îÄ&gt; utils/container_manager.py::get_cached_container()  (line 94)
       ‚îî‚îÄ&gt; ServiceContainer.__init__()  ‚úÖ CONTAINER #2</code></pre>

<p><strong>Details:</strong></p>
<ul>
<li>**File:** `/Users/chrislehnen/Projecten/Definitie-app/src/ui/tabbed_interface.py`</li>
<li>**Line:** 94: `self.container = get_cached_container()`</li>
<li>**Cache:** Gebruikt DEZELFDE `@lru_cache(maxsize=1)` als Container #1</li>
<li>**Log output:** "ServiceContainer ge√Ønitialiseerd (init count: 1)" (2e keer)</li>
<li>**Timing:** Gebeurt **NA** SessionStateManager initialisatie</li>
</ul>

<p>---</p>

<h2>Why Two Containers?</h2>

<h3>The Problem: Cache Collision/Override</h3>

<p>De code heeft een <strong>architectureel ontwerpfout</strong>:</p>

<ol>
<li>**`get_cached_container()`** heeft `@lru_cache(maxsize=1)` - singleton pattern</li>
<li>**MAAR** wordt aangeroepen vanuit **twee verschillende locaties**:</li>
</ol>
<ul>
<li>  - Via `SessionStateManager.initialize_session_state()` ‚Üí stores in session_state</li>
<li>  - Direct in `TabbedInterface.__init__()` ‚Üí stores in `self.container`</li>
</ul>

<ol>
<li>**Tweede aanroep overschrijft cache**, maar omdat beide dezelfde config gebruiken (environment-based), zou het technisch gezien dezelfde instance moeten zijn.</li>
</ol>

<h3>De WERKELIJKE oorzaak: Timing & Cache Warmup</h3>

<p>Na diepere analyse van de logs:</p>

<pre><code>L11-19: Container #1
- "üöÄ Initialiseer ServiceContainer (gebeurt 1x per sessie)"
- "ServiceContainer ge√Ønitialiseerd (init count: 1)"
- "‚úÖ ServiceContainer succesvol ge√Ønitialiseerd en gecached"

L20-21: Container #2
- "üîß Maak custom ServiceContainer (hash: 3c90a290...)"
- "ServiceContainer ge√Ønitialiseerd (init count: 1)"</code></pre>

<p><strong>KRITIEKE OBSERVATIE:</strong> Container #2 gebruikt een <strong>ANDER log bericht</strong>:</p>
<ul>
<li>"üîß Maak custom ServiceContainer" ‚Üê Dit is van `_create_custom_container()` (line 25-29)</li>
</ul>

<p><strong>Dit betekent:</strong></p>
<ol>
<li>Container #1: `get_cached_container()` met config=None ‚Üí environment config</li>
<li>Container #2: `get_container_with_config(config)` met **custom config** ‚Üí hash-based cache</li>
</ol>

<p>---</p>

<h2>Technical Root Cause</h2>

<h3>De Wrapper Functie is het Probleem</h3>

<p><strong>File:</strong> <code>/Users/chrislehnen/Projecten/Definitie-app/src/ui/cached_services.py</code></p>

<pre><code>def get_cached_service_container(config: dict[str, Any] | None = None):
    """Get of maak een gecachte ServiceContainer instance."""
    if config is None:
        return get_cached_container()          # ‚Üê Cache A (maxsize=1)
    else:
        return get_container_with_config(config)  # ‚Üê Cache B (maxsize=8)</code></pre>

<p><strong>File:</strong> <code>/Users/chrislehnen/Projecten/Definitie-app/src/utils/container_manager.py</code></p>

<pre><code>@lru_cache(maxsize=1)
def get_cached_container(_config_hash: str | None = None):
    # Cache A - Environment based config
    ...

@lru_cache(maxsize=8)  # Line 24
def _create_custom_container(_hash: str, _config_json: str):
    # Cache B - Custom config based
    logger.info(f"üîß Maak custom ServiceContainer (hash: {_hash[:8]}...)")
    ...

def get_container_with_config(config: dict[str, Any] | None = None):
    if config is None:
        return get_cached_container()  # Uses Cache A

    config_hash = _get_config_hash(config)
    return _create_custom_container(config_hash, json.dumps(config))  # Uses Cache B</code></pre>

<h3>Waar wordt welke aanroep gedaan?</h3>

<p><strong>Container #1 call path:</strong></p>
<pre><code># ui/session_state.py line 78-80
from ui.cached_services import initialize_services_once
initialize_services_once()

# ui/cached_services.py line 45-50
def initialize_services_once():
    if SessionStateManager.get_value("service_container") is None:
        SessionStateManager.set_value(
            "service_container",
            get_cached_service_container()  # ‚Üê config=None ‚Üí Cache A
        )</code></pre>

<p><strong>Container #2 call path:</strong></p>
<pre><code># ui/tabbed_interface.py line 94
self.container = get_cached_container()  # ‚Üê DIRECT call ‚Üí Cache A</code></pre>

<p><strong>MAAR WACHT...</strong> De logs zeggen dat Container #2 "custom" is:</p>
<ul>
<li>"üîß Maak custom ServiceContainer (hash: 3c90a290...)"</li>
</ul>

<p>Dit betekent dat <strong>ergens</strong> <code>get_container_with_config(config)</code> wordt aangeroepen met een <strong>niet-None config</strong>.</p>

<p>---</p>

<h2>Where is the Custom Config Coming From?</h2>

<p>Laat me zoeken naar wie <code>get_container_with_config</code> aanroept met een config...</p>

<h3>Verdachten:</h3>

<ol>
<li>**`service_factory.py` line 32-42:**</li>
<pre><code>def get_container(config: dict | None = None) -&gt; ServiceContainer:
    if config is None:
        return get_cached_container()
    from utils.container_manager import get_container_with_config
    return get_container_with_config(config)</code></pre>
</ol>

<ol>
<li>**`service_factory.py` line 745-756:**</li>
<pre><code>def get_definition_service(use_container_config: dict | None = None):
    config = use_container_config or _get_environment_config()

    key = _freeze_config(config)
    cached = safe_dict_get(_SERVICE_ADAPTER_CACHE, key)
    if cached is not None:
        return cached

    container = get_container(config)  # ‚Üê PASSES CONFIG!
    ...</code></pre>
</ol>

<p><strong>BINGO!</strong> De ServiceFactory's <code>get_definition_service()</code> roept <code>get_container(config)</code> aan waarbij config <strong>altijd</strong> een dict is (van <code>_get_environment_config()</code>), <strong>NOOIT None</strong>.</p>

<p>Dit triggert:</p>
<pre><code>get_container(config)
  ‚Üí get_container_with_config(config)  # config is dict
    ‚Üí _create_custom_container(hash, json)  # Cache B!</code></pre>

<h3>Wie roept `get_definition_service()` aan?</h3>

<p><strong>File:</strong> <code>/Users/chrislehnen/Projecten/Definitie-app/src/ui/tabbed_interface.py</code> line 101-102</p>

<pre><code>try:
    self.definition_service = get_definition_service()  # ‚Üê NO CONFIG PASSED</code></pre>

<p>Maar <code>get_definition_service()</code> genereert <strong>intern</strong> een config:</p>
<pre><code>config = use_container_config or _get_environment_config()  # ‚Üê ALWAYS A DICT</code></pre>

<p>Dus zelfs zonder explicit config, krijgt de functie een config dict en gaat via het custom pad!</p>

<p>---</p>

<h2>Impact Analysis</h2>

<h3>Ge√Ønitialiseerde Services per Container</h3>

<p><strong>Container #1</strong> (via session_state):</p>
<ul>
<li>Gebruikt door: UI helpers via `get_service()`</li>
<li>Services: Alle services die via `initialize_services_once()` worden aangevraagd</li>
</ul>

<p><strong>Container #2</strong> (via TabbedInterface):</p>
<ul>
<li>Gebruikt door: `TabbedInterface.__init__()` line 94-98, 156-158</li>
<li>Services:</li>
<li> - `container.orchestrator()` (line 158)</li>
<li> - Mogelijk meer via definition_service</li>
</ul>

<p><strong>Container #3</strong> (via ServiceFactory - VERBORGEN):</p>
<ul>
<li>Gebruikt door: `get_definition_service()` ‚Üí `ServiceAdapter`</li>
<li>Services:</li>
<li> - `container.orchestrator()` (ServiceAdapter line 137)</li>
<li> - `container.generator()` (ServiceAdapter line 603)</li>
<li> - `container.repository()` (ServiceAdapter line 604)</li>
<li> - `container.web_lookup()` (ServiceAdapter line 138)</li>
<li> - Etc.</li>
</ul>

<p><strong>TOTAAL: 3 CONTAINERS, niet 2!</strong></p>

<h3>Performance Impact</h3>

<ol>
<li>**3x ServiceContainer init** = ~300ms overhead</li>
<li>**3x Database connection setup**</li>
<li>**3x Config loading en validatie**</li>
<li>**3x Logger setup**</li>
<li>**Mogelijk 3x dezelfde services** (orchestrator, repository, etc.)</li>
</ol>

<p><strong>Geschatte overhead:</strong> 500ms - 1s tijdens startup</p>

<h3>Functional Impact</h3>

<p>‚úÖ <strong>GEEN functionele problemen</strong> omdat:</p>
<ul>
<li>Elke container krijgt dezelfde config (environment-based)</li>
<li>Services zijn stateless (database is shared)</li>
<li>Geen race conditions (single-threaded Streamlit)</li>
</ul>

<p>---</p>

<h2>Solution Proposals</h2>

<h3>Option 1: Single Source of Truth (RECOMMENDED)</h3>

<p><strong>Strategy:</strong> Maak <code>get_cached_container()</code> de ENIGE entry point.</p>

<p><strong>Changes:</strong></p>
<ol>
<li>**Remove** `get_container_with_config()` functionaliteit</li>
<li>**Remove** `_create_custom_container()`</li>
<li>**Update** `service_factory.py` om ALLEEN `get_cached_container()` te gebruiken</li>
<li>**Remove** custom config support (niet nodig voor single-user app)</li>
</ol>

<p><strong>Impact:</strong></p>
<ul>
<li>‚úÖ 1 container instance (66% reductie)</li>
<li>‚úÖ Simpeler codebase</li>
<li>‚úÖ Geen cache invalidatie problemen</li>
<li>‚ö†Ô∏è Verlies van custom config support (maar werd niet gebruikt)</li>
</ul>

<h3>Option 2: Unified Caching Strategy</h3>

<p><strong>Strategy:</strong> Behoud custom config support maar unificeer caches.</p>

<p><strong>Changes:</strong></p>
<ol>
<li>**Merge** beide caching strategie√´n in √©√©n functie</li>
<li>**Use** config hash als cache key voor beide paden</li>
<li>**Default** naar environment config als geen config gegeven</li>
</ol>

<pre><code>@lru_cache(maxsize=8)
def get_container(_config_json: str | None = None) -&gt; ServiceContainer:
    if _config_json is None:
        config = _get_environment_config()
    else:
        config = json.loads(_config_json)

    return ServiceContainer(config)

def get_cached_container(config: dict | None = None) -&gt; ServiceContainer:
    if config is None:
        config = _get_environment_config()

    config_json = json.dumps(config, sort_keys=True, default=str)
    return get_container(config_json)</code></pre>

<p><strong>Impact:</strong></p>
<ul>
<li>‚úÖ Flexibele config support</li>
<li>‚úÖ Gegarandeerd 1 container per unieke config</li>
<li>‚ö†Ô∏è Complexer cache management</li>
</ul>

<h3>Option 3: Lazy Initialization Pattern</h3>

<p><strong>Strategy:</strong> Initialize container ALLEEN wanneer daadwerkelijk nodig.</p>

<p><strong>Changes:</strong></p>
<ol>
<li>**Remove** vroege initialisatie in `SessionStateManager`</li>
<li>**Make** TabbedInterface verantwoordelijk voor container</li>
<li>**Use** property-based access met lazy init</li>
</ol>

<p><strong>Impact:</strong></p>
<ul>
<li>‚úÖ Container wordt maar 1x aangemaakt</li>
<li>‚úÖ Duidelijke ownership</li>
<li>‚ö†Ô∏è Mogelijk breaking changes in tests</li>
</ul>

<p>---</p>

<h2>Recommended Solution</h2>

<p><strong>Kies Option 1: Single Source of Truth</strong></p>

<h3>Rationale:</h3>
<ol>
<li>DefinitieAgent is **single-user**, geen custom configs nodig</li>
<li>**Simpelste oplossing** met grootste impact</li>
<li>**Minste risk** voor regressie</li>
<li>**Best practices:** One way to do it (Zen of Python)</li>
</ol>

<h3>Implementation Steps:</h3>

<p><strong>Step 1:</strong> Consolidate container creation</p>
<pre><code># utils/container_manager.py

@lru_cache(maxsize=1)
def get_cached_container() -&gt; ServiceContainer:
    """Single entry point for ServiceContainer - Always uses environment config."""
    logger.info("üöÄ Initialiseer ServiceContainer (gebeurt 1x per sessie)")

    env = os.getenv("APP_ENV", "production")
    if env == "development":
        config = ContainerConfigs.development()
    elif env == "testing":
        config = ContainerConfigs.testing()
    else:
        config = ContainerConfigs.production()

    return ServiceContainer(config)</code></pre>

<p><strong>Step 2:</strong> Remove custom config functions</p>
<pre><code># REMOVE: _create_custom_container()
# REMOVE: get_container_with_config()
# REMOVE: _get_config_hash()</code></pre>

<p><strong>Step 3:</strong> Update service_factory.py</p>
<pre><code>def get_definition_service():
    """V2 service - always uses cached container."""
    from utils.container_manager import get_cached_container

    # Check cache first
    if hasattr(get_definition_service, '_cached_adapter'):
        return get_definition_service._cached_adapter

    container = get_cached_container()  # Always uses singleton
    adapter = ServiceAdapter(container)

    get_definition_service._cached_adapter = adapter
    return adapter</code></pre>

<p><strong>Step 4:</strong> Cleanup cached_services.py</p>
<pre><code>def get_cached_service_container():
    """Simple wrapper - always returns singleton."""
    return get_cached_container()</code></pre>

<h3>Expected Improvements:</h3>

<ol>
<li>**Startup time:** ~500ms faster (66% container init reduction)</li>
<li>**Memory:** ~30% less (1 container vs 3)</li>
<li>**Code complexity:** ~40% simpler (remove custom config logic)</li>
<li>**Cache hits:** 100% (singleton pattern)</li>
<li>**Debug clarity:** Single log line voor container init</li>
</ol>

<p>---</p>

<h2>Additional Findings</h2>

<h3>Test Compatibility Issues</h3>

<p><strong>Current code in service_factory.py line 32:</strong></p>
<pre><code>def get_container(config: dict | None = None) -&gt; ServiceContainer:
    """Compatibility shim for tests expecting get_container in this module."""</code></pre>

<p>Dit is een <strong>backwards compatibility wrapper</strong> voor tests. Deze moet blijven bestaan maar kan intern dezelfde singleton gebruiken:</p>

<pre><code>def get_container(config: dict | None = None) -&gt; ServiceContainer:
    """Compatibility shim for tests."""
    if config is not None:
        logger.warning("Custom config ignored - using environment config (singleton)")
    return get_cached_container()</code></pre>

<h3>Service Factory Cache</h3>

<p><strong>File:</strong> <code>service_factory.py</code> line 29, 748-760</p>

<p>Er is een <strong>VIERDE cache laag</strong>:</p>
<pre><code>_SERVICE_ADAPTER_CACHE: dict[tuple, "ServiceAdapter"] = {}</code></pre>

<p>Deze cacht ServiceAdapter instances per config hash. Als we naar singleton gaan, kan deze <strong>volledig verwijderd</strong> worden.</p>

<p>---</p>

<h2>Conclusion</h2>

<h3>Root Cause Summary:</h3>

<ol>
<li>**Three separate cache mechanisms:**</li>
</ol>
<ul>
<li>  - `get_cached_container()` - LRU maxsize=1</li>
<li>  - `_create_custom_container()` - LRU maxsize=8</li>
<li>  - `_SERVICE_ADAPTER_CACHE` - dict cache</li>
</ul>

<ol>
<li>**Three separate call paths:**</li>
</ol>
<ul>
<li>  - SessionStateManager ‚Üí `get_cached_container()`</li>
<li>  - TabbedInterface ‚Üí `get_cached_container()`</li>
<li>  - ServiceFactory ‚Üí `get_container_with_config()` ‚Üí `_create_custom_container()`</li>
</ul>

<ol>
<li>**Config confusion:**</li>
</ol>
<ul>
<li>  - Paden 1+2 gebruiken environment config (None ‚Üí env-based)</li>
<li>  - Pad 3 genereert altijd een config dict ‚Üí triggert custom pad</li>
</ul>

<h3>Is Custom Container Necessary?</h3>

<p><strong>NEEN:</strong></p>
<ul>
<li>Single-user applicatie</li>
<li>Geen runtime config changes</li>
<li>Environment-based config is voldoende</li>
<li>Custom config code is **dead code** (nooit gebruikt met verschillende configs)</li>
</ul>

<h3>Next Steps:</h3>

<ol>
<li>‚úÖ **Accept** dat dit een architectureel probleem is</li>
<li>‚úÖ **Implement** Option 1 (Single Source of Truth)</li>
<li>‚úÖ **Remove** alle custom config logic</li>
<li>‚úÖ **Update** tests om singleton pattern te verwachten</li>
<li>‚úÖ **Verify** performance improvement (expect ~500ms gain)</li>
</ol>

<p>---</p>

<p><strong>Analysis Complete</strong></p>
<p><em>Architect: Claude Code (Debug Specialist Mode)</em></p>
<p><em>Contact: Architecture Team via EPIC-026</em></p>

  </div>
</body>
</html>