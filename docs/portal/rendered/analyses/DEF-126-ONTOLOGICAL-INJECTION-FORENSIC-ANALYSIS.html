<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DEF-126: Forensic Analysis - Ontological Category Injection Points</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <h1>DEF-126: Forensic Analysis - Ontological Category Injection Points</h1>

<h2>Executive Summary</h2>

<p><strong>CRITICAL FINDING</strong>: The system has <strong>5+ redundant injection points</strong> for ontological category instructions, resulting in:</p>
<ul>
<li>**~65+ duplicate lines** in prompts</li>
<li>**Conflicting terminology** (deverbaal vs resultaat, soort vs type, particulier vs exemplaar)</li>
<li>**Multiple modules** trying to determine/inject the same category information</li>
<li>**Token waste** of approximately 25-30% of prompt size</li>
</ul>

<h2>1. Complete Injection Point Inventory</h2>

<h3>PRIMARY INJECTION POINTS</h3>

<h4>1.1 SemanticCategorisationModule (Lines 136-277)</h4>
<p><strong>File</strong>: <code>src/services/prompts/modules/semantic_categorisation_module.py</code></p>
<p><strong>Lines</strong>: 136-277 (141 lines!)</p>
<p><strong>Type</strong>: Template + Dynamic guidance</p>
<p><strong>Content</strong>:</p>
<ul>
<li>Base ESS-02 instructions (lines 136-152): ALL 4 categories</li>
<li>Category-specific guidance (lines 182-277): Detailed per category</li>
<li>**Problem**: Injects ALL categories + "determine yourself" instructions</li>
</ul>

<h4>1.2 ExpertiseModule (Line 181)</h4>
<p><strong>File</strong>: <code>src/services/prompts/modules/expertise_module.py</code></p>
<p><strong>Line</strong>: 181</p>
<p><strong>Type</strong>: Dynamic based on word type</p>
<p><strong>Content</strong>: <code>"deverbaal": "Als het begrip een resultaat is, beschrijf het dan als uitkomst van een proces."</code></p>
<p><strong>Problem</strong>: Conflicts with SemanticCategorisationModule's "resultaat" category</p>

<h4>1.3 DefinitionTaskModule (Multiple locations)</h4>
<p><strong>File</strong>: <code>src/services/prompts/modules/definition_task_module.py</code></p>

<p><strong>Location 1</strong> - Lines 189-196 (Checklist focus):</p>
<pre><code>"proces": "activiteit/handeling",
"type": "soort/categorie",  # Different terminology!
"resultaat": "uitkomst/gevolg",
"exemplaar": "specifiek geval"</code></pre>

<p><strong>Location 2</strong> - Lines 252-253 (Ontological marker):</p>
<pre><code>"Ontologische categorie: kies uit [soort, exemplaar, proces, resultaat]"</code></pre>
<p><strong>Problem</strong>: Asks model to CHOOSE when category is already determined!</p>

<h4>1.4 TemplateModule</h4>
<p><strong>File</strong>: <code>src/services/prompts/modules/template_module.py</code></p>
<p><strong>Lines</strong>: 81-82, 145+</p>
<p><strong>Type</strong>: Uses both metadata AND shared state</p>
<p><strong>Problem</strong>: May receive conflicting categories from different sources</p>

<h4>1.5 EssRulesModule (Implicit)</h4>
<p><strong>File</strong>: <code>src/services/prompts/modules/ess_rules_module.py</code></p>
<p><strong>Type</strong>: Loads ESS-02 from JSON</p>
<p><strong>Content</strong>: Would load ESS-02 rule about ontological categorization</p>
<p><strong>Problem</strong>: Redundant with SemanticCategorisationModule</p>

<h3>SECONDARY INJECTION POINTS</h3>

<h4>1.6 UI Layer (Manual Override)</h4>
<p><strong>File</strong>: <code>src/ui/components/definition_generator_tab.py</code></p>
<p><strong>Lines</strong>: 1081, 2222</p>
<pre><code>SessionStateManager.set_value("manual_ontological_category", new_category)</code></pre>

<h4>1.7 ImprovedOntologyClassifier</h4>
<p><strong>File</strong>: <code>src/ontologie/improved_classifier.py</code></p>
<p><strong>Purpose</strong>: Determines category before generation</p>
<p><strong>Output</strong>: TYPE/PROCES/RESULTAAT/EXEMPLAAR</p>

<h2>2. Data Flow Diagram</h2>

<h3>2.1 Complete Runtime Flow</h3>

<pre><code>graph TD
    UI[UI Layer] --&gt;|1. User selects category| SS[Session State]
    UI --&gt;|2. Or auto-classify| IOC[ImprovedOntologyClassifier]

    IOC --&gt;|3. Determines: TYPE/PROCES/etc| CAT[Category Decision]
    SS --&gt;|manual_ontological_category| CAT

    CAT --&gt;|4. Pass to GenerationRequest| GR[GenerationRequest]
    GR --&gt;|5. ontologische_categorie| PSV2[PromptServiceV2]

    PSV2 --&gt;|6. Sets metadata| EC[EnrichedContext]
    EC --&gt;|"metadata['ontologische_categorie']"| EC2[Context Metadata]
    EC --&gt;|"metadata['semantic_category']"| EC3[Template Mapping]

    EC2 --&gt;|7. Build prompt via| PO[PromptOrchestrator]

    PO --&gt;|8. Execute modules| SCM[SemanticCategorisationModule]
    PO --&gt;|9. Execute| EM[ExpertiseModule]
    PO --&gt;|10. Execute| DTM[DefinitionTaskModule]
    PO --&gt;|11. Execute| TM[TemplateModule]

    SCM --&gt;|Lines 70-116: ALL categories!| PROMPT[FINAL PROMPT]
    EM --&gt;|Line 181: deverbaal advice| PROMPT
    DTM --&gt;|Lines 196, 253: category focus| PROMPT
    TM --&gt;|Lines 119-130: templates| PROMPT

    style SCM fill:#ff9999
    style EM fill:#ffcc99
    style DTM fill:#ffcc99
    style PROMPT fill:#ff6666</code></pre>

<h3>2.2 Metadata Flow Detail</h3>

<pre><code>1. UI determines category → "proces"
2. PromptServiceV2 (line 121): metadata["ontologische_categorie"] = "proces"
3. PromptServiceV2 (line 137): metadata["semantic_category"] = "Proces"
4. ModuleContext receives metadata
5. SemanticCategorisationModule (line 86): reads metadata["ontologische_categorie"]
6. SemanticCategorisationModule (line 90): sets shared["ontological_category"]
7. Other modules read from shared state</code></pre>

<h2>3. Redundancy Analysis</h2>

<h3>3.1 Terminology Conflicts</h3>

<p>| Module | TYPE | PROCES | RESULTAAT | EXEMPLAAR |</p>
<p>|--------|------|--------|-----------|-----------|</p>
<p>| SemanticCategorisationModule | "type" | "proces" | "resultaat" | "exemplaar" |</p>
<p>| ExpertiseModule | "overig" | "werkwoord" | "deverbaal" | - |</p>
<p>| DefinitionTaskModule | "soort/categorie" | "activiteit/handeling" | "uitkomst/gevolg" | "specifiek geval" |</p>
<p>| EssRulesModule | "type" | "proces" | "resultaat" | "particulier" |</p>

<h3>3.2 Duplicate Instructions Examples</h3>

<p><strong>For "PROCES" category, the prompt contains:</strong></p>

<ol>
<li>**Line 3** (ExpertiseModule):</li>
</ol>
<ul>
<li>  - "Als het begrip een handeling beschrijft, definieer het dan als proces of activiteit"</li>
</ul>

<ol>
<li>**Lines 139-140** (SemanticCategorisationModule base):</li>
</ol>
<ul>
<li>  - "PROCES begrippen → start met: 'activiteit waarbij...', 'handeling die...'"</li>
</ul>

<ol>
<li>**Lines 182-207** (SemanticCategorisationModule detailed):</li>
</ol>
<ul>
<li>  - Full PROCES guidance with examples</li>
</ul>

<ol>
<li>**Line 196** (DefinitionTaskModule):</li>
</ol>
<ul>
<li>  - "Focus: Dit is een **proces** (activiteit/handeling)"</li>
</ul>

<ol>
<li>**Line 253** (DefinitionTaskModule):</li>
</ol>
<ul>
<li>  - "Ontologische categorie: kies uit [soort, exemplaar, proces, resultaat]"</li>
</ul>

<p><strong>Total</strong>: Same instruction repeated 5 times in different forms!</p>

<h2>4. Token Impact Analysis</h2>

<h3>Current State (Worst Case)</h3>
<pre><code>SemanticCategorisationModule: ~141 lines (~2000 tokens)
ExpertiseModule word advice: ~3 lines (~50 tokens)
DefinitionTaskModule focus: ~8 lines (~100 tokens)
DefinitionTaskModule marker: ~3 lines (~50 tokens)
TemplateModule: ~20 lines (~300 tokens)
-------------------------------------------
TOTAL: ~175 lines (~2500 tokens for category instructions)</code></pre>

<h3>After Optimization (Single Source)</h3>
<pre><code>SemanticCategorisationModule (compact): ~15 lines (~200 tokens)
Other modules use shared state: 0 tokens
-------------------------------------------
TOTAL: ~15 lines (~200 tokens)
SAVINGS: 92% reduction!</code></pre>

<h2>5. Root Cause Analysis</h2>

<h3>Why This Happened</h3>

<ol>
<li>**Evolution over time**: Different developers added category support independently</li>
<li>**No central authority**: Each module tries to be self-sufficient</li>
<li>**Mixed responsibilities**: Modules both determine AND inject categories</li>
<li>**Legacy compatibility**: Keeping old patterns while adding new ones</li>
<li>**Unclear ownership**: No single module designated as "category owner"</li>
</ol>

<h3>Current Problems</h3>

<ol>
<li>**Model confusion**: Conflicting instructions ("determine yourself" vs "use this category")</li>
<li>**Token waste**: 2500 tokens for what should be 200 tokens</li>
<li>**Maintenance nightmare**: Changes needed in 5+ places</li>
<li>**Quality issues**: Model receives contradictory guidance</li>
</ol>

<h2>6. Recommended Fix Approach</h2>

<h3>Phase 1: Consolidate Authority (Quick Win)</h3>

<ol>
<li>**Designate SemanticCategorisationModule as Single Source**</li>
</ol>
<ul>
<li>  - Remove category determination logic</li>
<li>  - Only inject instructions for SELECTED category</li>
<li>  - Use metadata from UI/classifier</li>
</ul>

<ol>
<li>**Remove Redundant Injections**</li>
</ol>
<ul>
<li>  - ExpertiseModule: Remove word_type advice</li>
<li>  - DefinitionTaskModule: Remove "choose category" instruction</li>
<li>  - EssRulesModule: Skip ESS-02</li>
<li>  - TemplateModule: Only use shared state</li>
</ul>

<h3>Phase 2: Refactor Module (Clean Architecture)</h3>

<pre><code>class SemanticCategorisationModule:
    def execute(self, context: ModuleContext) -&gt; ModuleOutput:
        # Get ALREADY DETERMINED category
        category = context.get_metadata("ontologische_categorie")

        if not category:
            return ModuleOutput(content="", skip=True)

        # Inject ONLY instructions for THIS category
        content = self._get_single_category_instruction(category)

        # Share for other modules
        context.set_shared("ontological_category", category)

        return ModuleOutput(content=content)</code></pre>

<h3>Phase 3: Update Dependencies</h3>

<ul>
<li>All modules read from `context.get_shared("ontological_category")`</li>
<li>No module generates its own category instructions</li>
<li>Consistent terminology throughout</li>
</ul>

<h2>7. Risk Assessment</h2>

<h3>Current Implementation Risks</h3>

<p>| Risk | Severity | Impact |</p>
<p>|------|----------|--------|</p>
<p>| Token limit exceeded | HIGH | Generation fails for complex prompts |</p>
<p>| Conflicting instructions | HIGH | Poor quality definitions |</p>
<p>| Model confusion | MEDIUM | Inconsistent outputs |</p>
<p>| Maintenance burden | MEDIUM | Bug fixes needed in 5+ places |</p>
<p>| Performance impact | LOW | Slower generation due to token overhead |</p>

<h3>Fix Implementation Risks</h3>

<p>| Risk | Severity | Mitigation |</p>
<p>|------|----------|-----------|</p>
<p>| Breaking existing prompts | LOW | Feature flag for gradual rollout |</p>
<p>| Module dependencies | LOW | Extensive testing |</p>
<p>| Category not set | LOW | Default to "type" category |</p>

<h2>8. Implementation Checklist</h2>

<ul>
<li>[ ] Update SemanticCategorisationModule to single-category mode</li>
<li>[ ] Remove word_type advice from ExpertiseModule</li>
<li>[ ] Remove "choose category" from DefinitionTaskModule</li>
<li>[ ] Update TemplateModule to use only shared state</li>
<li>[ ] Configure EssRulesModule to skip ESS-02</li>
<li>[ ] Test with all 4 categories</li>
<li>[ ] Measure token reduction</li>
<li>[ ] Update documentation</li>
</ul>

<h2>9. Expected Outcomes</h2>

<ol>
<li>**Token reduction**: 2500 → 200 tokens (92% reduction)</li>
<li>**Clearer prompts**: Single, consistent instruction</li>
<li>**Better quality**: No conflicting guidance</li>
<li>**Easier maintenance**: Single point of change</li>
<li>**Faster generation**: Less tokens to process</li>
</ol>

<h2>10. Verification Example</h2>

<h3>Real Prompt Analysis (from PROMPT_MODULE_MAPPING.md)</h3>

<p>For the term "contradictie" (classified as TYPE), the generated prompt contains:</p>

<ol>
<li>**Line 3** (ExpertiseModule): "Als het begrip een resultaat is, beschrijf het dan als uitkomst"</li>
<li>**Lines 70-87** (SemanticCategorisationModule base): Instructions for ALL 4 categories</li>
<li>**Lines 88-116** (SemanticCategorisationModule TYPE-specific): Detailed TYPE guidance</li>
<li>**Lines 119-130** (TemplateModule): Templates for "Object" category</li>
<li>**Line 196** (DefinitionTaskModule): Focus marker for category</li>
<li>**Line 253** (DefinitionTaskModule): "Choose from [soort, exemplaar, proces, resultaat]"</li>
</ol>

<p><strong>Result</strong>: The model receives:</p>
<ul>
<li>Instructions to CHOOSE a category (when it's already TYPE)</li>
<li>Guidance for ALL 4 categories (when only TYPE is needed)</li>
<li>Conflicting terminology (soort vs type)</li>
<li>Total: 47 lines for category instructions that could be 10 lines</li>
</ul>

<h2>Conclusion</h2>

<p>The current implementation has evolved into a redundant mess with 5+ injection points for the same information. By consolidating to a single source of truth (SemanticCategorisationModule), we can achieve a 92% token reduction while improving quality and maintainability. This is a high-priority fix with minimal risk and maximum benefit.</p>

<h3>Key Takeaways</h3>

<ol>
<li>**The category is determined BEFORE prompt generation** (UI or classifier)</li>
<li>**Yet modules still ask the model to determine it** (contradictory)</li>
<li>**Multiple modules inject the same instructions** (redundant)</li>
<li>**Terminology is inconsistent** (confusing)</li>
<li>**Solution is straightforward**: Single source of truth pattern</li>
</ol>
  </div>
</body>
</html>