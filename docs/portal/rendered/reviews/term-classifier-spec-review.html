<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Term-Based Classification Specification Review</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <p>---</p>
<p>id: REVIEW-002</p>
<p>title: "Term-Based Classification Specification Review"</p>
<p>type: architecture-review</p>
<p>status: draft</p>
<p>reviewer: Claude Code</p>
<p>date: 2025-10-15</p>
<p>applies_to: ontology-classification-system</p>
<p>risk_level: HIGH</p>
<p>---</p>

<h1>Term-Based Classification Specification Review</h1>

<h2>Executive Summary</h2>

<p><strong>Review Status:</strong> CRITICAL GAPS IDENTIFIED</p>
<p><strong>Overall Risk:</strong> HIGH</p>
<p><strong>Recommendation:</strong> SPECIFICATION REQUIRED BEFORE IMPLEMENTATION</p>

<p>This review analyzes the <strong>proposed term-based classification approach</strong> for ontological classification (TYPE/EXEMPLAAR/PROCES/RESULTAAT) against the current LLM-based hybrid system. The analysis reveals significant specification gaps that must be addressed before implementation.</p>

<p>---</p>

<h2>Current State Analysis</h2>

<h3>Existing Implementation (LLM-Based Hybrid)</h3>

<p><strong>Location:</strong> <code>src/services/classification/ontology_classifier.py</code></p>

<p><strong>Approach:</strong></p>
<ol>
<li>**Primary:** GPT-4 classification with structured prompt (YAML config)</li>
<li>**Validation:** Rules-based sanity checks via `OntologyValidator`</li>
<li>**Fallback:** Configurable fallback level (`ONBESLIST`)</li>
</ol>

<p><strong>Strengths:</strong></p>
<ul>
<li>Context-aware classification using full definition text</li>
<li>Handles ambiguous cases with confidence scores</li>
<li>Linguistic pattern validation (regex-based)</li>
<li>Domain-specific heuristics (legal, biology)</li>
</ul>

<p><strong>Weaknesses:</strong></p>
<ul>
<li>LLM dependency (API costs, latency)</li>
<li>Non-deterministic results</li>
<li>Difficult to debug classification decisions</li>
<li>No explicit term-list specification</li>
</ul>

<p>---</p>

<h2>Term-Based Classification Gap Analysis</h2>

<h3>1. Rule Completeness</h3>

<p><strong>RISK: HIGH</strong></p>

<h4>Missing Specifications</h4>

<p><strong>No explicit term lists exist:</strong></p>
<ul>
<li>No `TYPE` term dictionary (e.g., "soort", "categorie", "klasse")</li>
<li>No `EXEMPLAAR` term dictionary (e.g., "deze", "dit", "specifieke")</li>
<li>No `PROCES` term dictionary (e.g., "aanvragen", "beroep", "procedure")</li>
<li>No `RESULTAAT` term dictionary (e.g., "verleende", "vastgestelde", "verkregen")</li>
</ul>

<p><strong>Current Validator Patterns (Regex-Based):</strong></p>

<pre><code># From ontology_validator.py lines 22-75
PATTERNS = {
    "TYPE": {
        "strong_indicators": [
            r"\b(soort|type|categorie|klasse)\b",
            r"\b(een|de)\s+\w+\s+(is|betreft)\s+(een|de)\b",
            r"\b(alle|elk|elke|iedere)\b",
        ],
        # ... more patterns
    }
}</code></pre>

<p><strong>Issues:</strong></p>
<ol>
<li>**No 'machtiging' override rule** - Special cases not handled</li>
<li>**No compound word rules** - Dutch compounds (e.g., "vergunningaanvraag") not explicitly handled</li>
<li>**No negation handling** - "niet verlenen" vs "verlenen"</li>
<li>**No multi-word term matching** - "het verlenen van" vs "verlenen"</li>
</ol>

<p><strong>Recommendations:</strong></p>
<ul>
<li>✅ Create explicit term dictionaries in JSON/YAML config</li>
<li>✅ Add special-case override rules (e.g., `machtiging: TYPE` despite process-like morphology)</li>
<li>✅ Implement compound word decomposition for Dutch</li>
<li>✅ Add negation detection patterns</li>
<li>✅ Support multi-word term matching with context windows</li>
</ul>

<p>---</p>

<h3>2. Scoring Conflicts</h3>

<p><strong>RISK: MEDIUM</strong></p>

<h4>Current Behavior</h4>

<p>The LLM-based system returns a <strong>single classification with confidence</strong>:</p>
<ul>
<li>No multi-category scoring</li>
<li>No explicit conflict resolution</li>
</ul>

<pre><code># From ontology_classifier.py lines 145-152
result = ClassificationResult(
    level=result_data["level"],          # Single classification
    confidence=result_data["confidence"], # 0.0-1.0
    rationale=result_data["rationale"],
    linguistic_cues=result_data.get("linguistic_cues", []),
    validation_warnings=validation_warnings,
)</code></pre>

<h4>Missing Specification</h4>

<p><strong>What happens when multiple categories score equally?</strong></p>

<p>Example scenario:</p>
<pre><code>Term: "vergunningverlening"
Scores: PROCES=0.85 (process suffix -ing), RESULTAAT=0.85 (result prefix verlening-)</code></pre>

<p><strong>No documented conflict resolution strategy:</strong></p>
<ul>
<li>Priority order by category?</li>
<li>Tiebreaker rules?</li>
<li>Fall back to `ONBESLIST`?</li>
<li>Human review trigger?</li>
</ul>

<p><strong>Recommendations:</strong></p>
<ul>
<li>✅ Define category priority order: `EXEMPLAAR > TYPE > RESULTAAT > PROCES > ONBESLIST`</li>
<li>✅ Set minimum confidence delta (e.g., 0.15) for decisive classification</li>
<li>✅ Log ambiguous cases for manual review</li>
<li>✅ Implement scoring transparency: return all scores, not just winner</li>
</ul>

<p>---</p>

<h3>3. Dutch Language Specifics</h3>

<p><strong>RISK: MEDIUM-HIGH</strong></p>

<h4>Compound Word Challenges</h4>

<p>Dutch allows unlimited compound word formation, which term-based classification must handle:</p>

<p><strong>Current Limitations:</strong></p>

<pre><code># From ontology_validator.py line 51
r"\b(het|de)\s+\w+(en|ing)\b",  # Simplistic suffix matching</code></pre>

<p><strong>Missing Coverage:</strong></p>

<ol>
<li>**Nested Compounds:**</li>
</ol>
<ul>
<li>  - `identiteitsvaststelling` → `identiteit` + `vast` + `stelling`</li>
<li>  - `vergunningaanvraagprocedure` → `vergunning` + `aanvraag` + `procedure`</li>
<li>  - Classification depends on **head noun** (rightmost), not prefix</li>
</ul>

<ol>
<li>**Separable Verbs:**</li>
</ol>
<ul>
<li>  - `aanvragen` (infinitive) vs `vraagt aan` (conjugated)</li>
<li>  - `verlenen` vs `leent ver` (different meaning)</li>
</ul>

<ol>
<li>**Diminutives & Derivations:**</li>
</ol>
<ul>
<li>  - `documentje` (diminutive) → still TYPE</li>
<li>  - `aanvrager` (agent noun) → TYPE (person), not PROCES</li>
</ul>

<ol>
<li>**Ambiguous Morphology:**</li>
</ol>
<ul>
<li>  - `-ing` suffix: Can be PROCES ("aanvraag**ing**") or TYPE ("beoordel**ing**")</li>
<li>  - `-sel` suffix: Usually RESULTAAT ("overblijf**sel**")</li>
</ul>

<p><strong>Current Pattern Adequacy: INSUFFICIENT</strong></p>

<p>Regex patterns are too simplistic for Dutch morphology:</p>
<ul>
<li>No compound decomposition</li>
<li>No morphological analysis</li>
<li>No derivation handling</li>
</ul>

<p><strong>Recommendations:</strong></p>
<ul>
<li>✅ Integrate Dutch NLP library (e.g., `spaCy` with `nl_core_news_sm`)</li>
<li>✅ Implement compound word splitter (e.g., `secos` library)</li>
<li>✅ Add morphological feature extraction (POS tags, lemmas)</li>
<li>✅ Create suffix/prefix priority rules:</li>
<pre><code>  suffix_rules:
    -ing:
      priority: medium
      default: PROCES
      exceptions: ["opleiding", "voorziening"]  # These are TYPE
    -sel:
      priority: high
      default: RESULTAAT</code></pre>
</ul>

<p>---</p>

<h3>4. Performance</h3>

<p><strong>RISK: MEDIUM</strong></p>

<h4>Scalability Analysis</h4>

<p><strong>Current LLM-Based Approach:</strong></p>
<ul>
<li>Latency: ~1.5s per term (p50), 3s (p95) — from `ontology_classification.yaml` line 79</li>
<li>Cost: $0.03-0.06 per 1K tokens (GPT-4)</li>
<li>For 1,000 terms: ~25 minutes, $30-60</li>
</ul>

<p><strong>Term-Based Approach (Hypothetical):</strong></p>
<ul>
<li>Regex matching: < 1ms per term</li>
<li>NLP pipeline (spaCy): ~5-10ms per term</li>
<li>Dictionary lookup: O(1) with hash tables</li>
</ul>

<p><strong>Scaling for 1,000+ Terms:</strong></p>

<p>| Metric | LLM-Based | Term-Based | Improvement |</p>
<p>|--------|-----------|------------|-------------|</p>
<p>| Latency (1K terms) | 25 min | 10 sec | 150x faster |</p>
<p>| Cost | $30-60 | $0 | 100% savings |</p>
<p>| Memory | ~100 MB | ~50 MB | 2x less |</p>
<p>| Offline capable | No | Yes | ✓ |</p>

<p><strong>Regex Efficiency Concerns:</strong></p>

<p>Current validator has <strong>15 regex patterns</strong> (5 categories × 3 types):</p>
<pre><code># From ontology_validator.py lines 22-75
PATTERNS = {
    "TYPE": {"strong_indicators": [...], "weak_indicators": [...], "anti_indicators": [...]},
    "EXEMPLAAR": {...},
    "PROCES": {...},
    "RESULTAAT": {...},
}</code></pre>

<p><strong>Optimization Opportunities:</strong></p>
<ol>
<li>Pre-compile all regexes (currently recompiled per call)</li>
<li>Use `re.compile()` with flags in `__init__`</li>
<li>Batch validation: Process multiple terms in single pass</li>
<li>Cache pattern match results per unique definition text</li>
</ol>

<p><strong>Recommendations:</strong></p>
<ul>
<li>✅ Pre-compile regex patterns in validator `__init__`</li>
<li>✅ Add caching layer: `@lru_cache(maxsize=1000)` on validation</li>
<li>✅ Benchmark: Create `tests/performance/test_classification_scaling.py`</li>
<li>✅ Profile bottlenecks: Use `cProfile` to identify slow patterns</li>
<li>✅ Consider Bloom filters for term lookups if dictionary grows > 10K terms</li>
</ul>

<p>---</p>

<h3>5. Maintainability</h3>

<p><strong>RISK: MEDIUM-HIGH</strong></p>

<h4>JSON Config vs Hardcoded Rules</h4>

<p><strong>Current State: MIXED APPROACH</strong></p>

<p><strong>Configuration in Files:</strong></p>
<ul>
<li>✅ Prompt template: `config/prompts/ontology_classification.yaml`</li>
<li>✅ Service config: `src/services/classification/config.py` (Pydantic)</li>
</ul>

<p><strong>Hardcoded in Python:</strong></p>
<ul>
<li>❌ Validation patterns: `ontology_validator.py` lines 22-91</li>
<li>❌ Domain rules: `ontology_validator.py` lines 77-91</li>
</ul>

<pre><code># HARDCODED - difficult to maintain
PATTERNS = {
    "TYPE": {
        "strong_indicators": [
            r"\b(soort|type|categorie|klasse)\b",
            # ... more patterns
        ],
    }
}</code></pre>

<p><strong>Maintainability Issues:</strong></p>

<ol>
<li>**No Version Control for Rules:**</li>
</ol>
<ul>
<li>  - Pattern changes require code deployment</li>
<li>  - No A/B testing of rules</li>
<li>  - No rollback mechanism</li>
</ul>

<ol>
<li>**No External Editing:**</li>
</ol>
<ul>
<li>  - Domain experts can't edit rules</li>
<li>  - Requires Python knowledge to modify</li>
</ul>

<ol>
<li>**No Rule Provenance:**</li>
</ol>
<ul>
<li>  - Who added pattern X? Why?</li>
<li>  - When was domain rule Y validated?</li>
</ul>

<ol>
<li>**No Audit Trail:**</li>
</ol>
<ul>
<li>  - Can't track rule effectiveness over time</li>
<li>  - No metrics per pattern</li>
</ul>

<p><strong>Recommendations:</strong></p>

<p>✅ <strong>Move ALL patterns to external config:</strong></p>

<pre><code># config/classification/ontology_patterns.yaml
version: "1.0.0"
last_updated: "2025-10-15"
patterns:
  TYPE:
    strong_indicators:
      - pattern: '\b(soort|type|categorie|klasse)\b'
        weight: 1.0
        added_by: "architect"
        validated: "2025-01-15"
        examples: ["Dit is een soort fruit"]
      - pattern: '\b(alle|elk|elke|iedere)\b'
        weight: 0.8
        added_by: "domain-expert"
        validated: "2025-02-10"
        examples: ["Alle gevallen vallen onder..."]
    anti_indicators:
      - pattern: '\b(deze|dit|dat|die)\b'
        weight: -1.0
        rationale: "Specifieke verwijzingen duiden op EXEMPLAAR"
  # ... more categories</code></pre>

<p>✅ <strong>Add validation rule management UI:</strong></p>
<ul>
<li>Load/save patterns from YAML</li>
<li>Test patterns against corpus</li>
<li>Track pattern performance metrics</li>
</ul>

<p>✅ <strong>Implement rule versioning:</strong></p>
<ul>
<li>Store rules in database with version history</li>
<li>Support A/B testing of pattern sets</li>
<li>Enable rollback on regression</li>
</ul>

<p>---</p>

<h3>6. Testing Strategy</h3>

<p><strong>RISK: HIGH</strong></p>

<h4>Current Test Coverage</h4>

<p><strong>Existing Tests:</strong> <code>tests/services/classification/test_ontology_classifier.py</code></p>

<p><strong>Coverage Gaps (based on term-based classification needs):</strong></p>

<p><strong>Missing Test Categories:</strong></p>

<ol>
<li>**Edge Cases:**</li>
</ol>
<ul>
<li>  - ❌ Compound words (`vergunningaanvraagprocedure`)</li>
<li>  - ❌ Negations (`niet verlenen`)</li>
<li>  - ❌ Ambiguous terms (`machtiging` override)</li>
<li>  - ❌ Multi-word terms (`het verlenen van een vergunning`)</li>
</ul>

<ol>
<li>**Conflict Resolution:**</li>
</ol>
<ul>
<li>  - ❌ Equal scores across categories</li>
<li>  - ❌ Confidence threshold edge cases (0.49 vs 0.51)</li>
<li>  - ❌ Fallback behavior when all scores low</li>
</ul>

<ol>
<li>**Dutch Morphology:**</li>
</ol>
<ul>
<li>  - ❌ Separable verbs</li>
<li>  - ❌ Diminutives</li>
<li>  - ❌ Derivational suffixes (-er, -ing, -sel, -heid)</li>
</ul>

<ol>
<li>**Performance:**</li>
</ol>
<ul>
<li>  - ❌ Regex backtracking worst-case</li>
<li>  - ❌ Scaling to 1,000+ terms</li>
<li>  - ❌ Memory usage profiling</li>
</ul>

<ol>
<li>**Configuration:**</li>
</ol>
<ul>
<li>  - ❌ Pattern load/reload</li>
<li>  - ❌ Invalid pattern handling</li>
<li>  - ❌ Config validation</li>
</ul>

<p><strong>Recommendations:</strong></p>

<p>✅ <strong>Priority Test Cases (Must-Have):</strong></p>

<pre><code># tests/services/classification/test_term_based_classifier.py

class TestTermBasedClassifier:
    """Critical test cases for term-based classification."""

    # PRIORITY 1: Edge Cases
    def test_machtiging_override_to_type(self):
        """'machtiging' moet TYPE zijn ondanks -ing suffix (PROCES indicator)."""
        result = classifier.classify("machtiging", "De bevoegdheid om...")
        assert result.level == "TYPE"

    def test_compound_word_head_noun_wins(self):
        """Compound word classification bepaald door rightmost head noun."""
        result = classifier.classify(
            "vergunningaanvraagprocedure",
            "Het proces van..."
        )
        assert result.level == "PROCES"  # -procedure (head) wins

    def test_negation_preserves_category(self):
        """Negation mag classification niet omdraaien."""
        pos = classifier.classify("verlenen", "Het toekennen van...")
        neg = classifier.classify("niet verlenen", "Het weigeren van...")
        assert pos.level == neg.level == "PROCES"

    # PRIORITY 2: Conflict Resolution
    def test_equal_scores_uses_priority_order(self):
        """Bij gelijke scores: EXEMPLAAR &gt; TYPE &gt; RESULTAAT &gt; PROCES."""
        # Mock equal scores
        result = classifier.classify_with_scores("ambiguous_term", "...")
        assert result.all_scores["TYPE"] == result.all_scores["PROCES"] == 0.85
        assert result.level == "TYPE"  # TYPE heeft hogere priority

    def test_low_confidence_fallback(self):
        """Confidence &lt; 0.5 moet fallback naar ONBESLIST."""
        result = classifier.classify("vage_term", "Onduidelijke definitie")
        if result.confidence &lt; 0.5:
            assert result.level == "ONBESLIST"

    # PRIORITY 3: Dutch Morphology
    def test_separable_verb_classification(self):
        """Separable verbs herkennen als PROCES."""
        result = classifier.classify("vraagt aan", "Hij vraagt een vergunning aan")
        assert result.level == "PROCES"

    def test_diminutive_preserves_base_classification(self):
        """Diminutives behouden base classification."""
        base = classifier.classify("document", "Een geschreven stuk")
        dim = classifier.classify("documentje", "Een klein geschreven stuk")
        assert base.level == dim.level == "TYPE"

    def test_ing_suffix_ambiguity(self):
        """'-ing' kan TYPE of PROCES zijn - context-dependent."""
        opleiding = classifier.classify("opleiding", "Een cursus om te leren")
        aanvraaging = classifier.classify("aanvraaging", "Het proces van aanvragen")
        assert opleiding.level == "TYPE"
        assert aanvraaging.level == "PROCES"

    # PRIORITY 4: Performance
    @pytest.mark.slow
    def test_classification_scales_to_1000_terms(self):
        """Classificatie van 1000 terms binnen 30 seconden."""
        import time
        terms = generate_test_corpus(1000)
        start = time.time()
        results = classifier.classify_batch(terms)
        elapsed = time.time() - start
        assert elapsed &lt; 30.0
        assert len(results) == 1000

    def test_regex_no_catastrophic_backtracking(self):
        """Regex patterns moeten safe zijn tegen backtracking attacks."""
        evil_input = "a" * 10000  # Pathological input
        import time
        start = time.time()
        result = classifier.classify(evil_input, "...")
        elapsed = time.time() - start
        assert elapsed &lt; 1.0  # Max 1 second

    # PRIORITY 5: Configuration
    def test_invalid_pattern_config_raises(self):
        """Ongeldige regex patterns moeten duidelijke errors geven."""
        with pytest.raises(re.error):
            load_config("config/classification/invalid_patterns.yaml")

    def test_pattern_hot_reload(self):
        """Patterns moeten herladen kunnen worden zonder restart."""
        original = classifier.classify("test", "...")
        update_config("config/classification/ontology_patterns.yaml")
        classifier.reload_patterns()
        updated = classifier.classify("test", "...")
        # Verify new patterns applied</code></pre>

<p>✅ <strong>Test Data Requirements:</strong></p>

<ol>
<li>**Golden Dataset:**</li>
</ol>
<ul>
<li>  - 100 manually classified terms (25 per category)</li>
<li>  - Cover edge cases: compounds, negations, ambiguous</li>
<li>  - Source: Real definitions from `data/definities.db`</li>
</ul>

<ol>
<li>**Adversarial Dataset:**</li>
</ol>
<ul>
<li>  - Pathological regex inputs (backtracking)</li>
<li>  - Extremely long definitions (>10K chars)</li>
<li>  - Unicode edge cases (emoji, special chars)</li>
</ul>

<ol>
<li>**Regression Dataset:**</li>
</ol>
<ul>
<li>  - All terms that were mis-classified in production</li>
<li>  - Track classification drift over time</li>
</ul>

<p>---</p>

<h2>Risk Assessment Summary</h2>

<p>| Aspect | Risk Level | Probability | Impact | Mitigation Priority |</p>
<p>|--------|-----------|-------------|--------|---------------------|</p>
<p>| <strong>Rule Completeness</strong> | HIGH | High | High | URGENT |</p>
<p>| <strong>Scoring Conflicts</strong> | MEDIUM | Medium | Medium | HIGH |</p>
<p>| <strong>Dutch Language</strong> | MEDIUM-HIGH | High | High | HIGH |</p>
<p>| <strong>Performance</strong> | MEDIUM | Low | Medium | MEDIUM |</p>
<p>| <strong>Maintainability</strong> | MEDIUM-HIGH | High | Medium | HIGH |</p>
<p>| <strong>Testing</strong> | HIGH | High | High | URGENT |</p>

<p>---</p>

<h2>Recommendations</h2>

<h3>Immediate Actions (Before Implementation)</h3>

<ol>
<li>**Create Term-Based Specification Document** (URGENT)</li>
</ol>
<ul>
<li>  - Define explicit term dictionaries per category</li>
<li>  - Document conflict resolution strategy</li>
<li>  - Specify Dutch morphology handling rules</li>
</ul>

<ol>
<li>**Externalize All Patterns to Config** (HIGH)</li>
</ol>
<ul>
<li>  - Move `PATTERNS` and `DOMAIN_RULES` to YAML</li>
<li>  - Add versioning and provenance metadata</li>
<li>  - Enable hot-reload without code deployment</li>
</ul>

<ol>
<li>**Build Critical Test Suite** (URGENT)</li>
</ol>
<ul>
<li>  - Implement 15 priority test cases listed above</li>
<li>  - Create golden dataset of 100 manually classified terms</li>
<li>  - Add performance benchmarks for 1,000+ term scaling</li>
</ul>

<h3>Medium-Term Improvements</h3>

<ol>
<li>**Integrate Dutch NLP Pipeline** (HIGH)</li>
</ol>
<ul>
<li>  - Add `spaCy` with `nl_core_news_sm` model</li>
<li>  - Implement compound word splitter</li>
<li>  - Extract morphological features for classification</li>
</ul>

<ol>
<li>**Optimize Performance** (MEDIUM)</li>
</ol>
<ul>
<li>  - Pre-compile all regex patterns</li>
<li>  - Add LRU caching for repeated terms</li>
<li>  - Profile and optimize slow patterns</li>
</ul>

<ol>
<li>**Add Hybrid Fallback** (MEDIUM)</li>
</ol>
<ul>
<li>  - Keep LLM-based system as fallback for ambiguous cases</li>
<li>  - Use term-based for high-confidence (>0.85) cases</li>
<li>  - Log all fallback triggers for pattern improvement</li>
</ul>

<p>---</p>

<h2>Comparison: LLM-Based vs Term-Based</h2>

<p>| Criterion | LLM-Based (Current) | Term-Based (Proposed) | Winner |</p>
<p>|-----------|---------------------|------------------------|--------|</p>
<p>| <strong>Accuracy</strong> | High (context-aware) | Medium (pattern-based) | LLM |</p>
<p>| <strong>Speed</strong> | Slow (1.5s/term) | Fast (<10ms/term) | Term |</p>
<p>| <strong>Cost</strong> | High ($30-60/1K) | Zero | Term |</p>
<p>| <strong>Determinism</strong> | Low (stochastic) | High (rules-based) | Term |</p>
<p>| <strong>Debuggability</strong> | Hard (black box) | Easy (transparent rules) | Term |</p>
<p>| <strong>Maintainability</strong> | Medium | High (if externalized) | Term |</p>
<p>| <strong>Offline Support</strong> | No (API required) | Yes | Term |</p>
<p>| <strong>Dutch Handling</strong> | Excellent | Poor (needs NLP) | LLM |</p>
<p>| <strong>Edge Cases</strong> | Good (learns from examples) | Requires explicit rules | LLM |</p>

<p><strong>Recommendation: HYBRID APPROACH</strong></p>

<p>Use term-based for <strong>high-confidence cases</strong> (80%+ of terms), LLM fallback for <strong>ambiguous cases</strong> (20%).</p>

<p>---</p>

<h2>Definition of Done</h2>

<p><strong>This specification review is COMPLETE when:</strong></p>

<ul>
<li>✅ Term-based classification specification document created</li>
<li>✅ Explicit term dictionaries defined (TYPE, EXEMPLAAR, PROCES, RESULTAAT)</li>
<li>✅ Conflict resolution strategy documented</li>
<li>✅ Dutch morphology handling rules specified</li>
<li>✅ All patterns externalized to YAML config</li>
<li>✅ 15 priority test cases implemented and passing</li>
<li>✅ Golden dataset of 100 terms created and validated</li>
<li>✅ Performance benchmarks established (1,000+ terms < 30s)</li>
<li>✅ Hybrid LLM fallback strategy defined</li>
</ul>

<p><strong>CURRENT STATUS:</strong> ❌ SPECIFICATION INCOMPLETE - DO NOT IMPLEMENT YET</p>

<p>---</p>

<h2>Appendix: Current System Metrics</h2>

<h3>Code Locations</h3>

<pre><code>src/services/classification/
├── __init__.py                  # Public API
├── ontology_classifier.py       # Main service (237 LOC)
├── config.py                    # Pydantic config (91 LOC)
└── ontology_validator.py        # Rules validator (213 LOC)

config/prompts/
└── ontology_classification.yaml # LLM prompt template

tests/services/classification/
├── test_ontology_classifier.py  # Service tests
└── test_ontology_config.py      # Config tests</code></pre>

<h3>Performance Baseline (LLM-Based)</h3>

<pre><code># From config/prompts/ontology_classification.yaml lines 77-81
sla:
  p50_ms: 1500     # Median latency
  p95_ms: 3000     # 95th percentile
  timeout_ms: 10000 # Hard timeout</code></pre>

<h3>Current Pattern Count</h3>

<ul>
<li>**Total Regex Patterns:** 15 (5 categories × 3 types)</li>
<li>**Domain Rules:** 2 (biology, legal_procedure)</li>
<li>**Hardcoded Sanity Checks:** 3</li>
</ul>

<p>---</p>

<h2>References</h2>

<ul>
<li>**Current Implementation:** `src/services/classification/ontology_classifier.py`</li>
<li>**Validator Logic:** `src/services/classification/ontology_validator.py`</li>
<li>**Config Schema:** `src/services/classification/config.py`</li>
<li>**Prompt Template:** `config/prompts/ontology_classification.yaml`</li>
<li>**Tests:** `tests/services/classification/test_ontology_classifier.py`</li>
</ul>

<p>---</p>

<p><strong>Review Completed:</strong> 2025-10-15</p>
<p><strong>Reviewer:</strong> Claude Code (Architecture Review Agent)</p>
<p><strong>Next Action:</strong> Create term-based specification document before implementation</p>
<p><strong>Risk Level:</strong> HIGH - Implementation without specification will fail</p>

  </div>
</body>
</html>