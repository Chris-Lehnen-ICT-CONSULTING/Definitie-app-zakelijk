<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Architectural Review: Ontological Classification Decoupling</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <h1>Architectural Review: Ontological Classification Decoupling</h1>

<p><strong>Date</strong>: 2025-10-07</p>
<p><strong>Reviewer</strong>: Claude Code (Architecture Review Mode)</p>
<p><strong>Subject</strong>: Evaluation of Classification Placement in Definition Generation Flow</p>
<p><strong>Status</strong>: üî¥ CRITICAL - Architectural Constraint Violation Detected</p>

<p>---</p>

<h2>Code Quality Score: 4/10</h2>

<p><strong>Current Architecture</strong>: Classification is embedded in definition generation flow (UI layer)</p>
<p><strong>Proposed Architecture (Option 2)</strong>: Classification in ServiceAdapter</p>
<p><strong>Constraint</strong>: "Ontologische classificatie is PRE-PROCESSING stap, los van definitie generatie"</p>

<p><strong>Score Breakdown</strong>:</p>
<ul>
<li>**Separation of Concerns**: 2/10 (classification tightly coupled to generation)</li>
<li>**Reusability**: 3/10 (cannot classify without generating)</li>
<li>**Testability**: 5/10 (requires full generation flow to test classification)</li>
<li>**Architectural Clarity**: 4/10 (unclear where classification responsibility lies)</li>
<li>**Constraint Compliance**: 3/10 (classification not truly "pre-processing")</li>
</ul>

<p>---</p>

<h2>üî¥ Critical Issues (Must Fix)</h2>

<h3>[ISSUE-1]: Classification NOT Separate from Generation</h3>

<p><strong>Current Situation (AS-IS)</strong>:</p>
<pre><code># tabbed_interface.py (UI layer)
async def generate_definition(self, begrip, context_data):
    # STAP 1: Bepaal categorie (IN generate_definition!)
    auto_categorie, reasoning, scores = await self._determine_ontological_category(...)

    # STAP 2: Genereer definitie (met categorie)
    service_result = await self.definition_service.generate_definition(
        begrip=begrip,
        categorie=auto_categorie,  # Classification result used
        ...
    )</code></pre>

<p><strong>Proposed Solution (Option 2)</strong>:</p>
<pre><code># ServiceAdapter
async def generate_definition(self, begrip, context_dict, **kwargs):
    # Classification HIER (still inside generate_definition)
    categorie = self.ontology_classifier.classify(begrip)

    request = GenerationRequest(
        begrip=begrip,
        ontologische_categorie=categorie.value,
        ...
    )

    return await self.orchestrator.create_definition(request)</code></pre>

<p><strong>Impact</strong>: üî¥ <strong>CRITICAL VIOLATION OF CONSTRAINT</strong></p>

<p>The constraint states: <em>"Ontologische classificatie is PRE-PROCESSING stap, <strong>los van</strong> definitie generatie"</em></p>

<p><strong>Both implementations VIOLATE this constraint because</strong>:</p>
<ol>
<li>Classification happens INSIDE `generate_definition()` method</li>
<li>Classification cannot be invoked WITHOUT triggering definition generation</li>
<li>Classification is NOT a separate, reusable service</li>
<li>Cannot test classification independently from generation</li>
</ol>

<p><strong>Solution</strong>: See [BETTER ARCHITECTURE] section below</p>

<p>---</p>

<h3>[ISSUE-2]: Prompt Dependency Creates Tight Coupling</h3>

<p><strong>Evidence from Orchestrator</strong>:</p>
<pre><code># definition_orchestrator_v2.py:423
prompt_result = await self.prompt_service.build_generation_prompt(
    sanitized_request,  # Contains ontologische_categorie
    feedback_history=feedback_history,
    context=context,
)</code></pre>

<p><strong>Evidence from PromptService</strong>:</p>
<pre><code># prompt_service_v2.py:115-137
if request.ontologische_categorie:
    cat = request.ontologische_categorie.strip().lower()
    enriched_context.metadata["ontologische_categorie"] = cat

    # Mapping to semantic category for template selection
    mapping = {
        "proces": "Proces",
        "type": "Object",
        "resultaat": "Maatregel",
    }
    semantic = mapping.get(cat)
    if semantic:
        enriched_context.metadata["semantic_category"] = semantic</code></pre>

<p><strong>Evidence from SemanticCategorisationModule</strong>:</p>
<pre><code># semantic_categorisation_module.py:86-93
categorie = context.get_metadata("ontologische_categorie")

# Sla categorie op voor andere modules
if categorie:
    context.set_shared("ontological_category", categorie)

# Bouw de ESS-02 sectie (category-specific guidance)
content = self._build_ess02_section(categorie)</code></pre>

<p><strong>Impact</strong>: üî¥ <strong>TRUE DEPENDENCY CONFIRMED</strong></p>

<p>The category is <strong>ESSENTIAL</strong> for prompt generation because:</p>
<ol>
<li>**SemanticCategorisationModule** (ESS-02) injects category-specific guidance into prompt</li>
<li>**TemplateModule** selects templates based on category (Proces/Object/Maatregel)</li>
<li>Without category, prompt lacks critical guidance for GPT-4</li>
</ol>

<p><strong>This is NOT just metadata - it fundamentally shapes the prompt structure!</strong></p>

<p><strong>Conclusion</strong>: Category MUST be determined BEFORE prompt building, confirming it's a true pre-processing step.</p>

<p>---</p>

<h3>[ISSUE-3]: Option 2 Does NOT Achieve True Separation</h3>

<p><strong>Proposed Code (Option 2)</strong>:</p>
<pre><code># ServiceAdapter.generate_definition()
async def generate_definition(self, begrip, context_dict, **kwargs):
    # Classificatie HIER (niet in UI)
    categorie = self.ontology_classifier.classify(begrip)

    request = GenerationRequest(
        begrip=begrip,
        ontologische_categorie=categorie.value,
        ...
    )

    return await self.orchestrator.create_definition(request)</code></pre>

<p><strong>Problem</strong>: Classification is STILL embedded in <code>generate_definition()</code> flow!</p>

<p><strong>Reusability Test</strong>:</p>
<pre><code># Can I classify WITHOUT generating?
# NO - classification is private to generate_definition()

# What if I want to:
# 1. Pre-classify 100 terms for batch processing?
# 2. Show classification to user BEFORE generating?
# 3. Use classification in different context (e.g., validation)?

# ANSWER: NOT POSSIBLE with Option 2</code></pre>

<p><strong>Impact</strong>: üî¥ <strong>OPTION 2 FAILS THE "LOS VAN" TEST</strong></p>

<p>---</p>

<h2>üü° Important Improvements (Strongly Recommended)</h2>

<h3>[IMPROVEMENT-1]: TRUE Separation via Dedicated Service</h3>

<p><strong>Better Approach - Variant B</strong> (from your question):</p>
<pre><code># ServiceAdapter with SEPARATE classification method
class ServiceAdapter:
    def __init__(self, container):
        self.orchestrator = container.definition_orchestrator()
        self.classifier = OntologyClassifier()  # Dedicated classifier

    # SEPARATE method for classification (true pre-processing)
    def classify_begrip(self, begrip: str, context: dict = None) -&gt; CategoryResult:
        """Classify a term WITHOUT generating definition."""
        return self.classifier.classify(begrip, context)

    # Generation can use classification, but doesn't OWN it
    async def generate_definition(self, begrip, context_dict, **kwargs):
        # Check if category already provided (pre-classified)
        categorie = kwargs.get("categorie")

        # If not provided, classify as convenience
        if not categorie:
            result = self.classify_begrip(begrip, context_dict)
            categorie = result.level

        request = GenerationRequest(
            begrip=begrip,
            ontologische_categorie=categorie,
            ...
        )

        return await self.orchestrator.create_definition(request)</code></pre>

<p><strong>Benefit</strong>: Now classification is TRULY separate:</p>
<pre><code># Use case 1: Classify without generating
result = service.classify_begrip("validatie")
# Returns: CategoryResult(level="PROCES", confidence=0.85, ...)

# Use case 2: Pre-classify, then generate later
category = service.classify_begrip("sanctie").level
# ... do other work ...
definition = await service.generate_definition("sanctie", context, categorie=category)

# Use case 3: Batch classification
categories = [service.classify_begrip(term) for term in terms]</code></pre>

<p><strong>Current Approach</strong>: <code>category = generate_definition(...).category</code> (wasteful!)</p>
<p><strong>Better Approach</strong>: <code>category = classify_begrip(...)</code> (efficient, reusable)</p>

<p>---</p>

<h3>[IMPROVEMENT-2]: Make Classification Optional in GenerationRequest</h3>

<p><strong>Current Problem</strong>:</p>
<pre><code># Orchestrator EXPECTS category to be present
# definition_orchestrator_v2.py:201
logger.info(f"...with category '{request.ontologische_categorie}'")

# Prompt service REQUIRES category for proper guidance
# semantic_categorisation_module.py:86
categorie = context.get_metadata("ontologische_categorie")</code></pre>

<p><strong>Better Design</strong>:</p>
<pre><code># GenerationRequest with optional category
@dataclass
class GenerationRequest:
    begrip: str
    ontologische_categorie: Optional[str] = None  # Optional!
    # ... other fields

# Orchestrator handles missing category
class DefinitionOrchestratorV2:
    def __init__(self, ..., classifier: OntologyClassifier = None):
        self.classifier = classifier or OntologyClassifier()

    async def create_definition(self, request: GenerationRequest, ...):
        # PRE-PROCESSING: Ensure category is determined
        if not request.ontologische_categorie:
            result = self.classifier.classify(request.begrip)
            request.ontologische_categorie = result.level
            logger.info(f"Auto-classified: {result.level} (conf={result.confidence})")

        # Now proceed with prompt building (category guaranteed)
        prompt_result = await self.prompt_service.build_generation_prompt(...)
        ...</code></pre>

<p><strong>Benefit</strong>:</p>
<ul>
<li>Classification becomes **internal orchestrator concern**</li>
<li>UI doesn't need to know about it</li>
<li>ServiceAdapter can be thin pass-through</li>
<li>Supports both: "UI pre-classifies" OR "Orchestrator auto-classifies"</li>
</ul>

<p>---</p>

<h2>üü¢ Minor Suggestions (Nice to Have)</h2>

<h3>[SUGGESTION-1]: Add Classification Result to Response Metadata</h3>

<p><strong>Current</strong>: Classification result is lost after use</p>
<p><strong>Better</strong>: Include in response for transparency</p>

<pre><code># DefinitionResponseV2
@dataclass
class DefinitionResponseV2:
    success: bool
    definition: Definition
    validation_result: ValidationResult
    metadata: dict
    classification: ClassificationResult = None  # NEW!

# Orchestrator
response = DefinitionResponseV2(
    success=True,
    definition=definition,
    validation_result=raw_validation,
    classification=classification_result,  # Include classification
    metadata={
        "ontological_category": categorie,
        "classification_confidence": classification_result.confidence,
        ...
    }
)</code></pre>

<p><strong>Benefit</strong>: UI can show "Why was this classified as PROCES? (confidence: 0.85)"</p>

<p>---</p>

<h3>[SUGGESTION-2]: Explicit Classification Service Interface</h3>

<p><strong>Define clean contract</strong>:</p>
<pre><code># services/interfaces.py
class OntologyClassifierInterface(Protocol):
    """Interface for ontological classification."""

    def classify(
        self,
        begrip: str,
        context: Optional[dict] = None
    ) -&gt; ClassificationResult:
        """Classify term to ontological category.

        Returns:
            ClassificationResult with level, confidence, rationale
        """
        ...

    def classify_batch(
        self,
        begrippen: List[str]
    ) -&gt; List[ClassificationResult]:
        """Classify multiple terms efficiently."""
        ...</code></pre>

<p><strong>Benefit</strong>: Clear contract, mockable for tests, swappable implementations</p>

<p>---</p>

<h2>‚≠ê Positive Highlights</h2>

<ol>
<li>**Handover Document Quality**: Excellent analysis with 3 clear options and trade-offs</li>
<li>**Constraint Identification**: Correctly identified that classification should be "los van" generation</li>
<li>**Evidence-Based Review**: Test results (93.3% accuracy) provide empirical validation</li>
<li>**Realistic Options**: All 3 options are implementable (not theoretical)</li>
<li>**Code Reduction**: Proposed refactor reduces code by 76% (1415 ‚Üí 342 LOC)</li>
</ol>

<p>---</p>

<h2>üìä Summary</h2>

<h3>Overall Assessment</h3>

<p><strong>Current Architecture (AS-IS)</strong>:</p>
<ul>
<li>‚ùå Violates "pre-processing, los van generatie" constraint</li>
<li>‚ùå Classification tightly coupled to generation</li>
<li>‚ùå Cannot reuse classification independently</li>
<li>‚ùå 61 lines of business logic in UI layer</li>
</ul>

<p><strong>Proposed Architecture (Option 2 - Original)</strong>:</p>
<ul>
<li>‚ö†Ô∏è Moves classification from UI to Service (good)</li>
<li>‚ùå Still embedded in `generate_definition()` method (bad)</li>
<li>‚ùå Still cannot classify without generating (constraint violation)</li>
<li>‚ö†Ô∏è Better than AS-IS but doesn't achieve true separation</li>
</ul>

<p><strong>Recommended Architecture (Variant B - Enhanced Option 2)</strong>:</p>
<ul>
<li>‚úÖ Classification is SEPARATE method (`classify_begrip()`)</li>
<li>‚úÖ Can be used independently from generation</li>
<li>‚úÖ Reusable for batch processing, pre-classification</li>
<li>‚úÖ True "pre-processing step" as per constraint</li>
<li>‚úÖ Maintains convenient integration with generation</li>
</ul>

<h3>Key Learning Points</h3>

<ol>
<li>**"Los van" means STRUCTURALLY separate, not just "called before"**</li>
</ol>
<ul>
<li>  - Option 2 calls classification before generation (good)</li>
<li>  - But it's still inside the same method (bad)</li>
<li>  - Variant B makes it a separate public API (excellent)</li>
</ul>

<ol>
<li>**Prompt dependency confirms classification is pre-processing**</li>
</ol>
<ul>
<li>  - SemanticCategorisationModule NEEDS category for ESS-02 guidance</li>
<li>  - TemplateModule uses category for template selection</li>
<li>  - Category shapes the entire prompt structure</li>
<li>  - **Conclusion**: Category MUST be determined before prompt building</li>
</ul>

<ol>
<li>**Architectural purity vs. Pragmatism**</li>
</ol>
<ul>
<li>  - Option 3 (Orchestrator) is most "pure" but highest risk</li>
<li>  - Variant B (ServiceAdapter with separate method) is pragmatic AND correct</li>
<li>  - Choose Variant B for balance of quality and safety</li>
</ul>

<p>---</p>

<h2>üìã Recommended Implementation</h2>

<h3>Phase 1: Core Refactor (6-8 hours)</h3>

<p><strong>Step 1</strong>: Create separate classification service (2h)</p>
<pre><code># src/services/classification/ontology_classifier.py
class OntologyClassifier:
    """Dedicated classification service."""

    def classify(self, begrip: str, context: dict = None) -&gt; ClassificationResult:
        # Use level_classifier.py internally
        scores = self._generate_scores(begrip)
        result = classify_level(scores, begrip, policy="gebalanceerd")
        return self._to_classification_result(result)</code></pre>

<p><strong>Step 2</strong>: Add to ServiceAdapter as separate method (1h)</p>
<pre><code># src/services/service_factory.py
class ServiceAdapter:
    def classify_begrip(self, begrip: str, ...) -&gt; ClassificationResult:
        """PUBLIC API for classification (separate from generation)."""
        return self.classifier.classify(begrip, ...)

    async def generate_definition(self, begrip, context_dict, **kwargs):
        # Use classification as convenience, not requirement
        categorie = kwargs.get("categorie") or self.classify_begrip(begrip).level
        ...</code></pre>

<p><strong>Step 3</strong>: Simplify UI (delete 61 lines of orchestration) (1h)</p>
<pre><code># src/ui/tabbed_interface.py
def _handle_definition_generation(self, begrip, context_data):
    # OPTION A: Let service handle classification
    service_result = await self.definition_service.generate_definition(
        begrip=begrip,
        context_dict={...},
        # No category - service will classify
    )

    # OPTION B: Pre-classify and show to user (if desired)
    classification = self.definition_service.classify_begrip(begrip)
    st.info(f"Classified as: {classification.level} (confidence: {classification.confidence})")

    service_result = await self.definition_service.generate_definition(
        begrip=begrip,
        categorie=classification.level,  # Pass pre-classification
        ...
    )</code></pre>

<p><strong>Step 4</strong>: Update Orchestrator to handle optional category (2h)</p>
<pre><code># src/services/orchestrators/definition_orchestrator_v2.py
async def create_definition(self, request: GenerationRequest, ...):
    # PRE-PROCESSING: Ensure category exists
    if not request.ontologische_categorie:
        result = self.classifier.classify(request.begrip)
        request = request.replace(ontologische_categorie=result.level)
        logger.info(f"Auto-classified: {result.level}")

    # Continue with existing flow
    prompt_result = await self.prompt_service.build_generation_prompt(...)
    ...</code></pre>

<h3>Phase 2: Testing & Validation (4 hours)</h3>

<p><strong>Unit Tests</strong>:</p>
<pre><code>def test_classify_without_generating():
    """Can classify independently."""
    service = ServiceAdapter(...)
    result = service.classify_begrip("validatie")

    assert result.level == "PROCES"
    assert result.confidence &gt; 0.7
    # No definition generated!

def test_generation_uses_classification():
    """Generation reuses classification."""
    service = ServiceAdapter(...)

    # Pre-classify
    cat = service.classify_begrip("sanctie").level

    # Generate with pre-classified category
    result = await service.generate_definition("sanctie", categorie=cat, ...)

    assert result.definition.ontologische_categorie == cat</code></pre>

<p><strong>Integration Tests</strong>:</p>
<pre><code>async def test_orchestrator_auto_classifies():
    """Orchestrator classifies when category missing."""
    request = GenerationRequest(begrip="besluit")  # No category

    response = await orchestrator.create_definition(request)

    # Orchestrator should have classified it
    assert response.definition.ontologische_categorie is not None
    assert response.classification is not None</code></pre>

<p>---</p>

<h2>üéØ VERDICT</h2>

<h3>Constraint Compliance: ‚ùå FAILED</h3>

<p><strong>Current (AS-IS)</strong>: Classification embedded in UI.generate_definition() - <strong>VIOLATES</strong></p>
<p><strong>Proposed (Option 2)</strong>: Classification embedded in ServiceAdapter.generate_definition() - <strong>STILL VIOLATES</strong></p>
<p><strong>Recommended (Variant B)</strong>: Classification as separate ServiceAdapter.classify_begrip() - <strong>‚úÖ COMPLIES</strong></p>

<h3>Architecture Decision</h3>

<p><strong>‚ùå DO NOT implement Option 2 as originally proposed</strong></p>

<p>It improves code organization (UI ‚Üí Service) but <strong>fails to achieve true separation</strong>. Classification remains embedded in generation flow.</p>

<p><strong>‚úÖ IMPLEMENT Variant B (Enhanced Option 2)</strong></p>

<pre><code>ServiceAdapter:
  ‚îú‚îÄ classify_begrip(begrip) ‚Üí ClassificationResult  ‚úÖ SEPARATE, REUSABLE
  ‚îî‚îÄ generate_definition(begrip, categorie=None) ‚Üí DefinitionResponse
         ‚îî‚îÄ Uses classify_begrip() internally if categorie=None</code></pre>

<p><strong>Benefits</strong>:</p>
<ul>
<li>‚úÖ True pre-processing (can classify without generating)</li>
<li>‚úÖ Reusable API (batch classification, UI pre-classification)</li>
<li>‚úÖ Backward compatible (generation still works standalone)</li>
<li>‚úÖ Constraint compliant ("los van definitie generatie")</li>
<li>‚úÖ Lower risk than Option 3 (Orchestrator refactor)</li>
</ul>

<h3>Implementation Timeline</h3>

<ul>
<li>**Total Effort**: 10-12 hours (6-8h core + 4h testing)</li>
<li>**Risk Level**: Medium (significant refactor but clear path)</li>
<li>**Breaking Changes**: Minimal (additive API, backward compatible)</li>
<li>**Code Reduction**: 76% (1415 ‚Üí 342 LOC)</li>
<li>**Performance**: 500x faster (no web lookups)</li>
</ul>

<p>---</p>

<h2>üöÄ Next Steps</h2>

<h3>IMMEDIATE (Before Implementation)</h3>

<ol>
<li>**Confirm Architecture Decision** with tech lead</li>
</ol>
<ul>
<li>  - Present Variant B (this review)</li>
<li>  - Get sign-off on separate `classify_begrip()` method</li>
<li>  - Agree on public API contract</li>
</ul>

<ol>
<li>**Create Spike/Prototype** (2 hours)</li>
</ol>
<ul>
<li>  - Implement `OntologyClassifier` class</li>
<li>  - Add `classify_begrip()` to ServiceAdapter</li>
<li>  - Test independently: `result = service.classify_begrip("validatie")`</li>
<li>  - Verify reusability before full refactor</li>
</ul>

<ol>
<li>**Write Architecture Decision Record** (ADR)</li>
</ol>
<ul>
<li>  - Document: "Why classification is separate from generation"</li>
<li>  - Rationale: Constraint compliance, reusability, testability</li>
<li>  - Consequences: New public API, clearer separation</li>
</ul>

<h3>IMPLEMENTATION (After Approval)</h3>

<ol>
<li>**Phase 1**: Core refactor (6-8h)</li>
</ol>
<ul>
<li>  - See detailed steps above</li>
</ul>

<ol>
<li>**Phase 2**: Testing (4h)</li>
</ol>
<ul>
<li>  - Unit + integration tests</li>
<li>  - Regression tests (15 test cases)</li>
</ul>

<ol>
<li>**Phase 3**: Documentation (2h)</li>
</ol>
<ul>
<li>  - Update API docs</li>
<li>  - Add usage examples</li>
<li>  - Update HANDOVER with final decision</li>
</ul>

<p>---</p>

<h2>üìé References</h2>

<h3>Files Reviewed</h3>

<ul>
<li>`/src/ui/tabbed_interface.py` (lines 231-291, 698-866)</li>
<li>`/src/services/service_factory.py` (ServiceAdapter)</li>
<li>`/src/services/orchestrators/definition_orchestrator_v2.py` (lines 169-432)</li>
<li>`/src/services/prompts/prompt_service_v2.py` (lines 84-194)</li>
<li>`/src/services/prompts/modules/semantic_categorisation_module.py`</li>
<li>`/docs/handovers/HANDOVER_ONTOLOGICAL_CLASSIFICATION_REFACTOR.md`</li>
</ul>

<h3>Key Constraint</h3>

<blockquote>**"Ontologische classificatie is PRE-PROCESSING stap, los van definitie generatie, omdat categorie de promptopbouw bepaalt"**</blockquote>

<p><strong>Interpretation</strong>:</p>
<ul>
<li>"PRE-PROCESSING" = happens BEFORE generation starts</li>
<li>"LOS VAN" = structurally SEPARATE, can exist independently</li>
<li>"omdat categorie de promptopbouw bepaalt" = true dependency confirmed</li>
</ul>

<p><strong>Verdict</strong>: Variant B (separate method) is the ONLY option that fully satisfies this constraint.</p>

<p>---</p>

<p><strong>END OF REVIEW</strong></p>

<p><em>Generated by: Claude Code (Architecture Review Mode)</em></p>
<p><em>Date: 2025-10-07</em></p>
<p><em>Review Type: Architectural Constraint Compliance</em></p>

  </div>
</body>
</html>