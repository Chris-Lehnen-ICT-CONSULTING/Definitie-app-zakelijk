<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Streamlit Best Practices & Anti-Patterns</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">â† Terug naar Portal</a>
    <h1>Streamlit Best Practices & Anti-Patterns</h1>

<p><strong>Status:</strong> Active | <strong>Last Updated:</strong> 2025-11-06 | <strong>Source:</strong> DEF-56 & DEF-110 Root Cause Analysis</p>

<p>Deze richtlijnen zijn gebaseerd op concrete bugs gevonden in DefinitieAgent en gevalideerd door Streamlit officiÃ«le documentatie (Context7 MCP) en deep research (Perplexity MCP).</p>

<p>---</p>

<h2>ğŸ¯ Core Principle: Key-Only Widget Pattern</h2>

<p><strong>REGEL:</strong> Gebruik ALLEEN <code>key</code> parameter voor widgets die session state gebruiken. <strong>NOOIT</strong> <code>value</code> + <code>key</code> combineren.</p>

<h3>âœ… CORRECT Pattern</h3>

<pre><code>import streamlit as st
from ui.session_state import SessionStateManager

# 1ï¸âƒ£ Initialize session state VOOR widget declaratie
state_key = "my_text_area"
if not SessionStateManager.get_value(state_key):
    SessionStateManager.set_value(state_key, "default value")

# 2ï¸âƒ£ Widget met ALLEEN key parameter
text = st.text_area(
    "Label",
    key=state_key,  # âœ… Key only
    help="Help text"
)

# 3ï¸âƒ£ Gebruik widget return value of haal op uit session state
value = SessionStateManager.get_value(state_key)</code></pre>

<h3>âŒ INCORRECT Pattern (Race Condition!)</h3>

<pre><code># âŒ NEVER DO THIS: value + key combinatie
text = st.text_area(
    "Label",
    value=some_variable,  # âŒ Race condition!
    key=state_key         # Widget bewaart oude state
)</code></pre>

<p><strong>Waarom dit fout gaat:</strong></p>
<ol>
<li>Widget krijgt `value="old data"` bij eerste render</li>
<li>User genereert nieuwe data â†’ `some_variable` wordt ge-update</li>
<li>`st.rerun()` triggert page refresh</li>
<li>Widget's interne state blijft "old data" â†’ **nieuwe `value` wordt genegeerd**</li>
<li>Result: Widget toont oude data ondanks correcte session state</li>
</ol>

<p>---</p>

<h2>ğŸ”„ State Synchronization Pattern</h2>

<h3>Scenario: AI-Gegenereerde Content in Text Areas</h3>

<p><strong>Use Case:</strong> Genereer data met AI, vul text areas, preserveer user edits.</p>

<pre><code>from typing import Any
from ui.session_state import SessionStateManager

def sync_data_to_widgets(
    data: dict[str, Any],
    prefix: str,
    force_overwrite: bool = False
) -&gt; None:
    """Sync data dictionary naar Streamlit widget session keys.

    Args:
        data: Dictionary met veld data
        prefix: Session key prefix (bijv. 'edit_42')
        force_overwrite: True = overschrijf alles (post-generatie)
                        False = preserveer bestaande values (pre-widget)
    """
    for field_name, widget_suffix in FIELD_CONFIG:
        widget_key = f"{prefix}_{widget_suffix}"

        # Skip als al gezet EN niet force (preserveer user edits)
        if not force_overwrite:
            existing = SessionStateManager.get_value(widget_key, None)
            if existing is not None:
                continue

        # Haal data op en format
        value = data.get(field_name, "")
        formatted = format_value(value)  # bijv. list â†’ "\n".join()

        # Schrijf naar session state
        SessionStateManager.set_value(widget_key, formatted)

# VOOR widget declaratie (preserveer edits)
sync_data_to_widgets(current_data, "edit_23", force_overwrite=False)

# Declareer widgets (key-only!)
st.text_area("Field 1", key="edit_23_field1")
st.text_area("Field 2", key="edit_23_field2")

# NA AI generatie (force sync)
new_data = generate_with_ai()
sync_data_to_widgets(new_data, "edit_23", force_overwrite=True)
st.rerun()  # Widgets tonen nieuwe data na rerun</code></pre>

<p>---</p>

<h2>ğŸ—ï¸ Architecture Compliance</h2>

<h3>SessionStateManager is MANDATORY</h3>

<p><strong>REGEL:</strong> Alle <code>st.session_state</code> toegang MOET via <code>SessionStateManager</code>.</p>

<h4>âœ… CORRECT</h4>

<pre><code>from ui.session_state import SessionStateManager

# Read
value = SessionStateManager.get_value("my_key", default="fallback")

# Write
SessionStateManager.set_value("my_key", new_value)

# Clear
SessionStateManager.clear_value("my_key")</code></pre>

<h4>âŒ INCORRECT</h4>

<pre><code>import streamlit as st

# âŒ NEVER direct access
value = st.session_state.get("my_key")
st.session_state["my_key"] = new_value
del st.session_state["my_key"]</code></pre>

<p><strong>Waarom:</strong></p>
<ul>
<li>Centrale controle over state management</li>
<li>Debuggen en logging op Ã©Ã©n plek</li>
<li>Voorkomt circulaire dependencies</li>
<li>Consistent met DefinitieAgent architectuur</li>
</ul>

<p>---</p>

<h2>ğŸš« Common Anti-Patterns</h2>

<h3>1. Widget State Pollution</h3>

<p><strong>Problem:</strong> Widget state blijft hangen tussen tabs/sessions.</p>

<pre><code># âŒ BAD: Generieke keys zonder context
st.text_input("Name", key="name")  # Conflict tussen tabs!

# âœ… GOOD: Context-specific keys
st.text_input("Name", key=f"{context}_name")
st.text_input("Name", key="edit_23_name")</code></pre>

<h3>2. Conditional Widget Keys</h3>

<p><strong>Problem:</strong> Widget keys veranderen tussen reruns â†’ state verlies.</p>

<pre><code># âŒ BAD: Conditie kan wijzigen
key = "edit" if editing else "view"
st.text_input("Name", key=key)  # Key wijzigt â†’ state reset!

# âœ… GOOD: Stable keys
if editing:
    st.text_input("Name", key="name_edit")
else:
    st.text_input("Name", key="name_view", disabled=True)</code></pre>

<h3>3. Late State Initialization</h3>

<p><strong>Problem:</strong> Widget wordt gedeclareerd voordat session state is ge-initialiseerd.</p>

<pre><code># âŒ BAD: Widget voor state init
st.text_area("Text", key="my_text")
st.session_state["my_text"] = "default"  # Te laat!

# âœ… GOOD: State voor widget
SessionStateManager.set_value("my_text", "default")
st.text_area("Text", key="my_text")</code></pre>

<h3>4. State Mutation in render() Methods (DEF-110)</h3>

<p><strong>Problem:</strong> State mutations in render() methods triggeren rerun cascades â†’ 74,569% performance regression.</p>

<p><strong>Root Cause:</strong> Streamlit's purity principle vereist dat render() methods PURE zijn (geen side effects).</p>

<pre><code># âŒ CRITICAL: State mutation in render() â†’ Rerun cascade!
class TabbedInterface:
    def render(self):
        """Render de volledige tabbed interface."""
        # âŒ NEVER DO THIS: force_clean=True triggers state mutation
        init_context_cleaner(force_clean=True)  # â† Causes cascade!

        # App header
        self._render_header()
        # ...

# âœ… CORRECT: State cleanup in app initialization (main.py)
def main():
    """Hoofd applicatie functie."""
    # Initialize session state ONCE at app startup
    SessionStateManager.initialize_session_state()

    # init_context_cleaner() is called via default values
    # OR with force_clean=False (idempotent guard)

    # Render interface (PURE - no state mutations!)
    interface = get_tabbed_interface()
    interface.render()  # âœ… Pure render</code></pre>

<p><strong>Mechanisme van de Cascade:</strong></p>
<ol>
<li>`render()` method roept `init_context_cleaner(force_clean=True)` aan</li>
<li>Dit muteert session state â†’ Streamlit detecteert change</li>
<li>Streamlit triggert RERUN â†’ nieuwe Python process</li>
<li>Alle singletons gereset (RuleCache, ServiceContainer, etc.)</li>
<li>**Repeat 4x** â†’ 4x startup overhead</li>
</ol>

<p><strong>Impact (DEF-110):</strong></p>
<ul>
<li>Startup: 1.2s â†’ 35s (2,817% regressie)</li>
<li>RuleCache: 1x load â†’ 4x loads</li>
<li>ServiceContainer: 1x init â†’ 4x inits</li>
<li>Alle US-202, DEF-66, DEF-90 optimalisaties tenietgedaan</li>
</ul>

<p><strong>Preventie:</strong></p>
<ul>
<li>âœ… **NEVER** call cleanup/state mutation functions in render()</li>
<li>âœ… Use idempotent guards (`if context_cleaned is None`)</li>
<li>âœ… Cleanup in `main()` initialization, NOT render()</li>
<li>âœ… Pre-commit hook detecteert `force_clean=True` in render methods</li>
</ul>

<p><strong>Enforcement (Pre-Commit):</strong></p>
<pre><code># Automated check in scripts/check_streamlit_patterns.py
- Detect force_clean=True in any UI code â†’ CRITICAL ERROR
- Warn on state mutations in render() methods â†’ HIGH WARNING</code></pre>

<p><strong>Reference:</strong> <code>docs/backlog/EPIC-XXX/DEF-110/DEF-110-postmortem.md</code></p>

<p>---</p>

<h2>ğŸ§ª Testing Patterns</h2>

<h3>Unit Test: State Synchronization</h3>

<pre><code>import pytest
from ui.session_state import SessionStateManager
from unittest.mock import patch, MagicMock

@patch('streamlit.session_state', new_callable=dict)
def test_sync_preserves_user_edits(mock_session_state):
    """Test dat sync user edits NIET overschrijft."""
    # Setup: User heeft edit gemaakt
    SessionStateManager.set_value("edit_23_field1", "user edit")

    # Act: Sync nieuwe data met force_overwrite=False
    new_data = {"field1": "ai generated"}
    sync_data_to_widgets(new_data, "edit_23", force_overwrite=False)

    # Assert: User edit is gepreserveerd
    assert SessionStateManager.get_value("edit_23_field1") == "user edit"

@patch('streamlit.session_state', new_callable=dict)
def test_sync_force_overwrite(mock_session_state):
    """Test dat force sync user edits WEL overschrijft."""
    # Setup: User heeft edit gemaakt
    SessionStateManager.set_value("edit_23_field1", "user edit")

    # Act: Sync met force_overwrite=True
    new_data = {"field1": "ai generated"}
    sync_data_to_widgets(new_data, "edit_23", force_overwrite=True)

    # Assert: AI data heeft user edit overschreven
    assert SessionStateManager.get_value("edit_23_field1") == "ai generated"</code></pre>

<h3>Integration Test: Widget Behavior</h3>

<pre><code>from streamlit.testing.v1 import AppTest

def test_text_area_populates_after_generation():
    """Test dat text areas gevuld worden na AI generatie."""
    at = AppTest.from_file("src/main.py")
    at.run()

    # Navigate to Bewerk tab
    at.sidebar.selectbox[0].select("Bewerk definitie")
    at.run()

    # Trigger generation
    generate_button = at.button("âœ¨ Genereer voorbeelden (AI)")
    generate_button.click()
    at.run()

    # Assert: Text areas are populated
    text_areas = at.text_area
    assert len(text_areas[0].value) &gt; 0  # Voorbeeldzinnen
    assert len(text_areas[1].value) &gt; 0  # Praktijkvoorbeelden</code></pre>

<p>---</p>

<h2>ğŸ“‹ Pre-Flight Checklist</h2>

<p><strong>Voor elke nieuwe Streamlit component:</strong></p>

<ul>
<li>[ ] Widget gebruikt key-only pattern (GEEN `value` parameter)</li>
<li>[ ] Session state geÃ¯nitialiseerd VOOR widget declaratie</li>
<li>[ ] Key is context-specific (geen generieke keys)</li>
<li>[ ] SessionStateManager gebruikt (GEEN directe `st.session_state`)</li>
<li>[ ] Conditional logic beÃ¯nvloedt NIET widget keys</li>
<li>[ ] Error handling voor state access</li>
<li>[ ] Unit tests voor state sync logic</li>
</ul>

<p>---</p>

<h2>ğŸ” Debugging Tips</h2>

<h3>Widget Toont Verkeerde Data</h3>

<p><strong>Symptoom:</strong> Widget content komt niet overeen met session state.</p>

<p><strong>Checklist:</strong></p>
<ol>
<li>âœ… Check widget gebruikt key-only pattern (geen `value`)</li>
<li>âœ… Check session state is ge-set VOOR widget declaratie</li>
<li>âœ… Check widget key is correct (geen typo's)</li>
<li>âœ… Log session state value direct voor widget:</li>
<pre><code>   value = SessionStateManager.get_value("my_key")
   logger.debug(f"Session state voor widget: {value}")
   st.text_area("Label", key="my_key")</code></pre>
</ol>

<h3>State Verdwijnt Na Rerun</h3>

<p><strong>Symptoom:</strong> Widget reset naar lege value na <code>st.rerun()</code>.</p>

<p><strong>Checklist:</strong></p>
<ol>
<li>âœ… Check widget key is stable (wijzigt NIET tussen reruns)</li>
<li>âœ… Check geen conditional logic wijzigt key</li>
<li>âœ… Check session state wordt NIET cleared tijdens rerun</li>
<li>âœ… Gebruik Streamlit Session State viewer:</li>
<pre><code>   if st.checkbox("Debug Session State"):
       st.write("Session State:", dict(st.session_state))</code></pre>
</ol>

<p>---</p>

<h2>ğŸ“š References</h2>

<ul>
<li>**DEF-56 Root Cause Analysis:** `docs/backlog/EPIC-XXX/US-XXX/DEF-56/DEF-56.md`</li>
<li>**Streamlit Docs (Context7):** Widget state management best practices</li>
<li>**Perplexity Research:** Streamlit widget lifecycle and race conditions</li>
<li>**SessionStateManager:** `src/ui/session_state.py`</li>
</ul>

<p>---</p>

<h2>âœ… Enforcement</h2>

<p><strong>Pre-Commit Hook:</strong> Detecteer Streamlit anti-patterns</p>

<pre><code># .pre-commit-config.yaml
- id: streamlit-anti-patterns
  name: Check Streamlit Anti-Patterns
  entry: python scripts/check_streamlit_patterns.py
  language: system
  files: 'src/ui/.*\.py$'</code></pre>

<p><strong>Automated Checks:</strong></p>
<ul>
<li>âŒ Detect `st.text_area(value=..., key=...)` combinatie â†’ **CRITICAL**</li>
<li>âŒ Detect direct `st.session_state[...]` access in UI modules â†’ **HIGH**</li>
<li>âŒ Detect generieke widget keys ("name", "text", etc.) â†’ **MEDIUM**</li>
<li>âŒ Detect `force_clean=True` in render() methods (DEF-110) â†’ **CRITICAL**</li>
<li>âš ï¸  Warn on state mutations in render() methods (DEF-110) â†’ **HIGH**</li>
<li>âœ… Enforce SessionStateManager import in UI modules</li>
</ul>

<p><strong>Performance Tests:</strong></p>
<ul>
<li>`tests/performance/test_def110_regression.py`: Monitor rerun cascades</li>
<li>Auto-fails bij: >1 rerun, >2 context cleanups, >15s startup</li>
<li>Validates: No `force_clean=True` in codebase</li>
</ul>

<p>---</p>

<p><strong>Status:</strong> Deze patterns zijn gevalideerd door DEF-56 en DEF-110 fixes en moeten worden toegepast op ALLE Streamlit components in DefinitieAgent.</p>

<p><strong>Performance Guarantee:</strong> Met deze patterns blijft startup tijd <5s, geen rerun cascades, en alle caching optimalisaties (US-202, DEF-66, DEF-90) blijven intact.</p>

  </div>
</body>
</html>