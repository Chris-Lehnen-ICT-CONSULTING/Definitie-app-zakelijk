<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Export Fix Implementation Guide</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <h1>Export Fix Implementation Guide</h1>

<p><strong>Quick Reference for Developer Implementing the Export Data Limitation Fix</strong></p>

<p><strong>Related Analysis:</strong> <code>docs/reports/EXPORT_DATA_LIMITATION_ANALYSIS.md</code></p>
<p><strong>Architecture Diagram:</strong> <code>docs/diagrams/export-architecture-problem.md</code></p>
<p><strong>Estimated Time:</strong> 7.5 hours</p>
<p><strong>Priority:</strong> HIGH (User-facing data loss)</p>

<p>---</p>

<h2>Pre-Implementation Checklist</h2>

<ul>
<li>[ ] Read full analysis: `EXPORT_DATA_LIMITATION_ANALYSIS.md`</li>
<li>[ ] Review current exports in `exports/` directory</li>
<li>[ ] Check for downstream systems parsing export files</li>
<li>[ ] Create backup branch: `git checkout -b feature/comprehensive-export`</li>
<li>[ ] Run existing tests: `pytest tests/services/test_export_service.py`</li>
<li>[ ] Document current export file structure</li>
</ul>

<p>---</p>

<h2>Implementation Steps</h2>

<h3>Step 1: Add to_export_dict() Method (1 hour)</h3>

<p><strong>File:</strong> <code>src/database/definitie_repository.py</code></p>

<p><strong>Location:</strong> Add after <code>to_dict()</code> method (around line 140)</p>

<pre><code>def to_export_dict(self, mode: str = 'full') -&gt; dict[str, Any]:
    """
    Convert to export dictionary with configurable field coverage.

    Args:
        mode: Export mode
            - 'full': All 28 user-facing fields (default)
            - 'legacy': 8 fields for backward compatibility
            - 'minimal': 5 core fields only

    Returns:
        Dictionary with fields based on mode
    """
    # Core fields (always included)
    core = {
        'begrip': self.begrip,
        'definitie': self.definitie,
        'categorie': self.categorie,
        'organisatorische_context': self.organisatorische_context,
        'status': self.status,
    }

    if mode == 'minimal':
        return core

    # Legacy 8-field mode
    if mode == 'legacy':
        return {
            **core,
            'validation_score': self.validation_score,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }

    # Full mode (28 fields)
    return {
        **core,
        # Context fields
        'juridische_context': self.juridische_context,
        'wettelijke_basis': self.wettelijke_basis,

        # Business logic
        'ufo_categorie': self.ufo_categorie,
        'toelichting_proces': self.toelichting_proces,

        # Versioning
        'version_number': self.version_number,
        'previous_version_id': self.previous_version_id,

        # Validation
        'validation_score': self.validation_score,
        'validation_date': self.validation_date.isoformat() if self.validation_date else None,
        'validation_issues': self.validation_issues,

        # Source tracking
        'source_type': self.source_type,
        'source_reference': self.source_reference,
        'imported_from': self.imported_from,

        # Terminology
        'voorkeursterm': self.voorkeursterm,

        # User attribution
        'created_by': self.created_by,
        'updated_by': self.updated_by,
        'created_at': self.created_at.isoformat() if self.created_at else None,
        'updated_at': self.updated_at.isoformat() if self.updated_at else None,

        # Approval workflow
        'approved_by': self.approved_by,
        'approved_at': self.approved_at.isoformat() if self.approved_at else None,
        'approval_notes': self.approval_notes,

        # Legacy fields
        'datum_voorstel': self.datum_voorstel.isoformat() if self.datum_voorstel else None,
        'ketenpartners': self.ketenpartners,

        # Internal fields EXCLUDED:
        # - last_exported_at (internal tracking)
        # - export_destinations (internal tracking)
        # - voorkeursterm_is_begrip (deprecated)
    }</code></pre>

<p><strong>Test:</strong> <code>tests/database/test_definitie_repository.py</code></p>

<pre><code>def test_to_export_dict_full():
    """Test full export includes all 28 user-facing fields."""
    record = DefinitieRecord(
        begrip="test",
        definitie="test definitie",
        categorie="ENT",
        organisatorische_context="DJI",
        juridische_context="strafrecht",
        wettelijke_basis='["Wbp"]',
        voorkeursterm="test term",
    )

    export = record.to_export_dict(mode='full')

    # Should have 28 fields
    assert len(export) == 28

    # Check critical fields
    assert export['begrip'] == "test"
    assert export['juridische_context'] == "strafrecht"
    assert export['voorkeursterm'] == "test term"

    # Should NOT include internal fields
    assert 'last_exported_at' not in export
    assert 'export_destinations' not in export

def test_to_export_dict_legacy():
    """Test legacy mode maintains backward compatibility."""
    record = DefinitieRecord(begrip="test", definitie="def", categorie="ENT")
    export = record.to_export_dict(mode='legacy')

    # Should have exactly 8 fields
    assert len(export) == 8
    assert set(export.keys()) == {
        'begrip', 'definitie', 'categorie', 'organisatorische_context',
        'status', 'validation_score', 'created_at', 'updated_at'
    }</code></pre>

<p>---</p>

<h3>Step 2: Add Bulk Export to ExportService (2 hours)</h3>

<p><strong>File:</strong> <code>src/services/export_service.py</code></p>

<p><strong>Location:</strong> Add after <code>export_definitie()</code> method (around line 175)</p>

<pre><code>def export_definitions_bulk(
    self,
    definitions: list[DefinitieRecord],
    format: ExportFormat = ExportFormat.TXT,
    filename_prefix: str = "definities_export",
) -&gt; str:
    """
    Export multiple definitions to a single file.

    Args:
        definitions: List of definitions to export
        format: Export format
        filename_prefix: Prefix for generated filename

    Returns:
        Path to exported file

    Raises:
        ValueError: If definitions list is empty
        NotImplementedError: If format is not supported
    """
    if not definitions:
        raise ValueError("No definitions provided for export")

    logger.info(f"Bulk export: {len(definitions)} definitions to {format.value}")

    if format == ExportFormat.TXT:
        return self._export_bulk_to_txt(definitions, filename_prefix)
    if format == ExportFormat.JSON:
        return self._export_bulk_to_json(definitions, filename_prefix)
    if format == ExportFormat.CSV:
        return self._export_bulk_to_csv(definitions, filename_prefix)

    msg = f"Bulk export format {format} not implemented"
    raise NotImplementedError(msg)

def _export_bulk_to_txt(
    self,
    definitions: list[DefinitieRecord],
    filename_prefix: str,
) -&gt; str:
    """Export multiple definitions to TXT format."""
    tijdstempel = datetime.now(UTC).strftime("%Y%m%d_%H%M%S")
    bestandsnaam = f"{filename_prefix}_{tijdstempel}.txt"
    pad = self.export_dir / bestandsnaam

    lines = [
        "=" * 80,
        f"DEFINITIE EXPORT - {len(definitions)} definities",
        f"Ge√´xporteerd op: {datetime.now(UTC).strftime('%Y-%m-%d %H:%M:%S')}",
        "=" * 80,
        "",
    ]

    for idx, definitie in enumerate(definitions, 1):
        # Convert to export dict
        export_dict = definitie.to_export_dict(mode='full')

        lines.extend([
            f"\n{'=' * 80}",
            f"DEFINITIE {idx}/{len(definitions)}",
            f"{'=' * 80}",
            "",
            f"üìò Begrip: {export_dict['begrip']}",
            f"üìù Definitie: {export_dict['definitie']}",
            "",
            f"üè∑Ô∏è  Categorie: {export_dict['categorie']}",
            f"üèõÔ∏è  UFO Categorie: {export_dict.get('ufo_categorie', 'n/a')}",
            f"üìä Status: {export_dict['status']}",
            "",
            "üìç Context:",
            f"  ‚Ä¢ Organisatorisch: {export_dict['organisatorische_context']}",
            f"  ‚Ä¢ Juridisch: {export_dict.get('juridische_context', 'n/a')}",
            f"  ‚Ä¢ Wettelijke basis: {export_dict.get('wettelijke_basis', 'n/a')}",
            "",
            f"üè∑Ô∏è  Voorkeursterm: {export_dict.get('voorkeursterm', 'n/a')}",
            f"üí° Toelichting: {export_dict.get('toelichting_proces', 'n/a')}",
            "",
            "‚úÖ Validatie:",
            f"  ‚Ä¢ Score: {export_dict.get('validation_score', 'n/a')}",
            f"  ‚Ä¢ Datum: {export_dict.get('validation_date', 'n/a')}",
            f"  ‚Ä¢ Issues: {export_dict.get('validation_issues', 'geen')}",
            "",
            "üìÑ Bron:",
            f"  ‚Ä¢ Type: {export_dict.get('source_type', 'n/a')}",
            f"  ‚Ä¢ Referentie: {export_dict.get('source_reference', 'n/a')}",
            f"  ‚Ä¢ Ge√Ømporteerd van: {export_dict.get('imported_from', 'n/a')}",
            "",
            "üë§ Goedkeuring:",
            f"  ‚Ä¢ Goedgekeurd door: {export_dict.get('approved_by', 'n/a')}",
            f"  ‚Ä¢ Datum: {export_dict.get('approved_at', 'n/a')}",
            f"  ‚Ä¢ Notities: {export_dict.get('approval_notes', 'n/a')}",
            "",
            "üìÖ Metadata:",
            f"  ‚Ä¢ Aangemaakt: {export_dict.get('created_at', 'n/a')} door {export_dict.get('created_by', 'n/a')}",
            f"  ‚Ä¢ Gewijzigd: {export_dict.get('updated_at', 'n/a')} door {export_dict.get('updated_by', 'n/a')}",
            f"  ‚Ä¢ Versie: {export_dict.get('version_number', 'n/a')}",
            "",
        ])

    # Write to file
    with open(pad, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))

    logger.info(f"Bulk TXT export completed: {pad}")
    return str(pad)

def _export_bulk_to_csv(
    self,
    definitions: list[DefinitieRecord],
    filename_prefix: str,
) -&gt; str:
    """Export multiple definitions to CSV format."""
    import csv

    tijdstempel = datetime.now(UTC).strftime("%Y%m%d_%H%M%S")
    bestandsnaam = f"{filename_prefix}_{tijdstempel}.csv"
    pad = self.export_dir / bestandsnaam

    # Get all field names from first record (all should have same fields)
    if definitions:
        fieldnames = list(definitions[0].to_export_dict(mode='full').keys())
    else:
        fieldnames = []

    with open(pad, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        for definitie in definitions:
            writer.writerow(definitie.to_export_dict(mode='full'))

    logger.info(f"Bulk CSV export completed: {pad} ({len(definitions)} records)")
    return str(pad)

def _export_bulk_to_json(
    self,
    definitions: list[DefinitieRecord],
    filename_prefix: str,
) -&gt; str:
    """Export multiple definitions to JSON format."""
    tijdstempel = datetime.now(UTC).strftime("%Y%m%d_%H%M%S")
    bestandsnaam = f"{filename_prefix}_{tijdstempel}.json"
    pad = self.export_dir / bestandsnaam

    json_data = {
        'export_info': {
            'export_timestamp': datetime.now(UTC).isoformat(),
            'export_version': '2.0',
            'format': 'json',
            'count': len(definitions),
        },
        'definitions': [d.to_export_dict(mode='full') for d in definitions],
    }

    with open(pad, 'w', encoding='utf-8') as f:
        json.dump(json_data, f, ensure_ascii=False, indent=2)

    logger.info(f"Bulk JSON export completed: {pad}")
    return str(pad)</code></pre>

<p><strong>Test:</strong> <code>tests/services/test_export_service.py</code></p>

<pre><code>def test_export_definitions_bulk_txt(tmp_path):
    """Test bulk TXT export with multiple definitions."""
    repository = DefinitieRepository(db_path=":memory:")
    service = ExportService(repository, export_dir=str(tmp_path))

    # Create test definitions
    definitions = [
        DefinitieRecord(begrip=f"test_{i}", definitie=f"def {i}", categorie="ENT")
        for i in range(3)
    ]

    # Export
    path = service.export_definitions_bulk(definitions, format=ExportFormat.TXT)

    # Verify
    assert Path(path).exists()
    content = Path(path).read_text(encoding='utf-8')
    assert "DEFINITIE 1/3" in content
    assert "DEFINITIE 3/3" in content
    assert "test_0" in content
    assert "test_2" in content

def test_export_field_coverage():
    """Ensure bulk export includes all 28 user-facing fields."""
    record = DefinitieRecord(
        begrip="test",
        definitie="test",
        categorie="ENT",
        juridische_context="strafrecht",
        voorkeursterm="preferred",
    )

    export = record.to_export_dict(mode='full')

    # Critical fields must be present
    critical_fields = [
        'begrip', 'definitie', 'categorie',
        'juridische_context', 'wettelijke_basis',
        'voorkeursterm', 'ufo_categorie',
        'approved_by', 'approved_at',
        'validation_issues',
    ]

    for field in critical_fields:
        assert field in export, f"Missing critical field: {field}"</code></pre>

<p>---</p>

<h3>Step 3: Refactor FormatExporter (2 hours)</h3>

<p><strong>File:</strong> <code>src/ui/components/tabs/import_export_beheer/format_exporter.py</code></p>

<p><strong>Changes:</strong></p>

<ol>
<li>**Add ExportService dependency:**</li>
</ol>

<pre><code>from services.export_service import ExportService, ExportFormat

class FormatExporter:
    def __init__(self, repository: DefinitieRepository):
        self.repository = repository
        self.export_service = ExportService(repository)  # NEW</code></pre>

<ol>
<li>**Replace _generate_export() method:**</li>
</ol>

<pre><code>def _generate_export(self, format: str, status_filter: str, limit: int):
    """Generate export using ExportService."""
    with st.spinner("Export genereren..."):
        try:
            # Get definitions
            if status_filter == "Alle":
                definitions = self.repository.get_all()
            else:
                definitions = self.repository.get_by_status(status_filter)

            # Apply limit
            if limit &gt; 0:
                definitions = definitions[:limit]

            if not definitions:
                st.warning("Geen definities gevonden voor export")
                return

            # Use ExportService for bulk export
            export_format = ExportFormat(format.lower())
            path = self.export_service.export_definitions_bulk(
                definitions=definitions,
                format=export_format,
                filename_prefix="definities_export"
            )

            # Show success and download button
            with open(path, 'rb') as f:
                file_data = f.read()

            filename = Path(path).name
            mime_type = self._get_mime_type(format)

            st.download_button(
                label=f"üì• Download {format} ({len(definitions)} definities)",
                data=file_data,
                file_name=filename,
                mime=mime_type,
            )

            st.success(f"‚úÖ Export gegenereerd: {len(definitions)} definities")

        except Exception as e:
            logger.error(f"Export failed: {e}")
            st.error(f"Fout bij genereren export: {e!s}")

def _get_mime_type(self, format: str) -&gt; str:
    """Get MIME type for format."""
    mime_types = {
        'CSV': 'text/csv',
        'TXT': 'text/plain',
        'JSON': 'application/json',
        'Excel': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    }
    return mime_types.get(format, 'text/plain')</code></pre>

<ol>
<li>**Remove obsolete methods:**</li>
</ol>

<pre><code># DELETE these methods (no longer needed):
# - _definitions_to_dataframe()
# - _generate_txt_export()</code></pre>

<p><strong>Test:</strong> Manual UI test after implementation</p>

<p>---</p>

<h3>Step 4: Add Field Coverage Test (1 hour)</h3>

<p><strong>File:</strong> <code>tests/services/test_export_field_coverage.py</code> (NEW)</p>

<pre><code>"""
Test suite for export field coverage.

Ensures that exports include all user-facing fields from DefinitieRecord.
"""

import pytest
from database.definitie_repository import DefinitieRecord


def test_export_dict_covers_all_user_fields():
    """Verify to_export_dict() includes all 28 user-facing fields."""
    record = DefinitieRecord(begrip="test", definitie="test", categorie="ENT")
    export = record.to_export_dict(mode='full')

    # Should have 28 fields (31 total - 3 internal)
    assert len(export) == 28, f"Expected 28 fields, got {len(export)}"

    # Define all expected fields
    expected_fields = {
        # Core (5)
        'begrip', 'definitie', 'categorie', 'organisatorische_context', 'status',
        # Context (2)
        'juridische_context', 'wettelijke_basis',
        # Business logic (2)
        'ufo_categorie', 'toelichting_proces',
        # Versioning (2)
        'version_number', 'previous_version_id',
        # Validation (3)
        'validation_score', 'validation_date', 'validation_issues',
        # Source tracking (3)
        'source_type', 'source_reference', 'imported_from',
        # Terminology (1)
        'voorkeursterm',
        # User attribution (4)
        'created_by', 'updated_by', 'created_at', 'updated_at',
        # Approval (3)
        'approved_by', 'approved_at', 'approval_notes',
        # Legacy (2)
        'datum_voorstel', 'ketenpartners',
    }

    assert set(export.keys()) == expected_fields

    # Should NOT include internal fields
    internal_fields = {'last_exported_at', 'export_destinations', 'voorkeursterm_is_begrip'}
    assert not any(f in export for f in internal_fields)


def test_critical_fields_not_null_when_set():
    """Ensure critical fields are included when they have values."""
    record = DefinitieRecord(
        begrip="test",
        definitie="test definitie",
        categorie="ENT",
        juridische_context="strafrecht",
        wettelijke_basis='["Wbp", "AVG"]',
        voorkeursterm="preferred term",
        approved_by="admin",
    )

    export = record.to_export_dict(mode='full')

    # Critical fields should preserve values
    assert export['juridische_context'] == "strafrecht"
    assert export['wettelijke_basis'] == '["Wbp", "AVG"]'
    assert export['voorkeursterm'] == "preferred term"
    assert export['approved_by'] == "admin"


def test_legacy_mode_backward_compatible():
    """Verify legacy mode maintains 8-field backward compatibility."""
    record = DefinitieRecord(begrip="test", definitie="test", categorie="ENT")
    export = record.to_export_dict(mode='legacy')

    assert len(export) == 8
    assert set(export.keys()) == {
        'begrip', 'definitie', 'categorie', 'organisatorische_context',
        'status', 'validation_score', 'created_at', 'updated_at'
    }</code></pre>

<p><strong>Run test:</strong></p>
<pre><code>pytest tests/services/test_export_field_coverage.py -v</code></pre>

<p>---</p>

<h3>Step 5: Update Documentation (1 hour)</h3>

<p><strong>File 1:</strong> <code>docs/architectuur/export-architecture.md</code> (NEW)</p>

<pre><code># Export Architecture

## Overview
All export functionality flows through `ExportService` to ensure consistent field coverage.

## Components
- **ExportService**: Core export logic
- **DefinitieRecord.to_export_dict()**: Field mapping
- **FormatExporter**: UI wrapper (delegates to ExportService)
- **UIComponentsAdapter**: Single-definition exports

## Field Coverage
Exports include 28 out of 31 DefinitieRecord fields:
- 31 total database fields
- 28 user-facing fields (exported)
- 3 internal fields (excluded)

See `test_export_field_coverage.py` for field list.</code></pre>

<p><strong>File 2:</strong> Update <code>CLAUDE.md</code></p>

<p>Add to "Development Richtlijnen" section:</p>

<pre><code>### Export Architectuur

- **Centrale export:** Alle export via `ExportService` (Single Responsibility)
- **Field coverage:** 28/31 velden (exclusief internal tracking)
- **Formaten:** TXT, JSON, CSV (allen via `DefinitieRecord.to_export_dict()`)
- **Test validatie:** `test_export_field_coverage.py` voorkomt field regressie
- **Bulk vs single:** Beide paden gebruiken `ExportService`

**BELANGRIJK:** Nieuwe velden in `DefinitieRecord` MOETEN toegevoegd worden aan `to_export_dict()` √©n `test_export_field_coverage.py`</code></pre>

<p>---</p>

<h3>Step 6: Manual Testing (30 min)</h3>

<p><strong>Test Checklist:</strong></p>

<ol>
<li>**UI Bulk Export Test:**</li>
</ol>
<ul>
<li>  - [ ] Open Import/Export tab</li>
<li>  - [ ] Export 10 definitions to TXT</li>
<li>  - [ ] Verify file contains 28 fields per definition</li>
<li>  - [ ] Check for juridische_context, voorkeursterm, approved_by</li>
</ul>

<ol>
<li>**Single Definition Export Test:**</li>
</ol>
<ul>
<li>  - [ ] Generate a definition in Generator tab</li>
<li>  - [ ] Click export button</li>
<li>  - [ ] Verify same field coverage as bulk export</li>
</ul>

<ol>
<li>**Format Comparison:**</li>
</ol>
<ul>
<li>  - [ ] Export same definitions to TXT, CSV, JSON</li>
<li>  - [ ] Verify all formats have identical field coverage</li>
<li>  - [ ] Check CSV has 28 columns</li>
</ul>

<ol>
<li>**Backward Compatibility:**</li>
</ol>
<ul>
<li>  - [ ] If needed, test legacy mode: `to_export_dict(mode='legacy')`</li>
<li>  - [ ] Verify produces 8-field output</li>
</ul>

<ol>
<li>**Performance Test:**</li>
</ol>
<ul>
<li>  - [ ] Export 100+ definitions</li>
<li>  - [ ] Check file size (~3x larger than before)</li>
<li>  - [ ] Verify performance is acceptable (< 5 seconds)</li>
</ul>

<p>---</p>

<h2>Rollback Plan</h2>

<p><strong>If issues arise during implementation:</strong></p>

<ol>
<li>**Keep old code temporarily:**</li>
<pre><code>   # In format_exporter.py
   USE_NEW_EXPORT = os.getenv("USE_NEW_EXPORT", "true") == "true"

   if USE_NEW_EXPORT:
       path = self.export_service.export_definitions_bulk(...)
   else:
       # Old code path (fallback)
       df = self._definitions_to_dataframe(definitions)
       ...</code></pre>
</ol>

<ol>
<li>**Set environment variable to rollback:**</li>
<pre><code>   export USE_NEW_EXPORT=false
   streamlit run src/main.py</code></pre>
</ol>

<ol>
<li>**Fix issues, then re-enable:**</li>
<pre><code>   export USE_NEW_EXPORT=true</code></pre>
</ol>

<p>---</p>

<h2>Success Criteria</h2>

<h3>Quantitative</h3>
<ul>
<li>‚úÖ Export includes 28/31 fields (90% coverage)</li>
<li>‚úÖ Tests pass: `test_export_field_coverage.py`</li>
<li>‚úÖ No performance degradation (< 5s for 100 records)</li>
<li>‚úÖ File size increase acceptable (~3x)</li>
</ul>

<h3>Qualitative</h3>
<ul>
<li>‚úÖ User complaint resolved</li>
<li>‚úÖ Single export codebase (no duplication)</li>
<li>‚úÖ Documented field mapping</li>
<li>‚úÖ Automated regression prevention</li>
</ul>

<p>---</p>

<h2>Post-Implementation Tasks</h2>

<ol>
<li>**Monitor first week:**</li>
</ol>
<ul>
<li>  - Watch for user feedback</li>
<li>  - Check export file sizes</li>
<li>  - Monitor performance metrics</li>
</ul>

<ol>
<li>**Document lessons learned:**</li>
</ol>
<ul>
<li>  - Update `docs/refactor-log.md`</li>
<li>  - Add to team knowledge base</li>
</ul>

<ol>
<li>**Remove feature flag (after 1 week):**</li>
</ol>
<ul>
<li>  - If no issues, delete `USE_NEW_EXPORT` rollback code</li>
<li>  - Clean up old methods</li>
</ul>

<ol>
<li>**Consider future enhancements:**</li>
</ol>
<ul>
<li>  - Export profiles (minimal, standard, full)</li>
<li>  - Excel formatting (bold headers, frozen panes)</li>
<li>  - Export scheduling/automation</li>
</ul>

<p>---</p>

<h2>File Reference Summary</h2>

<p><strong>Modified Files:</strong></p>
<ul>
<li>`src/database/definitie_repository.py` - Add `to_export_dict()`</li>
<li>`src/services/export_service.py` - Add bulk export methods</li>
<li>`src/ui/components/tabs/import_export_beheer/format_exporter.py` - Refactor to use service</li>
</ul>

<p><strong>New Files:</strong></p>
<ul>
<li>`tests/services/test_export_field_coverage.py` - Field coverage tests</li>
<li>`docs/architectuur/export-architecture.md` - Architecture documentation</li>
</ul>

<p><strong>Updated Documentation:</strong></p>
<ul>
<li>`CLAUDE.md` - Add export architecture section</li>
<li>`docs/refactor-log.md` - Document this refactoring</li>
</ul>

<p>---</p>

<h2>Questions During Implementation?</h2>

<p><strong>Check these resources:</strong></p>
<ol>
<li>Full analysis: `docs/reports/EXPORT_DATA_LIMITATION_ANALYSIS.md`</li>
<li>Architecture diagram: `docs/diagrams/export-architecture-problem.md`</li>
<li>Existing tests: `tests/services/test_export_service.py`</li>
<li>Field list: `src/database/schema.sql` lines 9-82</li>
</ol>

<p><strong>Still stuck?</strong> Review the "Root Cause Summary" section in the analysis document.</p>

  </div>
</body>
</html>