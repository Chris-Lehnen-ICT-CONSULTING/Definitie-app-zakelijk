<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UNIQUE INDEX Removal Strategy - Design Document</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">← Terug naar Portal</a>
    <h1>UNIQUE INDEX Removal Strategy - Design Document</h1>

<h2>Document Information</h2>
<ul>
<li>**Created**: 2025-11-10</li>
<li>**Author**: Claude Code (AI Assistant)</li>
<li>**Status**: Design Phase</li>
<li>**Risk Level**: MEDIUM (reversible, but requires careful testing)</li>
</ul>

<h2>Executive Summary</h2>

<p>This document provides a comprehensive, safe strategy for removing the database UNIQUE INDEX constraint (<code>idx_definities_unique_full</code>) that currently prevents creating multiple definitions with the same attributes (begrip, context, categorie, wettelijke_basis).</p>

<p><strong>Key Insight</strong>: The constraint is implemented as a <strong>UNIQUE INDEX</strong>, not a table-level UNIQUE constraint. This makes removal simple and fully reversible.</p>

<p>---</p>

<h2>1. Problem Statement</h2>

<h3>Current State</h3>
<ul>
<li>Migration `008_add_unique_constraint.sql` (2025-10-31) added UNIQUE INDEX:</li>
<pre><code>  CREATE UNIQUE INDEX IF NOT EXISTS idx_definities_unique_full
  ON definities(begrip, organisatorische_context, juridische_context, wettelijke_basis, categorie)
  WHERE status != 'archived';</code></pre>
<li>This index prevents multiple definitions with identical 5-field combinations</li>
<li>Python-level duplicate detection in `find_duplicates()` still warns users</li>
</ul>

<h3>Desired State</h3>
<ul>
<li>Allow multiple definitions with same attributes (no database constraint)</li>
<li>Keep Python-level duplicate check as **warning only** (not blocking)</li>
<li>Maintain data integrity through application logic</li>
<li>Preserve audit trail and version history</li>
</ul>

<h3>Business Justification</h3>
<p>From schema.sql line 81:</p>
<pre><code>-- (UNIQUE constraint tijdelijk uitgeschakeld i.v.m. importstrategie)</code></pre>
<p>The constraint was <strong>already intended to be temporary</strong> for import strategy.</p>

<p>---</p>

<h2>2. Architecture Analysis</h2>

<h3>2.1 Constraint Type: UNIQUE INDEX</h3>
<p><strong>Critical Discovery</strong>: This is NOT a table-level UNIQUE constraint, but a <strong>UNIQUE INDEX</strong>.</p>

<p><strong>Implications</strong>:</p>
<ul>
<li>✅ **SAFE**: Can be dropped without schema modification</li>
<li>✅ **REVERSIBLE**: Can be recreated with same SQL command</li>
<li>✅ **NO DATA LOSS**: Only affects insert validation, not existing data</li>
<li>✅ **NO FOREIGN KEY CASCADE**: Index removal doesn't trigger cascades</li>
</ul>

<h3>2.2 Code Impact Areas</h3>

<h4>Python Code Handling Duplicates</h4>

<p><strong>1. <code>definitie_repository.py</code> (lines 531-573)</strong></p>
<pre><code>def create_definitie(self, record: DefinitieRecord, allow_duplicate: bool = False) -&gt; int:
    # Check for duplicates: permit if explicitly allowed
    if not allow_duplicate:
        duplicates = self.find_duplicates(...)
        if duplicates and any(d.definitie_record.status != DefinitieStatus.ARCHIVED.value for d in duplicates):
            raise ValueError(f"Definitie voor '{record.begrip}' bestaat al in deze context")</code></pre>

<p><strong>Impact</strong>: NO CHANGES NEEDED</p>
<ul>
<li>Already has `allow_duplicate` parameter</li>
<li>Python check remains as **warning mechanism**</li>
<li>Will continue to raise `ValueError` (caught by UI as warning)</li>
</ul>

<p><strong>2. <code>definition_repository.py</code> (lines 89-120)</strong></p>
<pre><code>def save(self, definition: Definition) -&gt; int:
    try:
        # Bypass duplicate guard if explicitly allowed via metadata
        allow_duplicate = False
        if definition.metadata and bool(definition.metadata.get("force_duplicate")):
            allow_duplicate = True

        result_id = self.legacy_repo.create_definitie(record, allow_duplicate=allow_duplicate)
    except ValueError as e:
        if "bestaat al" in str(e).lower():
            raise DuplicateDefinitionError(...) from e</code></pre>

<p><strong>Impact</strong>: MINIMAL CHANGES</p>
<ul>
<li>Already handles duplicates gracefully</li>
<li>Error handling remains valid (Python check still raises ValueError)</li>
<li>May want to add logging when `allow_duplicate=True` is used</li>
</ul>

<p><strong>3. <code>find_duplicates()</code> (lines 750-898)</strong></p>
<pre><code>def find_duplicates(self, begrip: str, organisatorische_context: str,
                   juridische_context: str = "", categorie: str | None = None,
                   wettelijke_basis: list[str] | None = None) -&gt; list[DuplicateMatch]:
    """
    Searches for potential duplicates matching:
    - Exact match: begrip + context + categorie + wettelijke_basis
    - Exact synonym match (case-insensitive)
    - Fuzzy match on begrip (&gt;70% similarity)
    """</code></pre>

<p><strong>Impact</strong>: NO CHANGES NEEDED</p>
<ul>
<li>This method provides **detection only**, not blocking</li>
<li>Returns list of matches for UI to display as warnings</li>
<li>Algorithm remains valid after constraint removal</li>
</ul>

<p>---</p>

<h2>3. Migration Design</h2>

<h3>3.1 Forward Migration (Remove Constraint)</h3>

<p><strong>File</strong>: <code>src/database/migrations/009_remove_unique_constraint.sql</code></p>

<pre><code>-- Migration 009: Remove UNIQUE constraint to allow multiple definitions (DESIGN-2025-11-10)
-- Author: System (AI-assisted design)
-- Date: 2025-11-10
-- Description: Removes the UNIQUE INDEX constraint that was added in migration 008.
--              This allows multiple definitions with same attributes (begrip, context,
--              categorie, wettelijke_basis) to be created. Duplicate detection remains
--              at application level (Python code) as warning-only mechanism.
--
-- Business Rationale:
--   - The constraint was marked as temporary in schema.sql line 81
--   - Import strategy requires flexibility to create similar definitions
--   - Application-level duplicate detection provides better UX (warnings vs hard blocks)
--   - Users need ability to create contextually similar definitions
--
-- Prerequisites:
--   - Migration 008 must have been applied (UNIQUE INDEX exists)
--   - No code changes required (Python duplicate check remains)
--
-- Rollback: Re-apply migration 008 (see 008_add_unique_constraint.sql)

-- Drop the UNIQUE INDEX created in migration 008
DROP INDEX IF EXISTS idx_definities_unique_full;

-- Verification query (should return the index count = 0):
-- SELECT COUNT(*) FROM sqlite_master
-- WHERE type='index' AND name='idx_definities_unique_full';

-- After this migration:
-- - Multiple definitions with identical attributes CAN be created
-- - Python code in definitie_repository.find_duplicates() still detects them
-- - UI will show warnings but allow creation (if user confirms)
-- - Database integrity relies on application logic (not SQL constraints)</code></pre>

<h3>3.2 Rollback Migration (Restore Constraint)</h3>

<p><strong>File</strong>: <code>src/database/migrations/009_rollback_remove_unique_constraint.sql</code></p>

<pre><code>-- Rollback Migration 009: Restore UNIQUE constraint
-- Author: System (emergency rollback)
-- Date: 2025-11-10
-- Description: Restores the UNIQUE INDEX that was removed in migration 009.
--
-- WARNING: This rollback will FAIL if duplicate records exist in database!
--          Run cleanup_duplicates.py BEFORE rolling back.
--
-- Prerequisites:
--   - No duplicate records in definities table (status != 'archived')
--   - Run: python scripts/cleanup_duplicates.py --preview first
--   - Then: python scripts/cleanup_duplicates.py --execute

-- Restore the UNIQUE INDEX (exact copy from migration 008)
CREATE UNIQUE INDEX IF NOT EXISTS idx_definities_unique_full
ON definities(
    begrip,
    organisatorische_context,
    juridische_context,
    wettelijke_basis,
    categorie
)
WHERE status != 'archived';

-- Verification query (should return 0 duplicates):
-- SELECT begrip, organisatorische_context, juridische_context,
--        wettelijke_basis, categorie, COUNT(*) as count
-- FROM definities
-- WHERE status != 'archived'
-- GROUP BY begrip, organisatorische_context, juridische_context,
--          wettelijke_basis, categorie
-- HAVING COUNT(*) &gt; 1;</code></pre>

<p>---</p>

<h2>4. Code Changes Required</h2>

<h3>4.1 MINIMAL - Add Logging When Allowing Duplicates</h3>

<p><strong>File</strong>: <code>src/database/definitie_repository.py</code></p>

<p><strong>Location</strong>: Line 553 (in <code>create_definitie()</code> method)</p>

<pre><code>def create_definitie(self, record: DefinitieRecord, allow_duplicate: bool = False) -&gt; int:
    """Create new definition, optionally allowing duplicates."""

    # Set database save flag
    try:
        from ui.session_state import SessionStateManager
        SessionStateManager.set_value("saving_to_database", True)
    except Exception:
        pass

    try:
        with self._get_connection() as conn:
            # Check for duplicates: permit if explicitly allowed
            if not allow_duplicate:
                duplicates = self.find_duplicates(...)

                if duplicates and any(d.definitie_record.status != DefinitieStatus.ARCHIVED.value
                                     for d in duplicates):
                    msg = f"Definitie voor '{record.begrip}' bestaat al in deze context"
                    raise ValueError(msg)
            else:
                # NEW: Log when explicitly allowing duplicates
                logger.info(
                    f"Creating definition with allow_duplicate=True: "
                    f"begrip='{record.begrip}', categorie={record.categorie}, "
                    f"context={record.organisatorische_context}"
                )

            # ... rest of create logic ...</code></pre>

<p><strong>Rationale</strong>: Audit trail for when duplicates are intentionally created.</p>

<h3>4.2 NO CHANGES NEEDED</h3>

<p>The following code <strong>already handles duplicates correctly</strong>:</p>

<ol>
<li>**`find_duplicates()`** - Detection logic remains valid</li>
<li>**`allow_duplicate` parameter** - Already exists and works</li>
<li>**Error handling in `definition_repository.py`** - Catches ValueError correctly</li>
<li>**UI duplicate warnings** - Show warnings but allow override</li>
</ol>

<p>---</p>

<h2>5. Testing Strategy</h2>

<h3>5.1 Pre-Migration Tests</h3>

<p><strong>File</strong>: <code>tests/database/test_unique_constraint_exists.py</code> (NEW)</p>

<pre><code>"""Test that UNIQUE INDEX exists before migration 009."""
import sqlite3
import pytest

def test_unique_index_exists_before_migration(test_db_path):
    """Verify UNIQUE INDEX exists before removal."""
    conn = sqlite3.connect(test_db_path)
    cursor = conn.cursor()

    # Check index exists
    cursor.execute("""
        SELECT COUNT(*) FROM sqlite_master
        WHERE type='index' AND name='idx_definities_unique_full'
    """)
    count = cursor.fetchone()[0]

    assert count == 1, "UNIQUE INDEX should exist before migration"

def test_duplicate_insert_blocked_before_migration(test_db_path):
    """Verify duplicates are blocked before migration."""
    repo = DefinitieRepository(test_db_path)

    record1 = DefinitieRecord(
        begrip="test", definitie="def1", categorie="ENT",
        organisatorische_context="DJI", juridische_context="strafrecht",
        wettelijke_basis="[]"
    )

    id1 = repo.create_definitie(record1)
    assert id1 &gt; 0

    # Attempt duplicate - should raise ValueError
    record2 = DefinitieRecord(
        begrip="test", definitie="def2", categorie="ENT",
        organisatorische_context="DJI", juridische_context="strafrecht",
        wettelijke_basis="[]"
    )

    with pytest.raises(ValueError, match="bestaat al"):
        repo.create_definitie(record2)</code></pre>

<h3>5.2 Post-Migration Tests</h3>

<p><strong>File</strong>: <code>tests/database/test_unique_constraint_removed.py</code> (NEW)</p>

<pre><code>"""Test that UNIQUE INDEX is removed after migration 009."""
import sqlite3
import pytest

def test_unique_index_removed_after_migration(test_db_path):
    """Verify UNIQUE INDEX is removed after migration."""
    conn = sqlite3.connect(test_db_path)
    cursor = conn.cursor()

    # Check index does NOT exist
    cursor.execute("""
        SELECT COUNT(*) FROM sqlite_master
        WHERE type='index' AND name='idx_definities_unique_full'
    """)
    count = cursor.fetchone()[0]

    assert count == 0, "UNIQUE INDEX should NOT exist after migration"

def test_duplicate_insert_allowed_after_migration(test_db_path):
    """Verify duplicates ARE allowed after migration (with allow_duplicate=True)."""
    repo = DefinitieRepository(test_db_path)

    record1 = DefinitieRecord(
        begrip="test", definitie="def1", categorie="ENT",
        organisatorische_context="DJI", juridische_context="strafrecht",
        wettelijke_basis="[]"
    )

    id1 = repo.create_definitie(record1, allow_duplicate=False)
    assert id1 &gt; 0

    # Attempt duplicate WITH allow_duplicate=True - should succeed
    record2 = DefinitieRecord(
        begrip="test", definitie="def2 (variant)", categorie="ENT",
        organisatorische_context="DJI", juridische_context="strafrecht",
        wettelijke_basis="[]"
    )

    id2 = repo.create_definitie(record2, allow_duplicate=True)
    assert id2 &gt; 0
    assert id2 != id1

    # Verify both records exist
    def1 = repo.get_definitie(id1)
    def2 = repo.get_definitie(id2)

    assert def1.definitie == "def1"
    assert def2.definitie == "def2 (variant)"

def test_duplicate_check_still_detects_after_migration(test_db_path):
    """Verify find_duplicates() still works after constraint removal."""
    repo = DefinitieRepository(test_db_path)

    # Create two identical definitions
    record1 = DefinitieRecord(
        begrip="test", definitie="def1", categorie="ENT",
        organisatorische_context="DJI", juridische_context="strafrecht",
        wettelijke_basis="[]"
    )
    record2 = DefinitieRecord(
        begrip="test", definitie="def2", categorie="ENT",
        organisatorische_context="DJI", juridische_context="strafrecht",
        wettelijke_basis="[]"
    )

    repo.create_definitie(record1)
    repo.create_definitie(record2, allow_duplicate=True)

    # find_duplicates should detect both
    duplicates = repo.find_duplicates("test", "DJI", "strafrecht", "ENT", [])

    assert len(duplicates) == 2, "Should find both definitions as duplicates"
    assert all(d.match_score == 1.0 for d in duplicates), "Should be exact matches"

def test_python_duplicate_guard_without_allow_flag(test_db_path):
    """Verify Python-level duplicate check still blocks when allow_duplicate=False."""
    repo = DefinitieRepository(test_db_path)

    record1 = DefinitieRecord(
        begrip="test", definitie="def1", categorie="ENT",
        organisatorische_context="DJI", juridische_context="strafrecht",
        wettelijke_basis="[]"
    )

    repo.create_definitie(record1)

    # Attempt duplicate WITHOUT allow_duplicate - should raise ValueError
    record2 = DefinitieRecord(
        begrip="test", definitie="def2", categorie="ENT",
        organisatorische_context="DJI", juridische_context="strafrecht",
        wettelijke_basis="[]"
    )

    with pytest.raises(ValueError, match="bestaat al"):
        repo.create_definitie(record2, allow_duplicate=False)</code></pre>

<h3>5.3 Integration Tests</h3>

<p><strong>File</strong>: <code>tests/integration/test_duplicate_workflow_after_migration.py</code> (NEW)</p>

<pre><code>"""Integration tests for duplicate handling after constraint removal."""

def test_ui_duplicate_warning_workflow(test_app):
    """Test that UI shows warning but allows creation with confirmation."""
    # 1. Create first definition
    result1 = test_app.create_definition(
        begrip="test",
        definitie="First definition",
        categorie="ENT",
        context={"organisatorische_context": ["DJI"], "juridische_context": ["strafrecht"]}
    )
    assert result1.success

    # 2. Attempt duplicate - should show warning dialog
    result2 = test_app.create_definition(
        begrip="test",
        definitie="Second definition",
        categorie="ENT",
        context={"organisatorische_context": ["DJI"], "juridische_context": ["strafrecht"]}
    )

    assert result2.duplicate_warning is True, "Should show duplicate warning"
    assert result2.can_override is True, "Should allow override"

    # 3. Confirm creation (user clicks "Create Anyway")
    result3 = test_app.create_definition(
        begrip="test",
        definitie="Second definition",
        categorie="ENT",
        context={"organisatorische_context": ["DJI"], "juridische_context": ["strafrecht"]},
        force_duplicate=True  # User confirmed
    )

    assert result3.success is True, "Should succeed with force_duplicate"
    assert result3.id != result1.id, "Should be different definitions"</code></pre>

<h3>5.4 Regression Tests</h3>

<p><strong>Ensure existing tests still pass:</strong></p>

<pre><code># Run existing duplicate detection tests
pytest tests/services/test_duplicate_detection_service.py -v

# Run repository tests
pytest tests/services/test_definition_repository.py -v
pytest tests/unit/test_definition_repository_error_handling.py -v

# Run integration tests
pytest tests/test_duplicate_detection_fix.py -v
pytest tests/test_duplicate_web_lookup_fix.py -v</code></pre>

<p>---</p>

<h2>6. Risk Assessment</h2>

<h3>6.1 Risks & Mitigations</h3>

<p>| Risk | Probability | Impact | Mitigation |</p>
<p>|------|-------------|--------|------------|</p>
<p>| <strong>Accidental duplicate creation</strong> | MEDIUM | LOW | Python-level check still warns; logging added |</p>
<p>| <strong>Performance degradation (duplicate checks)</strong> | LOW | LOW | find_duplicates() already optimized with indexes |</p>
<p>| <strong>Data integrity loss</strong> | LOW | MEDIUM | Application logic enforces rules; audit trail preserved |</p>
<p>| <strong>Rollback failure due to duplicates</strong> | MEDIUM | MEDIUM | Provide cleanup script; test rollback in staging |</p>
<p>| <strong>User confusion (multiple similar defs)</strong> | MEDIUM | LOW | UI improvements to show duplicate warnings clearly |</p>

<h3>6.2 Rollback Scenarios</h3>

<p><strong>Scenario 1: Migration fails during deployment</strong></p>
<ul>
<li>**Solution**: Migration script has `IF EXISTS` check - safe to retry</li>
<li>**Impact**: NONE (no changes applied)</li>
</ul>

<p><strong>Scenario 2: Duplicates created after migration, need to restore constraint</strong></p>
<ul>
<li>**Solution**: Run `cleanup_duplicates.py` BEFORE rollback</li>
<li>**Impact**: MEDIUM (requires manual cleanup)</li>
<li>**Prevention**: Test rollback procedure in staging first</li>
</ul>

<p><strong>Scenario 3: Application bugs cause excessive duplicates</strong></p>
<ul>
<li>**Solution**: Monitor logs for `allow_duplicate=True` usage; restore constraint if needed</li>
<li>**Impact**: LOW (duplicates can be merged later)</li>
</ul>

<p>---</p>

<h2>7. Deployment Plan</h2>

<h3>7.1 Pre-Deployment Checklist</h3>

<ul>
<li>[ ] Review migration SQL (009_remove_unique_constraint.sql)</li>
<li>[ ] Review rollback SQL (009_rollback_remove_unique_constraint.sql)</li>
<li>[ ] Add logging to `create_definitie()` (optional enhancement)</li>
<li>[ ] Write pre-migration tests</li>
<li>[ ] Write post-migration tests</li>
<li>[ ] Test migration in local dev environment</li>
<li>[ ] Test rollback procedure (critical!)</li>
<li>[ ] Document expected behavior change in user docs</li>
</ul>

<h3>7.2 Deployment Steps</h3>

<pre><code># 1. Backup database
cp data/definities.db data/definities.db.backup_pre_migration_009

# 2. Verify UNIQUE INDEX exists
sqlite3 data/definities.db "SELECT name FROM sqlite_master WHERE type='index' AND name='idx_definities_unique_full';"
# Expected output: idx_definities_unique_full

# 3. Run pre-migration tests
pytest tests/database/test_unique_constraint_exists.py -v

# 4. Apply migration
sqlite3 data/definities.db &lt; src/database/migrations/009_remove_unique_constraint.sql

# 5. Verify INDEX removed
sqlite3 data/definities.db "SELECT COUNT(*) FROM sqlite_master WHERE type='index' AND name='idx_definities_unique_full';"
# Expected output: 0

# 6. Run post-migration tests
pytest tests/database/test_unique_constraint_removed.py -v

# 7. Run regression tests
pytest tests/services/test_duplicate_detection_service.py -v
pytest tests/services/test_definition_repository.py -v

# 8. Smoke test: Create duplicate definition via UI
# - Open app: bash scripts/run_app.sh
# - Create definition: begrip="test", categorie="ENT"
# - Attempt duplicate: should show warning but allow creation</code></pre>

<h3>7.3 Post-Deployment Monitoring</h3>

<p><strong>Monitor these logs for 1 week:</strong></p>

<pre><code># Look for duplicate creation events
grep "allow_duplicate=True" logs/app.log

# Count duplicate definitions per day
# Should remain LOW (&lt; 5% of total definitions)</code></pre>

<p><strong>If duplicate rate > 10%:</strong></p>
<ul>
<li>Investigate root cause (UI bug? User confusion?)</li>
<li>Consider restoring constraint temporarily</li>
<li>Add UI improvements to reduce confusion</li>
</ul>

<p>---</p>

<h2>8. Rollback Procedure</h2>

<h3>8.1 Emergency Rollback (if migration causes issues)</h3>

<pre><code># 1. Stop application
# Ctrl+C if running locally

# 2. Restore backup
cp data/definities.db.backup_pre_migration_009 data/definities.db

# 3. Verify INDEX restored
sqlite3 data/definities.db "SELECT name FROM sqlite_master WHERE type='index' AND name='idx_definities_unique_full';"
# Expected output: idx_definities_unique_full

# 4. Restart application
bash scripts/run_app.sh</code></pre>

<h3>8.2 Planned Rollback (after duplicates exist)</h3>

<pre><code># 1. Check for duplicates
sqlite3 data/definities.db &lt;&lt;EOF
SELECT begrip, organisatorische_context, COUNT(*) as count
FROM definities
WHERE status != 'archived'
GROUP BY begrip, organisatorische_context, juridische_context, wettelijke_basis, categorie
HAVING COUNT(*) &gt; 1;
EOF

# 2. If duplicates exist, clean up FIRST
python scripts/cleanup_duplicates.py --preview
python scripts/cleanup_duplicates.py --execute

# 3. Apply rollback migration
sqlite3 data/definities.db &lt; src/database/migrations/009_rollback_remove_unique_constraint.sql

# 4. Verify no errors during rollback
# If UNIQUE constraint violation occurs, repeat step 2</code></pre>

<p>---</p>

<h2>9. Success Criteria</h2>

<h3>9.1 Technical Success Criteria</h3>

<ul>
<li>✅ UNIQUE INDEX removed from database</li>
<li>✅ Duplicate definitions CAN be created (with `allow_duplicate=True`)</li>
<li>✅ Python-level duplicate check STILL raises ValueError (when `allow_duplicate=False`)</li>
<li>✅ All existing tests pass</li>
<li>✅ New post-migration tests pass</li>
<li>✅ Rollback procedure tested and documented</li>
</ul>

<h3>9.2 Business Success Criteria</h3>

<ul>
<li>✅ Users can create multiple definitions with same attributes (after confirmation)</li>
<li>✅ UI still shows duplicate warnings (not silently creating duplicates)</li>
<li>✅ Import strategy works without constraint violations</li>
<li>✅ No performance degradation</li>
<li>✅ Audit trail preserved</li>
</ul>

<h3>9.3 Monitoring Metrics</h3>

<p><strong>Track for 2 weeks after deployment:</strong></p>

<p>| Metric | Target | Alert Threshold |</p>
<p>|--------|--------|----------------|</p>
<p>| Duplicate definitions created per day | < 5 | > 10 |</p>
<p>| Percentage of definitions that are duplicates | < 5% | > 10% |</p>
<p>| User complaints about duplicates | 0 | > 1 |</p>
<p>| Performance of <code>find_duplicates()</code> | < 100ms | > 500ms |</p>
<p>| Database size growth | < 10% | > 25% |</p>

<p>---</p>

<h2>10. Next Steps</h2>

<h3>10.1 Implementation Checklist</h3>

<ol>
<li>**Create migration files** (this document → SQL)</li>
<li>**Add logging enhancement** (optional)</li>
<li>**Write pre-migration tests**</li>
<li>**Write post-migration tests**</li>
<li>**Test locally** (dev environment)</li>
<li>**Document user-facing changes**</li>
<li>**Execute migration** (production)</li>
<li>**Monitor for 1 week**</li>
</ol>

<h3>10.2 Follow-Up Tasks</h3>

<ul>
<li>**EPIC-XXX**: UI improvements for duplicate warnings</li>
<li>**US-XXX**: Add merge functionality for duplicate definitions</li>
<li>**US-XXX**: Add "View Similar Definitions" in definition detail view</li>
<li>**DOCS**: Update user guide with duplicate handling explanation</li>
</ul>

<p>---</p>

<h2>Appendix A: Related Files</h2>

<h3>Database Files</h3>
<ul>
<li>`src/database/schema.sql` - Main schema (line 81: constraint comment)</li>
<li>`src/database/migrations/008_add_unique_constraint.sql` - Original constraint</li>
<li>`src/database/migrations/009_remove_unique_constraint.sql` - This migration (TO BE CREATED)</li>
</ul>

<h3>Python Code</h3>
<ul>
<li>`src/database/definitie_repository.py` - create_definitie(), find_duplicates()</li>
<li>`src/services/definition_repository.py` - save(), error handling</li>
</ul>

<h3>Tests</h3>
<ul>
<li>`tests/services/test_duplicate_detection_service.py`</li>
<li>`tests/services/test_definition_repository.py`</li>
<li>`tests/unit/test_definition_repository_error_handling.py`</li>
<li>`tests/test_duplicate_detection_fix.py`</li>
</ul>

<h3>Documentation</h3>
<ul>
<li>`CLAUDE.md` - Project guidelines</li>
<li>`docs/architectuur/TECHNICAL_ARCHITECTURE.md` - Database architecture</li>
</ul>

<p>---</p>

<h2>Appendix B: SQL Commands Reference</h2>

<h3>Check if UNIQUE INDEX exists</h3>
<pre><code>SELECT name, sql FROM sqlite_master
WHERE type='index' AND name='idx_definities_unique_full';</code></pre>

<h3>List all indexes on definities table</h3>
<pre><code>SELECT name, sql FROM sqlite_master
WHERE type='index' AND tbl_name='definities';</code></pre>

<h3>Count duplicate definitions (should be 0 before migration)</h3>
<pre><code>SELECT begrip, organisatorische_context, juridische_context,
       wettelijke_basis, categorie, COUNT(*) as count
FROM definities
WHERE status != 'archived'
GROUP BY begrip, organisatorische_context, juridische_context,
         wettelijke_basis, categorie
HAVING COUNT(*) &gt; 1;</code></pre>

<h3>Manually drop UNIQUE INDEX (if needed)</h3>
<pre><code>DROP INDEX IF EXISTS idx_definities_unique_full;</code></pre>

<h3>Manually recreate UNIQUE INDEX (rollback)</h3>
<pre><code>CREATE UNIQUE INDEX IF NOT EXISTS idx_definities_unique_full
ON definities(begrip, organisatorische_context, juridische_context,
              wettelijke_basis, categorie)
WHERE status != 'archived';</code></pre>

<p>---</p>

<h2>Appendix C: Decision Log</h2>

<p>| Date | Decision | Rationale |</p>
<p>|------|----------|-----------|</p>
<p>| 2025-11-10 | Remove UNIQUE INDEX (not table constraint) | Simpler, reversible, no schema changes |</p>
<p>| 2025-11-10 | Keep Python-level duplicate check | Provides user warnings without hard blocks |</p>
<p>| 2025-11-10 | Add logging for allow_duplicate=True | Audit trail for intentional duplicates |</p>
<p>| 2025-11-10 | Require cleanup before rollback | Prevents UNIQUE constraint violations on rollback |</p>

<p>---</p>

<h2>Appendix D: Questions & Answers</h2>

<p><strong>Q: Why remove the constraint instead of adding more exceptions?</strong></p>
<p><strong>A</strong>: The constraint was marked as temporary in schema.sql. Removing it aligns with original intent and provides flexibility for import strategy.</p>

<p><strong>Q: Won't this lead to data quality issues?</strong></p>
<p><strong>A</strong>: No - Python-level validation still detects duplicates and warns users. Users must explicitly confirm to create duplicates.</p>

<p><strong>Q: What if we need to restore the constraint later?</strong></p>
<p><strong>A</strong>: Rollback migration is provided. Just run cleanup script first to remove any duplicates that were created.</p>

<p><strong>Q: How do we prevent accidental duplicate creation?</strong></p>
<p><strong>A</strong>: UI shows warnings, Python code requires explicit <code>allow_duplicate=True</code>, and logging tracks all duplicate creations.</p>

<p><strong>Q: Can this migration be run multiple times safely?</strong></p>
<p><strong>A</strong>: Yes - uses <code>DROP INDEX IF EXISTS</code>, so it's idempotent.</p>

<p>---</p>

<p><strong>END OF DESIGN DOCUMENT</strong></p>

  </div>
</body>
</html>