<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Synonym Orchestrator Architecture v3.1</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">â† Terug naar Portal</a>
    <h1>Synonym Orchestrator Architecture v3.1</h1>
<h2>Unified Synonym Management met Graph-Based Registry</h2>

<p><strong>Status:</strong> Final Design - Ready for Implementation</p>
<p><strong>Version:</strong> 3.1</p>
<p><strong>Date:</strong> 2025-10-09</p>
<p><strong>Authors:</strong> Multi-Agent Consensus Review (PO, Architect, Developer, QA, Security)</p>

<p>---</p>

<h2>ğŸ“‹ Executive Summary</h2>

<h3>Problem Statement</h3>

<p>De huidige synoniemen infrastructuur is gefragmenteerd over drie ongecoÃ¶rdineerde bronnen:</p>
<ol>
<li>**`juridische_synoniemen.yaml`** - Statisch bestand voor weblookup</li>
<li>**`synonym_suggestions` DB tabel** - GPT-4 suggesties pending review</li>
<li>**`definitie_voorbeelden` DB tabel** - Handmatige synoniemen per definitie</li>
</ol>

<p>Dit leidt tot:</p>
<ul>
<li>Geen single source of truth</li>
<li>Sync problemen tussen bronnen</li>
<li>Suboptimale weblookup (mist AI-suggesties)</li>
<li>Complexe maintenance (YAML + DB dual-write)</li>
</ul>

<h3>Solution</h3>

<p><strong>Unified Graph-Based Registry</strong> met orchestrator-laag:</p>

<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           SynonymOrchestrator                   â”‚
â”‚  (TTL Cache + Governance Policy + GPT-4 Sync)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         SynonymRegistry (Graph-Based)           â”‚
â”‚                                                  â”‚
â”‚  synonym_groups          synonym_group_members  â”‚
â”‚  â”œâ”€ id                   â”œâ”€ group_id (FK)      â”‚
â”‚  â”œâ”€ canonical_term       â”œâ”€ term               â”‚
â”‚  â””â”€ domain               â”œâ”€ weight (0.0-1.0)   â”‚
â”‚                          â”œâ”€ status (lifecycle)  â”‚
â”‚                          â”œâ”€ source (origin)     â”‚
â”‚                          â””â”€ definitie_id (scope)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<p><strong>Key Benefits:</strong></p>
<ul>
<li>âœ… Single source of truth (registry)</li>
<li>âœ… Symmetrische synoniemen (geen hoofdterm hiÃ«rarchie)</li>
<li>âœ… Sync GPT-4 aanvulling vÃ³Ã³r definitiegeneratie (betere weblookup)</li>
<li>âœ… TTL cache met invalidatie (performance)</li>
<li>âœ… Configurable governance (strict/pragmatic policy)</li>
<li>âœ… Geen backwards compatibility nodig (YAML recent toegevoegd)</li>
</ul>

<p>---</p>

<h2>ğŸ­ Multi-Agent Consensus Review</h2>

<h3>Drie Nieuwe Inzichten (Game Changers)</h3>

<ol>
<li>**Geen YAML Backwards Compatibility**</li>
</ol>
<ul>
<li>  - YAML file is pas enkele uren oud</li>
<li>  - Volledige verwijdering mogelijk â†’ -500 regels code</li>
<li>  - `JuridischeSynoniemService` wordt pure registry faÃ§ade</li>
</ul>

<ol>
<li>**Graph-Based Synoniemen Model**</li>
</ol>
<ul>
<li>  - Symmetrische groepen (peers, geen hiÃ«rarchie)</li>
<li>  - Bidirectionele lookup via JOIN (elegant)</li>
<li>  - Toekomstbestendig (metadata op groep-niveau)</li>
</ul>

<ol>
<li>**Sync GPT-4 Aanvulling VÃ“Ã“R Definitiegeneratie**</li>
</ol>
<ul>
<li>  - Check registry: <5 synoniemen? â†’ GPT-4 call (sync OK!)</li>
<li>  - Weblookup krijgt complete synoniemenset direct</li>
<li>  - Eenvoudiger dan async background jobs</li>
</ul>

<h3>Agent Consensus</h3>

<p>| Agent | Verdict | Rationale |</p>
<p>|-------|---------|-----------|</p>
<p>| <strong>PO (Sarah)</strong> | âœ… Approved | UX win: Ã©Ã©n klik = definitie + synoniemen + weblookup |</p>
<p>| <strong>Architect (Eva)</strong> | âœ… Approved | Clean design, geen async complexity, graph model zuiver |</p>
<p>| <strong>Developer (James)</strong> | âœ… Approved | Straightforward implementatie, deterministische tests |</p>
<p>| <strong>QA (Quinn)</strong> | âœ… Approved | Testbaar, geen race conditions, duidelijke flows |</p>
<p>| <strong>Security (Morgan)</strong> | âœ… Approved | Configurable governance, audit trail, RBAC ready |</p>

<p><strong>Unanimous Consensus Bereikt</strong> ğŸ‰</p>

<h3>Governance Policy Decision</h3>

<p><strong>Vraag:</strong> Gebruikt weblookup <code>ai_pending</code> synoniemen direct of na approval?</p>

<p><strong>Consensus:</strong> Model 1 (Strict) met configuratie override</p>
<ul>
<li>Default: `SYNONYM_POLICY = "strict"` (alleen approved)</li>
<li>Admin kan switchen naar `"pragmatic"` (ai_pending ook toegestaan)</li>
<li>Rationale: Governance > UX voor compliance, maar flexibiliteit behouden</li>
</ul>

<p>---</p>

<h2>ğŸ—„ï¸ Schema Design (Graph-Based)</h2>

<h3>Database Tables</h3>

<pre><code>-- Synonym Groups (expliciete groepering van gerelateerde termen)
CREATE TABLE synonym_groups (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    canonical_term TEXT NOT NULL UNIQUE,  -- "Voorkeurs" term voor display
    domain TEXT,                           -- "strafrecht", "civielrecht", etc. (optional)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by TEXT
);

-- Synonym Group Members (alle synoniemen als peers)
CREATE TABLE synonym_group_members (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    group_id INTEGER NOT NULL,
    term TEXT NOT NULL,

    -- Weighting &amp; Priority
    weight REAL DEFAULT 1.0 CHECK(weight &gt;= 0.0 AND weight &lt;= 1.0),
    is_preferred BOOLEAN DEFAULT FALSE,  -- Top-5 priority flag

    -- Lifecycle Status
    status TEXT NOT NULL DEFAULT 'active',
        -- active: In gebruik, beschikbaar voor queries
        -- ai_pending: GPT-4 suggestie, wacht op approval
        -- rejected_auto: Afgewezen door reviewer
        -- deprecated: Niet meer gebruikt (manual edit removed)

    -- Source Tracking
    source TEXT NOT NULL,
        -- db_seed: InitiÃ«le migratie vanuit oude DB
        -- manual: Handmatig toegevoegd door gebruiker
        -- ai_suggested: GPT-4 suggestie
        -- imported_yaml: Migratie vanuit juridische_synoniemen.yaml (legacy)

    -- Context &amp; Rationale
    context_json TEXT,  -- {"rationale": "...", "model": "gpt-4", "temperature": 0.3}

    -- Scoping (global vs per-definitie)
    definitie_id INTEGER,  -- NULL = global, anders scoped to definitie

    -- Analytics
    usage_count INTEGER DEFAULT 0,
    last_used_at TIMESTAMP,

    -- Audit Trail
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by TEXT,
    reviewed_by TEXT,
    reviewed_at TIMESTAMP,

    -- Constraints
    FOREIGN KEY(group_id) REFERENCES synonym_groups(id) ON DELETE CASCADE,
    FOREIGN KEY(definitie_id) REFERENCES definities(id) ON DELETE CASCADE,
    UNIQUE(group_id, term)  -- Een term kan maar 1x per groep
);

-- Indexes voor performance
CREATE INDEX idx_sgm_group ON synonym_group_members(group_id);
CREATE INDEX idx_sgm_term ON synonym_group_members(term);
CREATE INDEX idx_sgm_status ON synonym_group_members(status);
CREATE INDEX idx_sgm_preferred ON synonym_group_members(is_preferred);
CREATE INDEX idx_sgm_definitie ON synonym_group_members(definitie_id);
CREATE INDEX idx_sgm_usage ON synonym_group_members(usage_count DESC);</code></pre>

<h3>Example Data</h3>

<pre><code>-- Group 1: Voorlopige hechtenis groep
INSERT INTO synonym_groups (id, canonical_term, domain)
VALUES (1, 'voorlopige hechtenis', 'strafrecht');

-- Members (symmetrisch - geen hiÃ«rarchie!)
INSERT INTO synonym_group_members (group_id, term, weight, status, source) VALUES
    (1, 'voorlopige hechtenis', 1.0, 'active', 'manual'),        -- Canonical term zelf
    (1, 'voorarrest', 0.95, 'active', 'imported_yaml'),          -- Sterk synoniem
    (1, 'bewaring', 0.90, 'active', 'imported_yaml'),
    (1, 'inverzekeringstelling', 0.88, 'ai_pending', 'ai_suggested'),  -- Wacht op review
    (1, 'detentie', 0.82, 'ai_pending', 'ai_suggested');</code></pre>

<h3>Bidirectional Lookup Query</h3>

<pre><code>-- Haal alle synoniemen voor term "voorarrest" (inclusief canonical):
SELECT
    m2.term,
    m2.weight,
    m2.status,
    m2.is_preferred
FROM synonym_group_members m1
JOIN synonym_group_members m2 ON m1.group_id = m2.group_id
WHERE m1.term = 'voorarrest'
  AND m2.term != 'voorarrest'  -- Exclude zelf
  AND m2.status = 'active'
  AND (m2.definitie_id IS NULL OR m2.definitie_id = ?)  -- Global + scoped
ORDER BY m2.is_preferred DESC, m2.weight DESC, m2.usage_count DESC;</code></pre>

<p>---</p>

<h2>ğŸ”§ Core Components</h2>

<h3>1. SynonymRegistry (Data Access Layer)</h3>

<pre><code># src/repositories/synonym_registry.py

class SynonymRegistry:
    """
    Data access layer voor synonym groups &amp; members.

    Responsibilities:
    - CRUD operations op synonym_groups &amp; synonym_group_members
    - Bidirectionele lookup (term â†’ groep â†’ alle members)
    - Cache invalidation callbacks
    - Statistics &amp; health checks
    """

    def __init__(self, db_path: str = "data/definities.db"):
        self.db_path = db_path
        self._invalidation_callbacks: list[callable] = []

    # === GROUP OPERATIONS ===

    def get_or_create_group(
        self,
        canonical_term: str,
        domain: str | None = None,
        created_by: str = "system"
    ) -&gt; SynonymGroup:
        """Find existing group or create new one."""
        pass

    def find_group_by_term(self, term: str) -&gt; SynonymGroup | None:
        """Find group containing this term (any member)."""
        pass

    # === MEMBER OPERATIONS ===

    def add_group_member(
        self,
        group_id: int,
        term: str,
        weight: float = 1.0,
        status: str = 'active',
        source: str = 'manual',
        definitie_id: int | None = None,
        context_json: str | None = None,
        created_by: str = "system"
    ) -&gt; int:
        """Add member to group + trigger invalidation."""
        member_id = self._add_group_member_db(...)

        # Trigger cache invalidation
        group = self.get_group(group_id)
        if group:
            self._trigger_invalidation(group.canonical_term)

        return member_id

    def get_group_members(
        self,
        group_id: int,
        statuses: list[str] | None = None,
        min_weight: float = 0.0,
        filters: dict | None = None,
        order_by: list[str] | None = None,
        limit: int | None = None
    ) -&gt; list[SynonymGroupMember]:
        """Query members with flexible filtering."""
        pass

    def update_member_status(
        self,
        member_id: int,
        new_status: str,
        reviewed_by: str,
        reviewed_at: datetime | None = None
    ):
        """Update status + trigger invalidation."""
        self._update_member_status_db(...)

        # Trigger invalidation
        member = self.get_member(member_id)
        group = self.get_group(member.group_id)
        if group:
            self._trigger_invalidation(group.canonical_term)

    # === CACHE INVALIDATION ===

    def register_invalidation_callback(self, callback: callable):
        """Register callback voor cache updates."""
        self._invalidation_callbacks.append(callback)

    def _trigger_invalidation(self, term: str):
        """Trigger alle callbacks."""
        for callback in self._invalidation_callbacks:
            try:
                callback(term)
            except Exception as e:
                logger.error(f"Invalidation callback failed: {e}")

    # === STATISTICS ===

    def get_statistics(self) -&gt; dict:
        """Registry health metrics."""
        return {
            'total_groups': self._count_groups(),
            'total_members': self._count_members(),
            'avg_members_per_group': self._avg_members(),
            'by_status': self._count_by_status(),
            'by_source': self._count_by_source(),
            'orphaned_members': self._count_orphaned(),
            'unused_synonyms': self._count_unused()
        }</code></pre>

<h3>2. SynonymOrchestrator (Business Logic Layer)</h3>

<pre><code># src/services/synonym_orchestrator.py

class SynonymOrchestrator:
    """
    Business logic voor synonym operations.

    Responsibilities:
    - Get synonyms met governance policy enforcement
    - TTL caching met invalidatie
    - GPT-4 enrichment (sync tijdens definitiegeneratie)
    - Usage tracking
    """

    def __init__(
        self,
        registry: SynonymRegistry,
        gpt4_suggester: GPT4SynonymSuggester
    ):
        self.registry = registry
        self.gpt4_suggester = gpt4_suggester
        self.config = get_synonym_config()  # Centraal!

        # TTL Cache: {term: (synonyms, timestamp)}
        self._cache: dict[str, tuple[list, datetime]] = {}
        self._cache_lock = threading.RLock()
        self._cache_hits = 0
        self._cache_misses = 0

    def get_synonyms_for_lookup(
        self,
        term: str,
        max_results: int = 5,
        min_weight: float | None = None
    ) -&gt; list[WeightedSynonym]:
        """
        Get synonyms met TTL cache + governance.

        Priority:
        1. Preferred members (is_preferred=TRUE)
        2. Active members (status='active', weight &gt;= threshold)
        3. AI pending (ONLY if policy='pragmatic')
        """
        term_normalized = term.lower().strip()

        # Check cache
        if self._is_cached(term_normalized):
            self._cache_hits += 1
            return self._get_from_cache(term_normalized)[:max_results]

        # Cache miss - query registry
        self._cache_misses += 1

        # Determine statuses (governance policy!)
        statuses = ['active']
        if self.config.policy == SynonymPolicy.PRAGMATIC:
            statuses.append('ai_pending')

        # Query
        min_weight = min_weight or self.config.min_weight_for_weblookup
        synonyms = self.registry.get_synonyms(
            term=term_normalized,
            statuses=statuses,
            min_weight=min_weight,
            order_by=['is_preferred DESC', 'weight DESC', 'usage_count DESC'],
            limit=max_results * 2  # Cache extra
        )

        # Store in cache
        self._store_in_cache(term_normalized, synonyms)

        return synonyms[:max_results]

    async def ensure_synonyms(
        self,
        term: str,
        min_count: int = 5,
        context: dict | None = None
    ) -&gt; tuple[list[WeightedSynonym], int]:
        """
        Ensure term has min_count synoniemen (GPT-4 sync OK!).

        Called VÃ“Ã“Rdat definitiegeneratie start.

        Returns:
            (synonyms, ai_pending_count)
        """
        # Check existing
        existing = self.get_synonyms_for_lookup(term, max_results=10)

        if len(existing) &gt;= min_count:
            enrichment_logger.info(f"Cache hit for '{term}' (has {len(existing)} &gt;= {min_count})")
            return existing[:min_count], 0  # âœ… Fast path

        # Slow path: GPT-4 enrichment (sync blocking OK - user clicked "Genereer")
        enrichment_logger.info(
            f"Starting GPT-4 enrichment for '{term}' (only {len(existing)} found)"
        )

        start_time = datetime.now()

        try:
            ai_suggestions = await asyncio.wait_for(
                self.gpt4_suggester.suggest_synonyms(
                    term=term,
                    definitie=context.get('definitie') if context else None,
                    context=context.get('tokens') if context else None
                ),
                timeout=self.config.gpt4_timeout_seconds
            )

            duration = (datetime.now() - start_time).total_seconds()

            # Save as ai_pending (NOT active - requires approval!)
            group = self.registry.get_or_create_group(
                canonical_term=term,
                created_by='gpt4_enrichment'
            )

            ai_count = 0
            for suggestion in ai_suggestions:
                self.registry.add_group_member(
                    group_id=group.id,
                    term=suggestion.synoniem,
                    weight=suggestion.confidence,
                    status='ai_pending',  # Governance gate!
                    source='ai_suggested',
                    context_json=json.dumps({
                        'rationale': suggestion.rationale,
                        'model': 'gpt-4-turbo',
                        'triggered_by': 'definition_generation'
                    }),
                    created_by='gpt4_suggester'
                )
                ai_count += 1

            enrichment_logger.info(
                f"Enrichment complete for '{term}': "
                f"{ai_count} suggestions, duration: {duration:.2f}s"
            )

            # Re-fetch (nu met ai_pending if policy allows)
            enriched = self.get_synonyms_for_lookup(term, max_results=10)

            return enriched[:min_count], ai_count

        except asyncio.TimeoutError:
            duration = (datetime.now() - start_time).total_seconds()
            enrichment_logger.error(
                f"GPT-4 timeout for '{term}' after {duration:.2f}s"
            )
            return existing, 0  # Fail gracefully

        except Exception as e:
            enrichment_logger.error(f"GPT-4 enrichment failed for '{term}': {e}")
            return existing, 0

    def invalidate_cache(self, term: str | None = None):
        """Invalidate cache (called by registry callbacks)."""
        with self._cache_lock:
            if term:
                term_normalized = term.lower().strip()
                if term_normalized in self._cache:
                    del self._cache[term_normalized]
                    logger.info(f"Cache invalidated for '{term}'")
            else:
                self._cache.clear()
                logger.info("Cache flushed (all entries)")

    @property
    def cache_hit_rate(self) -&gt; float:
        """Cache performance metric."""
        total = self._cache_hits + self._cache_misses
        return self._cache_hits / total if total &gt; 0 else 0.0</code></pre>

<h3>3. JuridischeSynoniemService (FaÃ§ade)</h3>

<pre><code># src/services/web_lookup/synonym_service.py (REFACTORED)

class JuridischeSynoniemService:
    """
    Backward compatible faÃ§ade over SynonymOrchestrator.

    Existing callers blijven werken zonder wijzigingen!
    """

    def __init__(self, orchestrator: SynonymOrchestrator):
        self.orchestrator = orchestrator

    # === BACKWARD COMPATIBLE API ===

    def get_synoniemen(self, term: str) -&gt; list[str]:
        """Haal synoniemen (legacy API)."""
        weighted = self.orchestrator.get_synonyms_for_lookup(
            term=term,
            max_results=8,  # Historical default
            min_weight=0.7
        )
        return [ws.term for ws in weighted if ws.term != term]

    def get_synonyms_with_weights(self, term: str) -&gt; list[tuple[str, float]]:
        """Weighted synonyms (v2.0 compat)."""
        weighted = self.orchestrator.get_synonyms_for_lookup(term, max_results=8)
        return [(ws.term, ws.weight) for ws in weighted if ws.term != term]

    def expand_query_terms(self, term: str, max_synonyms: int = 3) -&gt; list[str]:
        """Query expansion."""
        weighted = self.orchestrator.get_synonyms_for_lookup(term, max_results=max_synonyms)
        return [term] + [ws.term for ws in weighted]

    def has_synoniemen(self, term: str) -&gt; bool:
        """Check if term has synonyms."""
        return len(self.get_synoniemen(term)) &gt; 0</code></pre>

<h3>4. Central Config Management</h3>

<pre><code># src/config/synonym_config.py

from enum import Enum
from dataclasses import dataclass

class SynonymPolicy(Enum):
    STRICT = "strict"        # Alleen approved synoniemen
    PRAGMATIC = "pragmatic"  # AI-pending ook toegestaan

@dataclass
class SynonymConfiguration:
    # Governance
    policy: SynonymPolicy = SynonymPolicy.STRICT

    # Enrichment
    min_synonyms_threshold: int = 5
    gpt4_timeout_seconds: int = 30
    gpt4_max_retries: int = 3

    # Caching
    cache_ttl_seconds: int = 3600  # 1 hour
    cache_max_size: int = 1000

    # Weights
    min_weight_for_weblookup: float = 0.7
    preferred_weight_threshold: float = 0.95

    @classmethod
    def from_yaml(cls, path: str) -&gt; "SynonymConfiguration":
        """Load from config/synonym_config.yaml."""
        pass

# Singleton access
_config: SynonymConfiguration | None = None

def get_synonym_config() -&gt; SynonymConfiguration:
    global _config
    if _config is None:
        _config = SynonymConfiguration.from_yaml("config/synonym_config.yaml")
    return _config</code></pre>

<pre><code># config/synonym_config.yaml

synonym_configuration:
  policy: strict  # strict | pragmatic
  min_synonyms: 5
  gpt4_timeout: 30
  cache_ttl: 3600
  min_weight: 0.7
  preferred_threshold: 0.95</code></pre>

<p>---</p>

<h2>ğŸ”„ Integration Flows</h2>

<h3>Flow 1: Definitiegeneratie met Synoniemen Enrichment</h3>

<pre><code># src/services/definition_generation_orchestrator.py

class DefinitionGenerationOrchestrator:
    async def generate_definition(self, term: str, context: dict) -&gt; dict:
        """
        Generate definition met synonym enrichment.

        Flow:
        1. Ensure synonyms (GPT-4 if needed) â† NIEUW!
        2. Web lookup (with complete synonym set)
        3. GPT-4 definition generation
        4. Return definition + synonym metadata
        """
        result = {}

        # PHASE 1: Synonym Enrichment (sync GPT-4 OK)
        synonyms, ai_pending_count = await self.synonym_orchestrator.ensure_synonyms(
            term=term,
            min_count=5,
            context=context
        )

        result['synonyms'] = [s.term for s in synonyms]
        result['ai_pending_count'] = ai_pending_count

        # PHASE 2: Web Lookup (with enriched synonyms!)
        web_results = await self.web_lookup_service.lookup(
            LookupRequest(
                term=term,
                synonyms=[s.term for s in synonyms],  # Complete set!
                context=context.get('tokens'),
                max_results=10
            )
        )

        result['web_results'] = web_results

        # PHASE 3: GPT-4 Definition Generation
        definition = await self.definition_generator.generate(
            term=term,
            context=context,
            web_sources=web_results
        )

        result['definition'] = definition
        result['metadata'] = {
            'synonyms_used': len(synonyms),
            'ai_pending_used': ai_pending_count if policy_allows else 0,
            'web_sources_found': len(web_results)
        }

        return result</code></pre>

<h3>Flow 2: Manual Edit Definitie-Editor</h3>

<pre><code># src/repositories/definitie_repository.py (UPDATED)

class DefinitieRepository:
    def save_voorbeelden(
        self,
        definitie_id: int,
        voorbeelden_dict: dict,
        gegenereerd_door: str = "system",
        voorkeursterm: str | None = None
    ) -&gt; list[int]:
        """
        Save voorbeelden + sync synoniemen naar registry.

        UPDATED: Triggert registry sync!
        """
        # Save to definitie_voorbeelden (legacy)
        saved_ids = self._save_voorbeelden_legacy(...)

        # Sync synoniemen naar registry (NIEUW!)
        synoniemen = voorbeelden_dict.get('synoniemen', [])
        if synoniemen:
            self._sync_synonyms_to_registry(
                definitie_id=definitie_id,
                synoniemen=synoniemen,
                edited_by=gegenereerd_door
            )

        return saved_ids

    def _sync_synonyms_to_registry(
        self,
        definitie_id: int,
        synoniemen: list[str],
        edited_by: str
    ):
        """
        Sync manual synoniemen naar registry (scoped to definitie_id).

        Logic:
        1. Find/create group voor definitie.begrip
        2. Add/update synoniemen als active (source=manual, definitie_id=X)
        3. Deprecate synoniemen in group met definitie_id=X maar NIET in input
        4. Cache invalidation
        """
        definitie = self.get_definitie(definitie_id)
        registry = ServiceContainer.get_instance().get_synonym_registry()

        group = registry.get_or_create_group(
            canonical_term=definitie.begrip,
            created_by=edited_by
        )

        # Get existing manual members for this definitie
        existing = registry.get_group_members(
            group_id=group.id,
            filters={'definitie_id': definitie_id, 'source': 'manual'}
        )

        existing_terms = {m.term: m for m in existing}
        input_terms = {s.strip().lower() for s in synoniemen if s.strip()}

        # Add/update from input
        for syn in synoniemen:
            syn_normalized = syn.strip().lower()
            if not syn_normalized:
                continue

            if syn_normalized in existing_terms:
                # Reactivate if deprecated
                member = existing_terms[syn_normalized]
                if member.status == 'deprecated':
                    registry.update_member_status(
                        member_id=member.id,
                        new_status='active',
                        reviewed_by=edited_by
                    )
            else:
                # Add new
                registry.add_group_member(
                    group_id=group.id,
                    term=syn_normalized,
                    weight=1.0,  # Manual = high confidence
                    status='active',
                    source='manual',
                    definitie_id=definitie_id,  # SCOPED!
                    created_by=edited_by
                )

        # Deprecate removed (NOT in input)
        for term, member in existing_terms.items():
            if term not in input_terms and member.status == 'active':
                registry.update_member_status(
                    member_id=member.id,
                    new_status='deprecated',
                    reviewed_by=edited_by
                )

        # Cache invalidation (automatic via callback)
        logger.info(f"Synced {len(synoniemen)} manual synonyms for definitie {definitie_id}")</code></pre>

<h3>Flow 3: AI-Synoniemen Review (UX)</h3>

<pre><code>User: Klikt "Genereer Definitie"
    â†“
[SPINNER: "Synoniemen controleren..."]
ensure_synonyms() â†’ &lt;5? GPT-4 call (5-15s)
    â†“
[SPINNER: "Externe bronnen zoeken..."]
Web lookup met synoniemen
    â†“
[SPINNER: "Definitie genereren..."]
GPT-4 definitie
    â†“
[RESULT DISPLAYED]
    â†“
ğŸ“Š Metadata Block:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… Definitie gegenereerd                     â”‚
â”‚                                              â”‚
â”‚ ğŸ“š Synoniemen gebruikt: 5                   â”‚
â”‚ âš ï¸  3 nieuwe AI-synoniemen gevonden         â”‚
â”‚    [Review Synoniemen] [Later]              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User klikt [Review Synoniemen]:
    â†“
Pop-up met pending synoniemen:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¤– AI-Gegenereerde Synoniemen Review        â”‚
â”‚                                              â”‚
â”‚ âœ… inverzekeringstelling (0.88)             â”‚
â”‚    Rationale: Strafvorderlijke maatregel... â”‚
â”‚    [âœ“ Goedkeuren] [âœ— Afwijzen]              â”‚
â”‚                                              â”‚
â”‚ [Alles Goedkeuren] [Later Reviewen]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

<p>---</p>

<h2>ğŸ“¦ Migration Strategy</h2>

<h3>Three Sources â†’ Unified Registry</h3>

<pre><code># scripts/migrate_synonyms_to_registry.py

class SynonymMigration:
    """Migrate all sources to graph-based registry."""

    def migrate_all(self, dry_run: bool = True) -&gt; dict:
        """
        Migrate:
        1. juridische_synoniemen.yaml (if exists - legacy)
        2. synonym_suggestions (approved only)
        3. definitie_voorbeelden (per-definitie manual)
        """
        stats = {
            'groups_created': 0,
            'members_added': 0,
            'yaml_imported': 0,
            'db_approved': 0,
            'definitie_voorbeelden': 0,
            'conflicts': []
        }

        # 1. YAML (if exists)
        if self.yaml_path.exists():
            yaml_data = self._load_yaml()
            for hoofdterm, synoniemen in yaml_data.items():
                group = self.registry.get_or_create_group(
                    canonical_term=hoofdterm,
                    created_by='yaml_migration'
                )
                stats['groups_created'] += 1

                for syn in synoniemen:
                    if not dry_run:
                        self.registry.add_group_member(
                            group_id=group.id,
                            term=syn['synoniem'] if isinstance(syn, dict) else syn,
                            weight=syn.get('weight', 1.0) if isinstance(syn, dict) else 1.0,
                            status='active',
                            source='imported_yaml',
                            created_by='yaml_migration'
                        )
                    stats['members_added'] += 1
                    stats['yaml_imported'] += 1

        # 2. Approved DB suggestions
        approved = self.synonym_repo.get_suggestions_by_status(
            SuggestionStatus.APPROVED
        )
        for suggestion in approved:
            group = self.registry.get_or_create_group(
                canonical_term=suggestion.hoofdterm,
                created_by='db_migration'
            )

            if not dry_run:
                self.registry.add_group_member(
                    group_id=group.id,
                    term=suggestion.synoniem,
                    weight=suggestion.confidence,
                    status='active',
                    source='ai_suggested',
                    context_json=suggestion.context_data,
                    reviewed_by=suggestion.reviewed_by,
                    created_by='db_migration'
                )
            stats['members_added'] += 1
            stats['db_approved'] += 1

        # 3. Definitie voorbeelden (scoped to definitie)
        all_defs = self.definitie_repo.search_definities(limit=None)
        for definitie in all_defs:
            voorbeelden = self.definitie_repo.get_voorbeelden_by_type(definitie.id)
            synoniemen = voorbeelden.get('synonyms', [])

            if not synoniemen:
                continue

            group = self.registry.get_or_create_group(
                canonical_term=definitie.begrip,
                created_by='definitie_migration'
            )

            for syn in synoniemen:
                if not dry_run:
                    self.registry.add_group_member(
                        group_id=group.id,
                        term=syn,
                        weight=1.0,
                        status='active',
                        source='manual',
                        definitie_id=definitie.id,  # SCOPED!
                        created_by='definitie_migration'
                    )
                stats['members_added'] += 1
                stats['definitie_voorbeelden'] += 1

        return stats

# CLI usage:
# python scripts/migrate_synonyms_to_registry.py --dry-run  # Preview
# python scripts/migrate_synonyms_to_registry.py --execute  # Run</code></pre>

<p>---</p>

<h2>ğŸ§ª Testing Strategy</h2>

<h3>Unit Tests</h3>

<pre><code># tests/services/test_synonym_orchestrator.py

class TestSynonymOrchestrator:
    def test_get_synonyms_cache_hit(self, mock_registry):
        """Verify cache hit doesn't query registry."""
        orchestrator = SynonymOrchestrator(mock_registry, Mock())

        # Prime cache
        orchestrator.get_synonyms_for_lookup("test", max_results=5)

        # Second call = cache hit
        result = orchestrator.get_synonyms_for_lookup("test", max_results=5)

        # Registry called only once
        assert mock_registry.get_synonyms.call_count == 1
        assert orchestrator.cache_hit_rate == 0.5  # 1 hit, 1 miss

    @pytest.mark.asyncio
    async def test_ensure_synonyms_enrichment(self, mock_registry, mock_gpt4):
        """Verify GPT-4 enrichment when &lt;5 synonyms."""
        mock_registry.get_synonyms.return_value = [Mock(term="syn1")]  # Only 1
        mock_gpt4.suggest_synonyms.return_value = [
            Mock(synoniem="syn2", confidence=0.9),
            Mock(synoniem="syn3", confidence=0.85)
        ]

        orchestrator = SynonymOrchestrator(mock_registry, mock_gpt4)

        result, ai_count = await orchestrator.ensure_synonyms("test", min_count=5)

        # GPT-4 called (enrichment triggered)
        mock_gpt4.suggest_synonyms.assert_called_once()
        assert ai_count == 2

    def test_governance_policy_strict(self, mock_registry):
        """Verify strict policy excludes ai_pending."""
        mock_config = Mock(policy=SynonymPolicy.STRICT, min_weight=0.7)

        orchestrator = SynonymOrchestrator(mock_registry, Mock())
        orchestrator.config = mock_config

        orchestrator.get_synonyms_for_lookup("test")

        # Verify statuses parameter
        call_args = mock_registry.get_synonyms.call_args
        assert 'ai_pending' not in call_args.kwargs['statuses']</code></pre>

<h3>Integration Tests</h3>

<pre><code># tests/integration/test_synonym_flow_e2e.py

class TestSynonymFlowE2E:
    @pytest.mark.asyncio
    async def test_definition_generation_with_enrichment(self, db, gpt4_service):
        """E2E: Definitiegeneratie â†’ enrichment â†’ weblookup â†’ result."""
        # Setup: Empty registry
        registry = SynonymRegistry(db_path=db)
        orchestrator = SynonymOrchestrator(registry, gpt4_service)

        # Generate definition
        gen_orchestrator = DefinitionGenerationOrchestrator(
            synonym_orchestrator=orchestrator,
            web_lookup_service=...,
            definition_generator=...
        )

        result = await gen_orchestrator.generate_definition(
            term="voorlopige hechtenis",
            context={"domain": "strafrecht"}
        )

        # Verify flow
        assert result['definition'] is not None
        assert len(result['synonyms']) &gt;= 5  # Enrichment worked
        assert result['ai_pending_count'] &gt; 0  # GPT-4 added suggestions
        assert len(result['web_results']) &gt; 0  # Weblookup used synonyms

    def test_manual_edit_sync_to_registry(self, db):
        """Verify manual edit in definitie-editor syncs to registry."""
        repo = DefinitieRepository(db_path=db)
        registry = SynonymRegistry(db_path=db)

        # Create definitie
        definitie_id = repo.create_definitie(
            DefinitieRecord(begrip="test", definitie="...")
        )

        # Manual edit: add synoniemen
        repo.save_voorbeelden(
            definitie_id=definitie_id,
            voorbeelden_dict={
                'synoniemen': ['syn1', 'syn2', 'syn3']
            },
            gegenereerd_door='user'
        )

        # Verify in registry
        group = registry.find_group_by_term("test")
        assert group is not None

        members = registry.get_group_members(
            group_id=group.id,
            filters={'definitie_id': definitie_id}
        )
        assert len(members) == 3
        assert all(m.source == 'manual' for m in members)</code></pre>

<h3>Performance Tests</h3>

<pre><code># tests/performance/test_synonym_cache.py

def test_cache_performance_under_load(benchmark):
    """Verify cache hit rate under concurrent load."""
    orchestrator = SynonymOrchestrator(...)

    def query_synonyms():
        terms = ["term1", "term2", "term3"] * 100
        for term in terms:
            orchestrator.get_synonyms_for_lookup(term)

    benchmark(query_synonyms)

    # Target: &gt;80% hit rate
    assert orchestrator.cache_hit_rate &gt; 0.80</code></pre>

<p>---</p>

<h2>ğŸ“Š Monitoring & KPIs</h2>

<h3>Key Performance Indicators</h3>

<p>| <strong>KPI</strong> | <strong>Target</strong> | <strong>Alert Threshold</strong> | <strong>Query</strong> |</p>
<p>|---------|-----------|---------------------|-----------|</p>
<p>| Cache Hit Rate | > 80% | < 60% | <code>orchestrator.cache_hit_rate</code> |</p>
<p>| GPT-4 Success Rate | > 95% | < 90% | Parse <code>logs/synonym_enrichment.log</code> |</p>
<p>| Avg Enrichment Time | < 10s | > 20s | Log analysis |</p>
<p>| Pending Review Count | < 100 | > 500 (backlog) | <code>SELECT COUNT(*) FROM synonym_group_members WHERE status='ai_pending'</code> |</p>
<p>| Approval Rate | > 70% | < 50% | <code>SELECT status, COUNT(*) FROM ... GROUP BY status</code> |</p>
<p>| Orphaned Members | 0 | > 0 (integrity issue) | <code>SELECT COUNT(*) FROM ... LEFT JOIN ... WHERE g.id IS NULL</code> |</p>

<h3>Logging</h3>

<pre><code># Dedicated logger voor enrichment
enrichment_logger = logging.getLogger('synonym_enrichment')
handler = logging.FileHandler('logs/synonym_enrichment.log')
enrichment_logger.addHandler(handler)

# Log format:
# 2025-10-09 14:32:15 - INFO - Starting GPT-4 enrichment for 'voorlopige hechtenis'
# 2025-10-09 14:32:23 - INFO - Enrichment complete: 3 suggestions, duration: 8.2s
# 2025-10-09 14:32:45 - ERROR - GPT-4 timeout for 'term' after 30.1s</code></pre>

<h3>Metrics Dashboard (Streamlit)</h3>

<pre><code># src/ui/pages/synonym_metrics.py

def render_synonym_metrics_dashboard():
    st.title("ğŸ“Š Synonym System Metrics")

    # Cache Performance
    cache_stats = orchestrator.get_cache_stats()
    st.metric("Cache Hit Rate", f"{cache_stats['hit_rate']:.1%}")

    # GPT-4 Enrichment
    enrichment_stats = parse_enrichment_logs(hours=24)
    st.metric("Success Rate", f"{enrichment_stats['success_rate']:.1%}")

    # Approval Workflow
    approval_stats = registry.get_approval_statistics()
    st.metric("Pending Review", approval_stats['pending_count'])

    # Top Used Synonyms
    top_synonyms = registry.get_top_used_synonyms(limit=10)
    st.dataframe(top_synonyms)</code></pre>

<p>---</p>

<h2>ğŸš€ Implementation Roadmap</h2>

<h3>PHASE 1: Foundation (Week 1-2)</h3>
<ul>
<li>[ ] **Schema**: Create synonym_groups + synonym_group_members tables</li>
<li>[ ] **Registry**: Implement SynonymRegistry CRUD + callbacks</li>
<li>[ ] **Config**: Build SynonymConfiguration + YAML loader</li>
<li>[ ] **Migration**: Script met dry-run mode (3 bronnen)</li>
<li>[ ] **Tests**: Unit tests registry + config</li>
</ul>

<p><strong>Deliverable:</strong> Working registry with migration script (dry-run validated)</p>

<h3>PHASE 2: Orchestrator & Cache (Week 3)</h3>
<ul>
<li>[ ] **Orchestrator**: Build met TTL cache + invalidation</li>
<li>[ ] **FaÃ§ade**: Refactor JuridischeSynoniemService â†’ wrapper</li>
<li>[ ] **Integration**: Wire callbacks in ServiceContainer</li>
<li>[ ] **Tests**: Integration tests (cache, invalidation)</li>
</ul>

<p><strong>Deliverable:</strong> Orchestrator working with cache (>80% hit rate in tests)</p>

<h3>PHASE 3: Definition Generation Flow (Week 4)</h3>
<ul>
<li>[ ] **Pre-enrichment**: Integrate ensure_synonyms() in generator</li>
<li>[ ] **UX**: Implement pending review UI (popup/expander)</li>
<li>[ ] **Manual Edit**: Sync definitie-editor â†’ registry</li>
<li>[ ] **Tests**: E2E tests (generation â†’ enrichment â†’ review)</li>
</ul>

<p><strong>Deliverable:</strong> Complete flow: generatie â†’ enrichment â†’ weblookup â†’ review</p>

<h3>PHASE 4: Monitoring & Cleanup (Week 5)</h3>
<ul>
<li>[ ] **Logging**: Setup enrichment_logger + file handler</li>
<li>[ ] **Metrics**: Build Streamlit dashboard</li>
<li>[ ] **Cleanup**: Remove YAML + YAMLConfigUpdater</li>
<li>[ ] **Tests**: Full regression suite</li>
</ul>

<p><strong>Deliverable:</strong> Production-ready system met monitoring</p>

<h3>PHASE 5: Migration & Cutover (Week 6)</h3>
<ul>
<li>[ ] **Dry-run**: Execute migration (review output)</li>
<li>[ ] **Execute**: Run production migration</li>
<li>[ ] **Validation**: Verify 3 sources migrated correctly</li>
<li>[ ] **Monitor**: 48h monitoring (cache, errors, approvals)</li>
</ul>

<p><strong>Deliverable:</strong> System in production, old sources retired</p>

<p>---</p>

<h2>ğŸ“ˆ Success Metrics</h2>

<p>| <strong>Metric</strong> | <strong>Before</strong> | <strong>Target After</strong> |</p>
<p>|-----------|-----------|------------------|</p>
<p>| Data Sources | 3 (fragmented) | 1 (unified) |</p>
<p>| Code Complexity | High (YAML sync, async) | Medium (sync flow, TTL cache) |</p>
<p>| Cache Hit Rate | N/A | > 80% |</p>
<p>| Avg Definition Gen Time | ~20s | ~15s (with cache) |</p>
<p>| Test Coverage | Partial | 100% (deterministic) |</p>
<p>| Manual Review Backlog | N/A | < 100 pending |</p>
<p>| User Flow Steps | 2 (separate review) | 1 (integrated) |</p>

<p>---</p>

<h2>ğŸ” Security & Governance</h2>

<h3>Role-Based Access Control (Future)</h3>

<pre><code># Future: RBAC voor registry mutations
class SynonymRegistry:
    def approve_suggestion(self, member_id: int, approved_by: str):
        # Check role
        if not has_permission(approved_by, 'approve_synonyms'):
            raise PermissionError("User lacks approve_synonyms permission")

        self.update_member_status(member_id, 'active', approved_by)</code></pre>

<h3>Audit Trail</h3>

<p>Alle mutations worden gelogd:</p>
<ul>
<li>`created_by`, `reviewed_by`, `created_at`, `reviewed_at`</li>
<li>`context_json` bevat rationale + model info</li>
<li>Status transitions (ai_pending â†’ active/rejected)</li>
<li>Usage tracking (`usage_count`, `last_used_at`)</li>
</ul>

<p>---</p>

<h2>ğŸ“š References</h2>

<h3>Code Locations</h3>

<ul>
<li>**Registry**: `src/repositories/synonym_registry.py`</li>
<li>**Orchestrator**: `src/services/synonym_orchestrator.py`</li>
<li>**FaÃ§ade**: `src/services/web_lookup/synonym_service.py`</li>
<li>**Config**: `src/config/synonym_config.py`</li>
<li>**Migration**: `scripts/migrate_synonyms_to_registry.py`</li>
<li>**Tests**: `tests/services/test_synonym_*`</li>
</ul>

<h3>Related Documents</h3>

<ul>
<li>`CLAUDE.md` - Project guidelines</li>
<li>`docs/architectuur/SOLUTION_ARCHITECTURE.md` - Overall architecture</li>
<li>`docs/backlog/EPIC-XXX/` - Related epics/stories</li>
</ul>

<h3>External Dependencies</h3>

<ul>
<li>GPT-4 Turbo (via `GPT4SynonymSuggester`)</li>
<li>SQLite (graph-based schema)</li>
<li>Streamlit (metrics dashboard)</li>
</ul>

<p>---</p>

<h2>âœ… Approval</h2>

<p><strong>Status:</strong> âœ… <strong>APPROVED</strong> - Unanimous Consensus</p>

<p>All agents (PO, Architect, Developer, QA, Security) approve this design for implementation.</p>

<p><strong>Next Steps:</strong> Start PHASE 1 (Foundation)</p>

<p>---</p>

<p><em>Generated: 2025-10-09</em></p>
<p><em>Version: 3.1 (Final)</em></p>
<p><em>Review Status: Multi-Agent Consensus Approved</em></p>

  </div>
</body>
</html>