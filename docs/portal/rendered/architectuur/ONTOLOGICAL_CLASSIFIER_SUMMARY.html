<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ontological Classifier - Executive Summary</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <h1>Ontological Classifier - Executive Summary</h1>

<p><strong>Datum</strong>: 2025-10-07</p>
<p><strong>Status</strong>: Design Complete, Ready for Implementation</p>
<p><strong>Beslissing</strong>: Optie 2 PLUS - Standalone Service met Optional Facade</p>

<p>---</p>

<h2>TL;DR</h2>

<p><strong>OntologicalClassifier is een standalone, first-class service die VOOR definitie generatie classificeert.</strong></p>

<pre><code># Gebruik in UI (3 simpele stappen):
classifier = container.ontological_classifier()
result = classifier.classify(begrip, org_ctx, jur_ctx)
request.ontologische_categorie = result.to_string_level()</code></pre>

<p>---</p>

<h2>1. Architectuur Beslissing</h2>

<h3>GEKOZEN: Standalone Service (Optie 2 PLUS)</h3>

<pre><code>ServiceContainer
‚îú‚îÄ‚îÄ ontological_classifier()  ‚Üê STANDALONE (altijd beschikbaar)
‚îú‚îÄ‚îÄ orchestrator()             ‚Üê Gebruikt categorie uit request
‚îî‚îÄ‚îÄ service_adapter()          ‚Üê OPTIONAL facade (gemak)</code></pre>

<p><strong>Waarom Standalone?</strong></p>

<p>| Criterium | Standalone ‚úÖ | Nested ‚ùå |</p>
<p>|-----------|--------------|----------|</p>
<p>| <strong>Timing</strong> | VOOR generatie (correct) | Tijdens generatie (te laat) |</p>
<p>| <strong>Herbruikbaar</strong> | UI, CLI, batch, validatie | Alleen via orchestrator |</p>
<p>| <strong>Testbaar</strong> | Unit tests in isolatie | Vereist orchestrator |</p>
<p>| <strong>Flexibel</strong> | UI kan result tonen/override | Hidden binnen orchestrator |</p>

<p>---</p>

<h2>2. API Design</h2>

<h3>2.1 Core Classifier</h3>

<pre><code>from services.classification import OntologicalClassifier, ClassificationResult

# Via DI
classifier = container.ontological_classifier()

# Classificeer single
result = classifier.classify(
    begrip="Overeenkomst",
    organisatorische_context="...",
    juridische_context="..."
)

# Result bevat:
# - result.level: OntologicalLevel (U/F/O)
# - result.confidence: float (0.0-1.0)
# - result.rationale: str (waarom dit niveau?)
# - result.is_reliable: bool (confidence &gt;= 60%)

# Gebruik in request
request.ontologische_categorie = result.to_string_level()  # "U"/"F"/"O"</code></pre>

<h3>2.2 Batch Processing</h3>

<pre><code># Classificeer meerdere begrippen
results = classifier.classify_batch(
    begrippen=["Overeenkomst", "Perceel", "Rechtspersoon"],
    shared_context=("Gemeente", "BW")
)

# Returns: dict[str, ClassificationResult]
for begrip, result in results.items():
    print(f"{begrip}: {result.level.value} ({result.confidence:.1%})")</code></pre>

<h3>2.3 Validation</h3>

<pre><code># Valideer bestaande definitie
is_correct, reason = classifier.validate_existing_definition(
    begrip="Overeenkomst",
    claimed_level="F",
    definition_text="..."
)

if not is_correct:
    print(f"Mismatch: {reason}")</code></pre>

<p>---</p>

<h2>3. UI Integration (Complete Flow)</h2>

<h3>Stap 1: Classificeer VOOR Generatie</h3>

<pre><code># In definition_generator_tab.py

def handle_generate_button_click():
    # Haal classifier
    container = st.session_state.service_container
    classifier = container.ontological_classifier()

    # Classificeer
    result = classifier.classify(
        begrip=begrip,
        organisatorische_context=org_context,
        juridische_context=jur_context
    )

    # Toon result (optioneel)
    st.info(
        f"üî∂ Geclassificeerd als: **{result.level.value}** "
        f"(confidence: {result.confidence:.1%})"
    )

    if not result.is_reliable:
        st.warning("‚ö†Ô∏è Lage betrouwbaarheid, voeg meer context toe")

    # Gebruik in request
    request = GenerationRequest(
        begrip=begrip,
        ontologische_categorie=result.to_string_level(),  # ‚Üê HIER
        organisatorische_context=org_context,
        # ... rest
    )

    # Genereer definitie
    response = await orchestrator.create_definition(request)</code></pre>

<h3>Stap 2: Toon Classificatie Details (Optioneel)</h3>

<pre><code>def display_classification_result(result: ClassificationResult):
    """Toon classificatie aan gebruiker met details"""

    # Header
    emoji = {"U": "üî∑", "F": "üî∂", "O": "üü†"}[result.level.value]
    st.success(f"{emoji} **Niveau: {result.level.value}**")

    # Confidence indicator
    color = {"high": "green", "medium": "orange", "low": "red"}
    st.markdown(
        f"Betrouwbaarheid: &lt;span style='color:{color[result.confidence_level.value]}'&gt;"
        f"{result.confidence_level.value.upper()}&lt;/span&gt;",
        unsafe_allow_html=True
    )

    # Rationale (waarom dit niveau?)
    with st.expander("üìñ Waarom dit niveau?"):
        st.write(result.rationale)

        # Alle scores
        for level, score in result.scores.items():
            st.write(f"**{level}**: {score:.1%}")</code></pre>

<p>---</p>

<h2>4. ServiceAdapter (Optional Gemak)</h2>

<pre><code># Optioneel: Gebruik adapter voor auto-classificatie

adapter = container.service_adapter()

# Auto-classify + generate in √©√©n call
response, classification = await adapter.generate_with_auto_classification(
    begrip="Overeenkomst",
    organisatorische_context="...",
    juridische_context="..."
)

# Response = GenerationResponse (zoals normaal)
# Classification = ClassificationResult (voor info)</code></pre>

<p><strong>Wanneer Adapter Gebruiken?</strong></p>

<ul>
<li>‚úÖ Simpele flows zonder gebruiker interactie met classificatie</li>
<li>‚úÖ Prototype/testing</li>
<li>‚ùå Als je classificatie wilt tonen aan gebruiker</li>
<li>‚ùå Als je manual override wilt toestaan</li>
</ul>

<p>---</p>

<h2>5. Herbruikbaarheid Voorbeelden</h2>

<h3>5.1 CLI Tool</h3>

<pre><code># Standalone classificatie
python -m scripts.classify_term "Overeenkomst" --org-context "Gemeente"

# Batch classificatie
python -m scripts.classify_batch --input begrippen.csv --output results.csv</code></pre>

<h3>5.2 Database Validatie Script</h3>

<pre><code># scripts/validate_classifications.py

def validate_all_definitions():
    container = ServiceContainer()
    classifier = container.ontological_classifier()
    repo = container.repository()

    definitions = repo.get_all()
    mismatches = []

    for definition in definitions:
        is_correct, reason = classifier.validate_existing_definition(
            begrip=definition.begrip,
            claimed_level=definition.ontologische_categorie,
            definition_text=definition.definitie
        )

        if not is_correct:
            mismatches.append((definition.begrip, reason))

    return mismatches</code></pre>

<h3>5.3 Jupyter Notebook Analyse</h3>

<pre><code># notebooks/classification_analysis.ipynb

import pandas as pd
from services.container import ServiceContainer

container = ServiceContainer()
classifier = container.ontological_classifier()

# Batch classificatie
begrippen = ["Overeenkomst", "Perceel", "Rechtspersoon", ...]
results = classifier.classify_batch(begrippen)

# Analyse
df = pd.DataFrame([
    {
        "begrip": begrip,
        "niveau": r.level.value,
        "confidence": r.confidence,
        "betrouwbaar": r.is_reliable
    }
    for begrip, r in results.items()
])

# Visualiseer
df["niveau"].value_counts().plot(kind="bar")</code></pre>

<p>---</p>

<h2>6. Dependency Injection Setup</h2>

<h3>In ServiceContainer</h3>

<pre><code># src/services/container.py

class ServiceContainer:

    def ontological_classifier(self):
        """Standalone ontological classifier (U/F/O)"""
        if "ontological_classifier" not in self._instances:
            from services.classification import OntologicalClassifier
            from services.ai_service_v2 import AIServiceV2

            ai_service = AIServiceV2(
                default_model=self.generator_config.gpt.model,
                use_cache=True
            )

            self._instances["ontological_classifier"] = OntologicalClassifier(
                ai_service
            )

        return self._instances["ontological_classifier"]

    def service_adapter(self):
        """Optional facade (classificatie + generatie)"""
        if "service_adapter" not in self._instances:
            from services.service_adapter import ServiceAdapter

            self._instances["service_adapter"] = ServiceAdapter(
                classifier=self.ontological_classifier(),
                orchestrator=self.orchestrator()
            )

        return self._instances["service_adapter"]</code></pre>

<p>---</p>

<h2>7. File Locations</h2>

<h3>Nieuwe Bestanden</h3>

<pre><code>src/services/classification/
‚îú‚îÄ‚îÄ __init__.py                      # ‚úÖ UPDATED (export OntologicalClassifier)
‚îú‚îÄ‚îÄ ontological_classifier.py        # ‚úÖ CREATED (standalone classifier)
‚îî‚îÄ‚îÄ ontology_classifier.py           # (existing, legacy)

src/services/
‚îú‚îÄ‚îÄ container.py                     # ‚úÖ UPDATED (add ontological_classifier method)
‚îî‚îÄ‚îÄ service_adapter.py               # TODO: OPTIONAL (facade)

docs/architectuur/
‚îú‚îÄ‚îÄ ontological_classifier_standalone_architecture.md  # ‚úÖ CREATED (full design)
‚îî‚îÄ‚îÄ ONTOLOGICAL_CLASSIFIER_SUMMARY.md                 # ‚úÖ CREATED (this file)

docs/examples/
‚îú‚îÄ‚îÄ classifier_integration_ui.py                      # ‚úÖ CREATED (UI examples)
‚îî‚îÄ‚îÄ service_adapter_with_classifier.py                # ‚úÖ CREATED (adapter examples)</code></pre>

<h3>Te Wijzigen Bestanden</h3>

<pre><code>src/ui/components/
‚îî‚îÄ‚îÄ definition_generator_tab.py      # TODO: Add classification step

src/ui/
‚îî‚îÄ‚îÄ tabbed_interface.py              # TODO: Wire up classifier in main flow

tests/services/classification/
‚îî‚îÄ‚îÄ test_ontological_classifier.py   # TODO: Unit tests

tests/integration/
‚îî‚îÄ‚îÄ test_classification_workflow.py  # TODO: Integration tests</code></pre>

<p>---</p>

<h2>8. Implementation Checklist</h2>

<h3>Core Implementation</h3>

<ul>
<li>[x] Create `OntologicalClassifier` class</li>
<li>[x] Add to `ServiceContainer`</li>
<li>[x] Update `__init__.py` exports</li>
<li>[ ] Write unit tests</li>
<li>[ ] Write integration tests</li>
</ul>

<h3>UI Integration</h3>

<ul>
<li>[ ] Update `definition_generator_tab.py` to use classifier</li>
<li>[ ] Add classification result display component</li>
<li>[ ] Add manual override UI (for low confidence)</li>
<li>[ ] Update main flow in `tabbed_interface.py`</li>
</ul>

<h3>Optional Enhancements</h3>

<ul>
<li>[ ] Create `ServiceAdapter` (optional facade)</li>
<li>[ ] Create CLI classification tool</li>
<li>[ ] Create batch validation script</li>
<li>[ ] Create Jupyter notebook for analysis</li>
</ul>

<h3>Documentation</h3>

<ul>
<li>[x] Architecture document</li>
<li>[x] API documentation</li>
<li>[x] Usage examples</li>
<li>[ ] Update CLAUDE.md</li>
<li>[ ] Update INDEX.md</li>
</ul>

<p>---</p>

<h2>9. Testing Strategy</h2>

<h3>Unit Tests</h3>

<pre><code># tests/services/classification/test_ontological_classifier.py

def test_classify_returns_result():
    classifier = OntologicalClassifier(mock_ai_service)
    result = classifier.classify("Overeenkomst")

    assert isinstance(result, ClassificationResult)
    assert result.level in [U, F, O]
    assert 0.0 &lt;= result.confidence &lt;= 1.0

def test_batch_classification():
    results = classifier.classify_batch(["Term1", "Term2"])
    assert len(results) == 2

def test_validate_existing_definition():
    is_correct, reason = classifier.validate_existing_definition(...)
    assert isinstance(is_correct, bool)</code></pre>

<h3>Integration Tests</h3>

<pre><code># tests/integration/test_classification_workflow.py

@pytest.mark.integration
async def test_full_flow():
    # Stap 1: Classificeer
    result = classifier.classify("Overeenkomst")

    # Stap 2: Genereer met classificatie
    request.ontologische_categorie = result.to_string_level()
    response = await orchestrator.create_definition(request)

    assert response.success</code></pre>

<p>---</p>

<h2>10. Key Takeaways</h2>

<ol>
<li>**Standalone Service** - OntologicalClassifier is een first-class service, niet nested</li>
<li>**Pre-Generation** - ALTIJD classificeren VOOR `create_definition()`</li>
<li>**DI Accessible** - Beschikbaar via `container.ontological_classifier()`</li>
<li>**Herbruikbaar** - UI, CLI, batch, validatie kunnen allemaal classifier gebruiken</li>
<li>**Optional Facade** - ServiceAdapter is gemak, niet verplicht</li>
<li>**Type Safe** - ClassificationResult is dataclass met helper methods</li>
<li>**Testable** - Unit + integration tests in isolatie</li>
</ol>

<p>---</p>

<h2>11. Next Steps</h2>

<ol>
<li>**Review**: Team review van design decisions</li>
<li>**Implement**: Core `OntologicalClassifier` class (‚úÖ DONE)</li>
<li>**Test**: Write unit + integration tests</li>
<li>**Integrate**: Update UI to use classifier</li>
<li>**Validate**: Test met echte begrippen</li>
<li>**Document**: Update CLAUDE.md en INDEX.md</li>
</ol>

<p>---</p>

<h2>Contact</h2>

<p>Voor vragen over deze architectuur, zie:</p>
<ul>
<li>**Full Design**: `docs/architectuur/ontological_classifier_standalone_architecture.md`</li>
<li>**UI Examples**: `docs/examples/classifier_integration_ui.py`</li>
<li>**Adapter Examples**: `docs/examples/service_adapter_with_classifier.py`</li>
</ul>

  </div>
</body>
</html>