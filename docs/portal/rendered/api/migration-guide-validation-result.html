<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Migration Guide: ValidationResult Changes</title>
  <link rel="stylesheet" href="../portal.css" />
  <style>
    .doc { max-width: 900px; margin: 16px auto 48px auto; padding: 0 16px; }
    .doc h1,.doc h2,.doc h3,.doc h4{ color:#223 }
    .doc p{ line-height:1.6; color:#222 }
    .doc a{ color:#1d4ed8; text-decoration: underline; }
    .doc pre{ background:#0b1020; color:#e6edf3; padding:12px; overflow:auto; border-radius:8px }
    .doc code{ background:#f0f2f5; padding:2px 6px; border-radius:4px }
    .back{ display:inline-block; margin:12px 0; padding:6px 10px; border:1px solid #ccd; border-radius:6px; text-decoration:none; color:#223; background:#f8f9fb }
  </style>
</head>
<body>
  <div class="doc">
    <a class="back" href="../../index.html">‚Üê Terug naar Portal</a>
    <h1>Migration Guide: ValidationResult Changes</h1>

<h2>Overview</h2>
<p>As part of Story 2.3, the <code>ModularValidationService</code> now returns plain dictionaries instead of <code>ValidationResult</code> objects. This guide helps you migrate existing code to work with the new format.</p>

<h2>Key Changes</h2>

<h3>1. ValidationResult is now a Dict</h3>

<p><strong>Before (Object):</strong></p>
<pre><code>result = await validator.validate(definition)
if result.is_valid:
    print(f"Score: {result.score}")
    for error in result.errors:
        print(error)</code></pre>

<p><strong>After (Dict):</strong></p>
<pre><code>result = await validator.validate_definition(begrip, text)
if result["is_acceptable"]:
    print(f"Score: {result['overall_score']}")
    for violation in result["violations"]:
        print(violation["message"])</code></pre>

<h3>2. Property Mappings</h3>

<p>| Old Property | New Dict Key | Notes |</p>
<p>|--------------|--------------|-------|</p>
<p>| <code>result.is_valid</code> | <code>result["is_acceptable"]</code> | Boolean validation status |</p>
<p>| <code>result.score</code> | <code>result["overall_score"]</code> | Float 0.0-1.0 |</p>
<p>| <code>result.errors</code> | <code>result["violations"]</code> | List of violation dicts |</p>
<p>| <code>result.warnings</code> | <code>result["violations"]</code> | Filtered by severity |</p>
<p>| <code>result.metadata</code> | <code>result["system"]</code> | System metadata |</p>

<h3>3. Violation Structure Changes</h3>

<p><strong>Before:</strong></p>
<pre><code>error = ValidationError(
    message="Definition too short",
    severity="error",
    code="LENGTH_ERROR"
)</code></pre>

<p><strong>After:</strong></p>
<pre><code>violation = {
    "code": "VAL-LEN-001",
    "severity": "error",
    "message": "Definition is shorter than minimum length",
    "rule_id": "VAL-LEN-001",
    "category": "juridisch"
}</code></pre>

<h2>Migration Strategies</h2>

<h3>Strategy 1: Direct Dict Access (Recommended)</h3>

<p>Update your code to use dictionary access:</p>

<pre><code># Before
if validation_result.is_valid:
    score = validation_result.score

# After
if validation_result.get("is_acceptable", False):
    score = validation_result.get("overall_score", 0.0)</code></pre>

<h3>Strategy 2: Wrapper Class (For Gradual Migration)</h3>

<p>Create a wrapper to maintain object-style access:</p>

<pre><code>class ValidationResultAdapter:
    def __init__(self, result_dict):
        self._data = result_dict

    @property
    def is_valid(self):
        return self._data.get("is_acceptable", False)

    @property
    def score(self):
        return self._data.get("overall_score", 0.0)

    @property
    def errors(self):
        return self._data.get("violations", [])

    def __getitem__(self, key):
        return self._data[key]

# Usage
result_dict = await validator.validate_definition(begrip, text)
result = ValidationResultAdapter(result_dict)

# Now you can use both styles
if result.is_valid:  # Object style
    print(result["overall_score"])  # Dict style</code></pre>

<h3>Strategy 3: Compatibility Layer (Already Implemented)</h3>

<p>The <code>service_factory.py</code> already includes backwards compatibility:</p>

<pre><code># Automatically handles both formats
"validation_score": (
    response.validation_result.get("overall_score", 0.0)
    if isinstance(response.validation_result, dict)
    else response.validation_result.score
    if hasattr(response.validation_result, "score")
    else 0.0
)</code></pre>

<h2>Common Migration Patterns</h2>

<h3>Pattern 1: Validation Checks</h3>

<pre><code># Before
if not validator.validate(definition).is_valid:
    raise ValidationError("Invalid definition")

# After
result = await validator.validate_definition(begrip, text)
if not result.get("is_acceptable", False):
    raise ValidationError("Invalid definition")</code></pre>

<h3>Pattern 2: Error Collection</h3>

<pre><code># Before
errors = []
for error in validation_result.errors:
    errors.append(error.message)

# After
errors = []
for violation in validation_result.get("violations", []):
    errors.append(violation["message"])</code></pre>

<h3>Pattern 3: Score Thresholds</h3>

<pre><code># Before
if validation_result.score &lt; 0.75:
    log.warning(f"Low score: {validation_result.score}")

# After
score = validation_result.get("overall_score", 0.0)
if score &lt; 0.75:
    log.warning(f"Low score: {score}")</code></pre>

<h3>Pattern 4: Filtering by Severity</h3>

<pre><code># Before
errors = [e for e in result.errors if e.severity == "error"]
warnings = [e for e in result.errors if e.severity == "warning"]

# After
violations = result.get("violations", [])
errors = [v for v in violations if v["severity"] == "error"]
warnings = [v for v in violations if v["severity"] == "warning"]</code></pre>

<h2>Testen Your Migration</h2>

<h3>Unit Test Updates</h3>

<pre><code># Before
def test_validation():
    result = Mock()
    result.is_valid = True
    result.score = 0.85

# After
def test_validation():
    result = {
        "is_acceptable": True,
        "overall_score": 0.85,
        "violations": []
    }</code></pre>

<h3>Integration Test Updates</h3>

<pre><code># Before
@patch('validator.validate')
def test_integration(mock_validate):
    mock_validate.return_value.is_valid = True

# After
@patch('validator.validate_definition')
async def test_integration(mock_validate):
    mock_validate.return_value = {
        "is_acceptable": True,
        "overall_score": 0.9
    }</code></pre>

<h2>Deprecation Timeline</h2>

<ul>
<li>**Current**: Both object and dict formats supported</li>
<li>**Next Release**: Dict format is default, object format deprecated</li>
<li>**Future**: Object format removed</li>
</ul>

<h2>Need Help?</h2>

<p>If you encounter issues during migration:</p>

<ol>
<li>Check if `service_factory.py` compatibility layer handles your case</li>
<li>Use the `ValidationResultAdapter` wrapper for gradual migration</li>
<li>Run tests with both formats to ensure compatibility</li>
</ol>

<h2>Benefits of the New Format</h2>

<ol>
<li>**JSON Serializable**: Direct database storage without custom serializers</li>
<li>**Type Safety**: TypedDict provides better IDE support</li>
<li>**Prestaties**: No object instantiation overhead</li>
<li>**Consistency**: Same format across all services</li>
<li>**Schema Validation**: Can validate against JSON Schema</li>
</ol>

  </div>
</body>
</html>